<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UE4中的Serialization</title>
    <url>/ue4-serialization/</url>
    <content><![CDATA[<p>这一次要好好的理解UE4中的Serialization这个概念。<br><a id="more"></a></p>
<h1 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h1><h1 id="NetWorking-Serialization"><a href="#NetWorking-Serialization" class="headerlink" title="NetWorking Serialization"></a>NetWorking Serialization</h1><p>关于Networking的序列化操作是一个很久之前就困扰我的谜题，有那么一段代码我经常会看见，知道是为了什么而存在的但是不知道需要怎么用，这次就让我彻底的了解这些个代码。</p>
<h2 id="Custom-Struct-Serialization"><a href="#Custom-Struct-Serialization" class="headerlink" title="Custom Struct Serialization"></a>Custom Struct Serialization</h2><p>关于UE4中的自定义的<code>USTRUCT</code>类型的网络序列化问题，为了缩减RPC调用的带宽(bandwidth)，UE4提供了很强大的序列化功能。但是这不是自动的，需要我们做一些设置。</p>
<p>很早以前就一直发现但是一直没有仔细看和整理的文章</p>
<ul>
<li><a href="http://www.aclockworkberry.com/custom-struct-serialization-for-networking-in-unreal-engine/" target="_blank" rel="noopener">Custom Struct Serialization for Networking in Unreal Engine</a></li>
</ul>
<p>当我们使用UE4提供的<strong>USTRUCT</strong>自定义了一个结构体之后，我们可以为其添加一个<code>NetSerialize</code>函数，来为UE4的Networking中<strong>属性复制(Properties Replication)</strong>和<strong>RPC</strong>提供序列化(Serialization)和反序列化(Deserialization)方法。</p>
<p>这是基于UE4所提供的<strong>struct trait system</strong>之上的。</p>
<p>关于如何使用这个函数其实在UE4的源码中也有大量的使用案例和Mannual，最集中的就是源码了。</p>
<ul>
<li><strong>Runtime/Engine/Classes/Engine/NetSerialization.h</strong></li>
</ul>
<p>关于这个方法的定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param Ar FArchive to read or write from.</span></span><br><span class="line"><span class="comment"> * @param Map PackageMap used to resolve references to UObject*</span></span><br><span class="line"><span class="comment"> * @param bOutSuccess return value to signify if the serialization was succesfull (if false, an error will be logged by the calling function)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return return true if the serialization was fully mapped. If false, the property will be considered 'dirty' and will replicate again on the next update.</span></span><br><span class="line"><span class="comment"> * This is needed for UActor* properties. If an actor's Actorchannel is not fully mapped, properties referencing it must stay dirty.</span></span><br><span class="line"><span class="comment"> * Note that UPackageMap::SerializeObject returns false if an object is unmapped. Generally, you will want to return false from your ::NetSerialize</span></span><br><span class="line"><span class="comment"> * if you make any calls to ::SerializeObject that return false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, class UPackageMap* Map, <span class="keyword">bool</span>&amp; bOutSuccess)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>结构体中的使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">USTRUCT()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FMyCustomNetSerializableStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	UPROPERTY()</span><br><span class="line">	<span class="keyword">float</span> SomeProperty;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, class UPackageMap* Map, <span class="keyword">bool</span>&amp; bOutSuccess)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TStructOpsTypeTraits</span>&lt;FMyCustomNetSerializableStruct&gt; :</span> <span class="keyword">public</span> TStructOpsTypeTraitsBase2&lt;FMyCustomNetSerializableStruct&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithNetSerializer = <span class="literal">true</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的模板类型匹配是UE4会自动调用我们自定义结构体中<code>NetSerialize</code>函数的关键，如果我们不提供这样的类型匹配不将<code>WithNetSerializer</code>设为true，那这个函数不会被调用，当然自己在别的函数中手动调用的话除外。</p>
<p>除了<code>WithNetSerializer</code>这个之外，UE4还提供了许多其他的特征(type traits):<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime/CoreUObject/Public/UObject/Class.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** type traits to cover the custom aspects of a script struct **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TStructOpsTypeTraitsBase</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">enum</span></span><br><span class="line">	&#123;</span><br><span class="line">		WithZeroConstructor            = <span class="literal">false</span>, <span class="comment">// struct can be constructed as a valid object by filling its memory footprint with zeroes.</span></span><br><span class="line">		WithNoInitConstructor          = <span class="literal">false</span>, <span class="comment">// struct has a constructor which takes an EForceInit parameter which will force the constructor to perform initialization, where the default constructor performs 'uninitialization'.</span></span><br><span class="line">		WithNoDestructor               = <span class="literal">false</span>, <span class="comment">// struct will not have its destructor called when it is destroyed.</span></span><br><span class="line">		WithCopy                       = <span class="literal">false</span>, <span class="comment">// struct can be copied via its copy assignment operator.</span></span><br><span class="line">		WithIdenticalViaEquality       = <span class="literal">false</span>, <span class="comment">// struct can be compared via its operator==.  This should be mutually exclusive with WithIdentical.</span></span><br><span class="line">		WithIdentical                  = <span class="literal">false</span>, <span class="comment">// struct can be compared via an Identical(const T* Other, uint32 PortFlags) function.  This should be mutually exclusive with WithIdenticalViaEquality.</span></span><br><span class="line">		WithExportTextItem             = <span class="literal">false</span>, <span class="comment">// struct has an ExportTextItem function used to serialize its state into a string.</span></span><br><span class="line">		WithImportTextItem             = <span class="literal">false</span>, <span class="comment">// struct has an ImportTextItem function used to deserialize a string into an object of that class.</span></span><br><span class="line">		WithAddStructReferencedObjects = <span class="literal">false</span>, <span class="comment">// struct has an AddStructReferencedObjects function which allows it to add references to the garbage collector.</span></span><br><span class="line">		WithSerializer                 = <span class="literal">false</span>, <span class="comment">// struct has a Serialize function for serializing its state to an FArchive.</span></span><br><span class="line">		WithPostSerialize              = <span class="literal">false</span>, <span class="comment">// struct has a PostSerialize function which is called after it is serialized</span></span><br><span class="line">		WithNetSerializer              = <span class="literal">false</span>, <span class="comment">// struct has a NetSerialize function for serializing its state to an FArchive used for network replication.</span></span><br><span class="line">		WithNetDeltaSerializer         = <span class="literal">false</span>, <span class="comment">// struct has a NetDeltaSerialize function for serializing differences in state from a previous NetSerialize operation.</span></span><br><span class="line">		WithSerializeFromMismatchedTag = <span class="literal">false</span>, <span class="comment">// struct has a SerializeFromMismatchedTag function for converting from other property tags.</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>关于原文中有这样一段：</p>
<blockquote>
<p>The <code>FArchive</code> is a class which implements a common pattern for data serialization, allowing the writing of two-way functions. Basically, when it comes to serialization, you have to make sure that the way you serialize your data is exactly the same you use for deserialization. The best way to ensure this behavior is to write one single context-sensitive function that does both. The black magic of the <code>FArchive</code> lays in its overloaded <code>&lt;&lt;</code> operator. This operator is at the base of the creation of two-way functions. Its behavior is context-sensitive: when the <code>FArchive</code> is in write mode, it copies data from right to left, when the <code>FArchive</code> is in read mode, it copies data from left to right.</p>
</blockquote>
<p><code>&lt;&lt;</code>看似是单向的其实是双向的，真的神奇。</p>
<p>作者用这里的代码作为参考：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Runtime/Core/Private/Math/UnrealMath.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FRotator::SerializeCompressed( FArchive&amp; Ar )</span><br><span class="line">&#123;</span><br><span class="line">	uint8 BytePitch = FRotator::CompressAxisToByte(Pitch);</span><br><span class="line">	uint8 ByteYaw = FRotator::CompressAxisToByte(Yaw);</span><br><span class="line">	uint8 ByteRoll = FRotator::CompressAxisToByte(Roll);</span><br><span class="line"></span><br><span class="line">	uint8 B = (BytePitch!=<span class="number">0</span>);</span><br><span class="line">	Ar.SerializeBits( &amp;B, <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">if</span>( B )</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; BytePitch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		BytePitch = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	B = (ByteYaw!=<span class="number">0</span>);</span><br><span class="line">	Ar.SerializeBits( &amp;B, <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">if</span>( B )</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; ByteYaw;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ByteYaw = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	B = (ByteRoll!=<span class="number">0</span>);</span><br><span class="line">	Ar.SerializeBits( &amp;B, <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">if</span>( B )</span><br><span class="line">	&#123;</span><br><span class="line">		Ar &lt;&lt; ByteRoll;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		ByteRoll = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里就是context-sensitive：只有在archive处于read mode的时候数据会被还原到结构体的属性中</span></span><br><span class="line">	<span class="keyword">if</span>( Ar.IsLoading() )</span><br><span class="line">	&#123;</span><br><span class="line">		Pitch = FRotator::DecompressAxisFromByte(BytePitch);</span><br><span class="line">		Yaw	= FRotator::DecompressAxisFromByte(ByteYaw);</span><br><span class="line">		Roll = FRotator::DecompressAxisFromByte(ByteRoll);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这在我们MultiplayerNetworking中是一个相当有用的特性。比如说当我们想要复制玩家的control的时候，我们需要将这些数据同步到其他客户端上，我们可以像上面的例子一样，将每一个control的数据压缩到一个字节中，而且仅当这个数据不为0，由于我们的控制也许大部分时间都是处于0的状态，这样就可以节省大量的带宽。下面是作者给出的例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NetSerialize</span><span class="params">(FArchive&amp; Ar, class UPackageMap* Map, <span class="keyword">bool</span>&amp; bOutSuccess)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 ByteAcceleration  = FMath::Quantize8UnsignedByte(Acceleration);</span><br><span class="line">    uint8 ByteBrake         = FMath::Quantize8UnsignedByte(Brake);</span><br><span class="line">    uint8 ByteTurn          = FMath::Quantize8SignedByte(Turn);</span><br><span class="line">    uint8 BytePitch         = FMath::Quantize8SignedByte(Pitch);</span><br><span class="line">    uint8 ByteRoll          = FMath::Quantize8SignedByte(Roll);</span><br><span class="line"></span><br><span class="line">    uint8 B = (ByteAcceleration != <span class="number">0</span>);</span><br><span class="line">    Ar.SerializeBits(&amp;B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (B)  Ar &lt;&lt; ByteAcceleration; <span class="keyword">else</span> ByteAcceleration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    B = (ByteBrake != <span class="number">0</span>);</span><br><span class="line">    Ar.SerializeBits(&amp;B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (B) Ar &lt;&lt; ByteBrake; <span class="keyword">else</span> ByteBrake = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    B = (ByteTurn != <span class="number">0</span>);</span><br><span class="line">    Ar.SerializeBits(&amp;B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (B) Ar &lt;&lt; ByteTurn; <span class="keyword">else</span> ByteTurn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    B = (BytePitch != <span class="number">0</span>);</span><br><span class="line">    Ar.SerializeBits(&amp;B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (B) Ar &lt;&lt; BytePitch; <span class="keyword">else</span> BytePitch = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    B = (ByteRoll != <span class="number">0</span>);</span><br><span class="line">    Ar.SerializeBits(&amp;B, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (B) Ar &lt;&lt; ByteRoll; <span class="keyword">else</span> ByteRoll = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Ar.IsLoading())</span><br><span class="line">    &#123;</span><br><span class="line">        Acceleration    = Decompress8UnsignedByte(ByteAcceleration);</span><br><span class="line">        Brake           = Decompress8UnsignedByte(ByteBrake);</span><br><span class="line">        Turn            = Decompress8SignedByte(ByteTurn);</span><br><span class="line">        Pitch           = Decompress8SignedByte(BytePitch);</span><br><span class="line">        Roll            = Decompress8SignedByte(ByteRoll);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于UE4中提供的可以快速序列化和反序列化的类型：</p>
<blockquote>
<p>Unreal Engine implements a generic data serialization for atomic properties of an Actor like ints, floats, objects* and a generic delta serialization for dynamic properties like TArrays. Delta serialization is performed by comparing a previous base state with the current state and generating a diff state and a full state to be used as a base state for the next delta serialization.</p>
</blockquote>
<p>可以知道的有<code>ints</code>,<code>floats</code>,<code>object*</code>,还有<code>TArray</code>。数组对应的应该也是那些基础类型。</p>
<p>数组的实现有些特殊，<strong>DeltaSerialization for Dynamic properties</strong>，DeltaSerialization是通过之前的<strong>base state</strong>和现在的<strong>current state</strong>进行对比生成一个<strong>diff state</strong>和一个<strong>full state</strong>,这个<strong>full state</strong>则会作为下次的<strong>DeltaSerialization</strong>的<strong>base state</strong>。</p>
<p>而在<strong>USTRUCT</strong>中也是可以对上面的<strong>DeltaSerialization</strong>实现自定义的。通过定义一个<code>NetDeltaSerialize</code>函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param DeltaParms	Generic struct of input parameters for delta serialization</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return return true if the serialization was fully mapped. If false, the property will be considered 'dirty' and will replicate again on the next update.</span></span><br><span class="line"><span class="comment"> *	This is needed for UActor* properties. If an actor's Actorchannel is not fully mapped, properties referencing it must stay dirty.</span></span><br><span class="line"><span class="comment"> *	Note that UPackageMap::SerializeObject returns false if an object is unmapped. Generally, you will want to return false from your ::NetSerialize</span></span><br><span class="line"><span class="comment"> *  if you make any calls to ::SerializeObject that return false.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NetDeltaSerialize</span><span class="params">(FNetDeltaSerializeInfo &amp; DeltaParms)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>上面提到的UE4的Serialization源码中有很多实现的教程。</p>
<p><strong>Custom net delta serialization</strong>主要是跟<strong>Fast TArray Replication(FTR)</strong>结合使用的。<br>基本上如果我们想要有效的对<strong>TArray</strong>进行复制(replicated)，又或者想要在客户端检测到add和remove的事件，那么就非常推荐我们在struct中使用FTR。</p>
<p>下面是关于FTR的代码源码的注释说明：</p>
<blockquote>
<p>Fast TArray Replication is a custom implementation of NetDeltaSerialize that is suitable for TArrays of UStructs. It offers performance improvements for large data sets, it serializes removals from anywhere in the array optimally, and allows events to be called on clients for adds and removals. The downside is that you will need to have game code mark items in the array as dirty, and well as the order of the list is not guaranteed to be identical between client and server in all cases.</p>
</blockquote>
<p>这是关于如何在自定义的struct中使用FTR的例子，来自于UE4的源码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Step 1: Make your struct inherit from FFastArraySerializerItem */</span></span><br><span class="line">USTRUCT()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FExampleItemEntry</span> :</span> <span class="keyword">public</span> FFastArraySerializerItem</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your data:</span></span><br><span class="line">	UPROPERTY()</span><br><span class="line">	int32		ExampleIntProperty;</span><br><span class="line"></span><br><span class="line">	UPROPERTY()</span><br><span class="line">	<span class="keyword">float</span>		ExampleFloatProperty;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Optional functions you can implement for client side notification of changes to items;</span></span><br><span class="line"><span class="comment">	 * Parameter type can match the type passed as the 2nd template parameter in associated call to FastArrayDeltaSerialize</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> It is not safe to modify the contents of the array serializer within these functions, nor to rely on the contents of the array</span></span><br><span class="line"><span class="comment">	 * being entirely up-to-date as these functions are called on items individually as they are updated, and so may be called in the middle of a mass update.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreReplicatedRemove</span><span class="params">(<span class="keyword">const</span> struct FExampleArray&amp; InArraySerializer)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostReplicatedAdd</span><span class="params">(<span class="keyword">const</span> struct FExampleArray&amp; InArraySerializer)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostReplicatedChange</span><span class="params">(<span class="keyword">const</span> struct FExampleArray&amp; InArraySerializer)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Step 2: You MUST wrap your TArray in another struct that inherits from FFastArraySerializer */</span></span><br><span class="line">USTRUCT()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FExampleArray</span>:</span> <span class="keyword">public</span> FFastArraySerializer</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line">	UPROPERTY()</span><br><span class="line">	TArray&lt;FExampleItemEntry&gt;	Items;	<span class="comment">/** Step 3: You MUST have a TArray named Items of the struct you made in step 1. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Step 4: Copy this, replace example with your names */</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">NetDeltaSerialize</span><span class="params">(FNetDeltaSerializeInfo &amp; DeltaParms)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	   <span class="keyword">return</span> FFastArraySerializer::FastArrayDeltaSerialize&lt;FExampleItemEntry, FExampleArray&gt;( Items, DeltaParms, *<span class="keyword">this</span> );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Step 5: Copy and paste this struct trait, replacing FExampleArray with your Step 2 struct. */</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TStructOpsTypeTraits</span>&lt; FExampleArray &gt; :</span> <span class="keyword">public</span> TStructOpsTypeTraitsBase</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">enum</span></span><br><span class="line">       &#123;</span><br><span class="line">			WithNetDeltaSerializer = <span class="literal">true</span>,</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Step 6 and beyond:</span></span><br><span class="line"><span class="comment"> *		-Declare a UPROPERTY of your FExampleArray (step 2) type.</span></span><br><span class="line"><span class="comment"> *		-You MUST call MarkItemDirty on the FExampleArray when you change an item in the array. You pass in a reference to the item you dirtied.</span></span><br><span class="line"><span class="comment"> *			See FFastArraySerializer::MarkItemDirty.</span></span><br><span class="line"><span class="comment"> *		-You MUST call MarkArrayDirty on the FExampleArray if you remove something from the array.</span></span><br><span class="line"><span class="comment"> *		-In your classes GetLifetimeReplicatedProps, use DOREPLIFETIME(YourClass, YourArrayStructPropertyName);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		You can override the following virtual functions in your structure (step 1) to get notifies before add/deletes/removes:</span></span><br><span class="line"><span class="comment"> *			-void PreReplicatedRemove(const FFastArraySerializer&amp; Serializer)</span></span><br><span class="line"><span class="comment"> *			-void PostReplicatedAdd(const FFastArraySerializer&amp; Serializer)</span></span><br><span class="line"><span class="comment"> *			-void PostReplicatedChange(const FFastArraySerializer&amp; Serializer)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Thats it!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>关于上面的第六步及以后，作者给了示例：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adding a FExampleArray property to an Actor</span></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActor</span> :</span> <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">	GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	UPROPERTY(Replicated)</span><br><span class="line">	FExampleArray DeltaTest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding DOREPLIFETIME to the GetLifetimeReplicatedProps method</span></span><br><span class="line"><span class="keyword">void</span> MyActor::GetLifetimeReplicatedProps(TArray&lt; FLifetimeProperty &gt; &amp; OutLifetimeProps) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">	DOREPLIFETIME(MyActor, DeltaTest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Adding an element to the array</span></span><br><span class="line"><span class="keyword">void</span> MyActor::AddItem() &#123;</span><br><span class="line">	FExampleItemEntry a;</span><br><span class="line">	a.ExampleFloatProperty = <span class="number">3.14</span>;</span><br><span class="line">	a.ExampleIntProperty = <span class="number">1234</span>;		</span><br><span class="line">	DeltaTest.MarkItemDirty(DeltaTest.Items.Add_GetRef(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modifying an element</span></span><br><span class="line"><span class="keyword">void</span> MyActor::ChangeItem(int32 ItemID) &#123;</span><br><span class="line">	<span class="keyword">if</span> (DeltaTest.Items.Num() &gt; ItemID) &#123;</span><br><span class="line">		DeltaTest.Items[ItemID].ExampleFloatProperty = <span class="number">6.28</span>;</span><br><span class="line">		DeltaTest.Items[ItemID].ExampleIntProperty = <span class="number">5678</span>;</span><br><span class="line">		DeltaTest.MarkItemDirty(DeltaTest.Items[ItemID]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removing an element</span></span><br><span class="line"><span class="keyword">void</span> MyActor::RemoveLastItem() &#123;</span><br><span class="line">	<span class="keyword">if</span> (DeltaTest.Items.Num() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		DeltaTest.Items.RemoveAt(DeltaTest.Items.Num()<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">		DeltaTest.MarkArrayDirty();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作者将一个Item标志为Dirty位，当新添加一个Item或者修改了一个Item的时候。<br>作者将整个Array标志为Dirty位，当移除了某个Item的时候。</p>
<p>这里我也不清楚这篇文章的作者是有意为之还是说移除某个对象的时候，其整体Array都需要标志为Dirty位是必须操作。不过我感觉这个是必须操作。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的Meta修饰符</title>
    <url>/ue4-meta-data-specifiers/</url>
    <content><![CDATA[<p>UE4中的<strong>MetadataSpecifiers</strong>是个很邪门的东西，一开始的时候根本不知道是什么东西怎么用，等到对UE4C++有了较为深入的了解还有引擎的源码读多了之后，才知道这个东西虽然不用也行但是用了有的时候会更方便一些。与之同样重要或者说更为重要的是<strong>PropertySpecifers</strong>这个概念。</p>
<a id="more"></a>
<h1 id="MetadataSpecifiers"><a href="#MetadataSpecifiers" class="headerlink" title="MetadataSpecifiers"></a>MetadataSpecifiers</h1><blockquote>
<p>When declaring classes, interfaces, structs, enums, enum values, functions, or properties, you can add Metadata Specifiers to control how they interact with various aspects of the engine and editor. Each type of data structure or member has its own list of Metadata Specifiers.</p>
</blockquote>
<p>上面是官方文档<a href="https://docs.unrealengine.com/en-US/ProgrammingAndScripting/GameplayArchitecture/Metadata/index.html" target="_blank" rel="noopener">Metadata Specifiers</a>的描述，当我声明UE4的数据结构的时候，基本上都可以添加Meta修饰符来实现一些动作，每种数据结构和成员都有它自己的一个Metadata修饰符的列表，而我的目的就是把自己遇到过的Meta修饰符整理，记录下使用方法。</p>
<p>需要注意的是，Metadata修饰符之存在于Editor部分，不要把Metadata修饰符的使用范围扩大到游戏中的逻辑，比如说游戏运行是变量数据的读取。仅仅是方便我们在UE4的Editor中开发的存在。</p>
<h2 id="遇到的一些使用"><a href="#遇到的一些使用" class="headerlink" title="遇到的一些使用"></a>遇到的一些使用</h2><h3 id="Meta-EditCondition-“变量名”"><a href="#Meta-EditCondition-“变量名”" class="headerlink" title="Meta = (EditCondition = “变量名”)"></a>Meta = (EditCondition = “变量名”)</h3><p>这里的变量名大多是布尔类型。用途是控制Detail面板上的变量能否修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWirte)</span><br><span class="line">uint8 bCondition : 1;</span><br><span class="line"></span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWirte, meta = (EditCondition = &quot;bCondition&quot;))</span><br><span class="line">float SettingsValue;</span><br></pre></td></tr></table></figure>
<p>这样Detail面板上的<code>SettingsValue</code>的值就会根据<code>bCondition</code>的值而允许修改或者不允许修改。</p>
<p><code>meta = (EditCondition = &quot;!bCondition&quot;)</code>这样的写法也是可以的。</p>
<ul>
<li>参考文章：<a href="https://qiita.com/Dv7Pavilion/items/6f86134587b3ad6ff396" target="_blank" rel="noopener">【UE4】詳細パネルでの編集可・不可を制御する</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-DataTable的使用</title>
    <url>/UE4-DataTable%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>C++中的函数指针理解</title>
    <url>/c++-function-pointer/</url>
    <content><![CDATA[<p>学会如何辨别和使用函数指针，还有与模板之间的应用。<br><a id="more"></a></p>
<p>当遇见需要大面积使用某种操作，大体上需要的操作都是一样的，但是总有一些数据类型或者条件有些细微的不同，让我不能简单实现批次处理，但是一个一个进行复制粘贴调整费时还费力，而且犯错的几率非常高，这个时候求助大佬的时候，简单的使用了C++的template，函数指针之类的操作完成了这个需求，看得我心痒的不行。</p>
<p>关于模板的内容我记得还在博客的别的文章中总结学习过，然而事实证明不是真正的使用就根本学不会。</p>
<p>这次准备实战进行学习。</p>
<p>首先是基础。</p>
<h1 id="C-中使用std-function"><a href="#C-中使用std-function" class="headerlink" title="C++中使用std::function"></a>C++中使用std::function</h1><p>这个地方多亏了一篇文章的总结，十分感谢：</p>
<ul>
<li><a href="https://qiita.com/ymd_/items/27009e3e6d7a73653fab" target="_blank" rel="noopener">std::functionの使い方 in C++</a></li>
</ul>
<p>首先是<code>std::function</code>的功能是可以包裹(Wrap)多数种类的C++函数类型方便进行统一的处理。这里多数种类的函数包括</p>
<ul>
<li>函数</li>
<li>Lambda表达式</li>
<li>函数Object</li>
<li>类的成员函数</li>
</ul>
<p>这里就引出了我之前没怎么意识到的问题，那就是，<strong>什么是函数？</strong></p>
<p>如果说上面的函数种类都被称为函数的话，那么<strong>什么是函数指针？</strong></p>
<p>这是我在使用的过程中一直没有搞清楚的地方。希望在整理这篇文章的过程中会对这个概念有个完全的理解。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>关于Lambda表达式有很多内容，之后慢慢更新，这里先参照我看的资料记住Lambda表达式的基础用法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[キャプチャー](引数)-&gt;返り値の型&#123;関数の内容&#125;(実行時の引数);</span><br></pre></td></tr></table></figure></p>
<p>翻译过来就是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[Capture](参数)-&gt; 返回值类型 &#123;函数体的内容&#125; (运行时参数)</span><br></pre></td></tr></table></figure></p>
<p>这里Capture中的内容可以是<code>&amp;</code>和<code>=</code>，还有什么都不写。<code>&amp;</code>就是通常的引用的意思，<code>=</code>就是复制来自Scope外的参数。<strong>至于什么都不写的情况下，是哪种方式我暂时不太清楚</strong>。</p>
<p>甚至可以这样写：<code>[]{}()</code>省略参数和返回值。</p>
<p>再就是最后的<code>(运行时参数)</code> 是个什么使用方法我还暂时不清楚，没遇到过。<br>难不成只是函数的<code>()</code>操作符，就像是<code>Get(运行时参数)</code>，这里就是<code>Lambda表达式(运行时参数)</code>这种感觉。</p>
<h2 id="std-function使用方法"><a href="#std-function使用方法" class="headerlink" title="std::function使用方法"></a>std::function使用方法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt; 戻り値の方(引数の型) &gt; object = 関数<span class="keyword">or</span> ラムダ式 <span class="keyword">or</span> 関数オブイェクト <span class="keyword">or</span>クラスのメンバ関数;</span><br><span class="line">object(引数);で利用できる</span><br></pre></td></tr></table></figure>
<p>翻译过来就是：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt; 返回值类型 (参数类型) &gt; object = 函数 <span class="keyword">or</span> Lambda表达式 <span class="keyword">or</span> 函数Object <span class="keyword">or</span> 类成员函数;</span><br><span class="line"></span><br><span class="line">object(参数); <span class="comment">// 函数调用</span></span><br></pre></td></tr></table></figure></p>
<h3 id="普通的函数"><a href="#普通的函数" class="headerlink" title="普通的函数"></a>普通的函数</h3><p>使用<code>std::function</code>来操作最简单最常见的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mai</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt; <span class="keyword">void</span>(<span class="keyword">int</span>) &gt; f_func = print_number;</span><br><span class="line">    f_func(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是最简单也是最好理解的用法。</p>
<h3 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>举个使用<code>std::function</code>操作lambda表达式的例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt; <span class="keyword">void</span> (<span class="keyword">int</span>) &gt; f_lambda = [=](<span class="keyword">int</span> i)&#123; print_number(i);&#125;;</span><br><span class="line"></span><br><span class="line">    f_lambda(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>这个这个使用方式是我几乎没有见到和使用的，记着没有坏处，应该是把函数的地址和参数地址绑定到一起？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_number</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function &lt; <span class="keyword">void</span>() &gt; f_bind = <span class="built_in">std</span>::bind(print_number, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    f_bind();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数绑定感觉有意思。</p>
<h3 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h3><p>一种可以表示类的成员函数的方法<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> <span class="keyword">int</span> n) : i_(n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print_add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i_ + n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> i_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt; <span class="keyword">void</span>(<span class="keyword">const</span> Foo&amp;, <span class="keyword">int</span>) &gt; f_member = &amp;Foo::print_add;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    f_member(foo, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数Object"><a href="#函数Object" class="headerlink" title="函数Object"></a>函数Object</h3><p>这个方法是我第一见到，这个概念说实话我也是第一次遇到，先上用法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrintFunctor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt; <span class="keyword">void</span>(<span class="keyword">int</span>) &gt; f_func_obj = PrintFunctor();</span><br><span class="line"></span><br><span class="line">    f_func_obj(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个的使用是我再请教大佬的是时候遇到的，再学会使用之前，需要搞懂<strong>函数Object</strong>这个概念。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim学习笔记</title>
    <url>/learning-vim/</url>
    <content><![CDATA[<p>记录一些Vim的常用的使用方法。</p>
<a id="more"></a>
<p>我使用Vim也很久了，但是要问我学的怎么样，我也只能说啥都不会，也就会一点特别基础的移动光标而已。所以这篇文章用来记录一些我使用Vim的命令。</p>
<h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><p>经常会需要使用其他的单词替换全文的某个单词，找了一下Vim的使用，有很多，但我看不懂，我就记下我看懂了的而且感觉上还好用的那种。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s/foo/bar/gc</span><br></pre></td></tr></table></figure>
<p>使用上面的命令进行逐个替换，<code>c</code>应该是确认的意思，<code>y/n</code>键进行确认替换和取消替换。</p>
<h3 id="使用寄存器中的内容进行替换"><a href="#使用寄存器中的内容进行替换" class="headerlink" title="使用寄存器中的内容进行替换"></a>使用寄存器中的内容进行替换</h3><p>有的时候想要重复的复制Vim剪切板的内容，但是由于替换之后Vim剪切板的内容就会被替换成刚刚删掉的内容，因此把想要使用替换的内容放到寄存器里会是一个方案。</p>
<p>首先我对寄存器并不是很了解，只记录下使用方式暂时。</p>
<p>比如说想把保存的内容放到<code>k</code>寄存器中：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"kyy</span></span><br></pre></td></tr></table></figure></p>
<p><code>yy</code>是复制当前行，也就是把当前行的内容复制到了<code>k</code>寄存器里了。</p>
<p>然后移动到想要复制的位置：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"kp</span></span><br></pre></td></tr></table></figure></p>
<p>将寄存器中的内容粘贴。</p>
<p>如果是想粘贴Windows剪切板中的内容（就是Ctrl+C），那么使用下面的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"*p</span></span><br></pre></td></tr></table></figure></p>
<p>参考资料：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/1497958/how-do-i-use-vim-registers" target="_blank" rel="noopener">How do I use vim registers?</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-各种容器的介绍</title>
    <url>/ue4-container/</url>
    <content><![CDATA[<p>UE4中提供了许多自定义的容器，比如说<code>TArray</code>，<code>TMap</code>等等，这篇文章主要想记录这些容器的使用。</p>
<a id="more"></a>
<h2 id="TMap的使用"><a href="#TMap的使用" class="headerlink" title="TMap的使用"></a>TMap的使用</h2><p>关于使用其实搜一下就好了，使用方法也很简单。</p>
<p>只是我遇到了一个问题就是TMap需要Key和Value，这个时候Key的类型需要是常用的类型，如果是自定义的类型则会出现编译错误，而我们需要把自定义的类型的Hash类型定义好。具体我也不是特别清楚……</p>
<p>下面是从ActionRPG项目里复制过来的代码，如何使用参照代码就OK了。<br>**<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Struct representing a slot for an item, shown in the UI */</span></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ACTIONRPG_API</span> <span class="title">FRPGItemSlot</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Constructor, -1 means an invalid slot */</span></span><br><span class="line">    FRPGItemSlot()</span><br><span class="line">        : SlotNumber(<span class="number">-1</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    FRPGItemSlot(<span class="keyword">const</span> FPrimaryAssetType&amp; InItemType, int32 InSlotNumber)</span><br><span class="line">        : ItemType(InItemType)</span><br><span class="line">        , SlotNumber(InSlotNumber)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** The type of items that can go in this slot */</span></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)</span><br><span class="line">    FPrimaryAssetType ItemType;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** The number of this slot, 0 indexed */</span></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Item)</span><br><span class="line">    int32 SlotNumber;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Equality operators */</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> FRPGItemSlot&amp; Other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ItemType == Other.ItemType &amp;&amp; SlotNumber == Other.SlotNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> FRPGItemSlot&amp; Other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == Other);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Implemented so it can be used in Maps/Sets */</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">inline</span> uint32 <span class="title">GetTypeHash</span><span class="params">(<span class="keyword">const</span> FRPGItemSlot&amp; Key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        uint32 Hash = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        Hash = HashCombine(Hash, GetTypeHash(Key.ItemType));</span><br><span class="line">        Hash = HashCombine(Hash, (uint32)Key.SlotNumber);</span><br><span class="line">        <span class="keyword">return</span> Hash;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Returns true if slot is valid */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ItemType.IsValid() &amp;&amp; SlotNumber &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>FGameplayAbilitySpecHandle：</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Handle that points to a specific granted ability. These are globally unique */</span></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FGameplayAbilitySpecHandle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    GENERATED_USTRUCT_BODY()</span><br><span class="line"> </span><br><span class="line">    FGameplayAbilitySpecHandle()</span><br><span class="line">        : Handle(INDEX_NONE)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** True if GenerateNewHandle was called on this handle */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Handle != INDEX_NONE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** Sets this to a valid handle */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenerateNewHandle</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; Other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Handle == Other.Handle;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; Other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Handle != Other.Handle;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> uint32 <span class="title">GetTypeHash</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; SpecHandle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ::GetTypeHash(SpecHandle.Handle);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">FString <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IsValid() ? FString::FromInt(Handle) : TEXT(<span class="string">"Invalid"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> </span><br><span class="line">    UPROPERTY()</span><br><span class="line">    int32 Handle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="关于TMap中的值传问题"><a href="#关于TMap中的值传问题" class="headerlink" title="关于TMap中的值传问题"></a>关于TMap中的值传问题</h3><p>经过验证，至少在Struct的使用上，TMap的使用是值传递，而不是引用传递。比方说：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">USTRUCT()</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FTest</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FTest test1 = FTest();</span><br><span class="line"></span><br><span class="line">TMap&lt;int32, FTest&gt; TestMap;</span><br><span class="line">TestMap.Add(<span class="number">1</span>, test1);</span><br><span class="line"></span><br><span class="line">test1.a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">print(test1.a);</span><br><span class="line">print(TestMap.Find(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></p>
<p>上面的代码是我随意瞎写的，就是体现个意思，通过输出结果可以发现，<code>Add</code>函数被调用之后使用了值传递，而不是引用传递。至少结构体是这样的。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-正确使用LOG</title>
    <url>/how-to-use-log/</url>
    <content><![CDATA[<p>关于UE4中的LOG的使用我一直都是经常使用，但是也只是只用了最常见的<code>UE_LOG</code>，这篇文章注意主要想集中记录UE4中的LOG的使用和日志文件的问题。</p>
<a id="more"></a>
<h1 id="UE4中的LOG"><a href="#UE4中的LOG" class="headerlink" title="UE4中的LOG"></a>UE4中的LOG</h1><p>在想要在游戏中使用LOG的时候，首先需要知道的是UE4的LOG可以做到哪一步。</p>
<p>首先需要记录的UE4中的LOG。</p>
<h2 id="自定义LOG的Category"><a href="#自定义LOG的Category" class="headerlink" title="自定义LOG的Category"></a>自定义LOG的Category</h2><p>参考文章：</p>
<ul>
<li><a href="https://blog.jamie.holdings/2020/04/21/unreal-engine-4-custom-log-categories/" target="_blank" rel="noopener">Unreal Engine 4 - Custom Log Categories</a></li>
</ul>
<p>自定义LOG的步骤有三步：声明-定义-使用。就这么简单。</p>
<p>头文件中声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DECLARE_LOG_CATEGORY_EXTERN(LogMyAwesomeGame, Log, All);</span><br></pre></td></tr></table></figure></p>
<p>CPP文件中定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DEFINE_LOG_CATEGORY(LogMyAwesomeGame);</span><br></pre></td></tr></table></figure></p>
<p>使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UE_LOG(LogMyAwesomeGame, Log, TEXT(<span class="string">"Test Log Message"</span>));</span><br></pre></td></tr></table></figure></p>
<p>然后是对声明中出现的参数进行说明。</p>
<p>第一个参数当然我们新定义的LOG类别的名称。</p>
<h3 id="第二个参数：Log"><a href="#第二个参数：Log" class="headerlink" title="第二个参数：Log"></a>第二个参数：Log</h3><p>第二个参数则是为这个种类的LOG定义了输出等级，UE4中包含了以下的几个LOG输出等级：</p>
<ul>
<li>Fatal</li>
<li>Error</li>
<li>Warning</li>
<li>Display</li>
<li>Log</li>
<li>Verbose</li>
<li>VeryVerbose </li>
</ul>
<p>像上面，如果你定义了Log类型，则Log以上包含Log的输出等级的Log都会被输出。</p>
<p>额外的，如果你想提升LOG的输出等级，只是为了Debug，我们可以在不修改代码改为修改设定文件的方式对该类型的默认LOG输出层级进行重写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Core.Log]</span><br><span class="line">LogMyAwesomeGame=VeryVerbose</span><br></pre></td></tr></table></figure></p>
<h3 id="第三个参数：All"><a href="#第三个参数：All" class="headerlink" title="第三个参数：All"></a>第三个参数：All</h3><p>第三个参数则是决定了编译阶段会被编译进去的LOG层级，这意味着在Runtime对Log的输出层级进行修改变为不可能，当然是指修改为未被编译进去的LOG层级。</p>
<p>为什么会需要这个参数？原因就是对于我们不想输出的层级仍然需要进行比是否要输出该层级，索性直接将其从编译中移除更彻底。</p>
<p>按照文章的内容所说一个大量的日志输出，哪怕并不会输出到日志上，但是决定这些是否要输出日志这件事本身就很慢了。</p>
<p><strong>All</strong>相当于<strong>VeryVerbose</strong>的缩写，效果是相同的。</p>
<h2 id="UE4的LOG输出时间"><a href="#UE4的LOG输出时间" class="headerlink" title="UE4的LOG输出时间"></a>UE4的LOG输出时间</h2><p>我一直以为UE4的Log没办法输出时间，实际上只是我没有调查而已…</p>
<p><code>Preferences -&gt; General -&gt;  Apppearance -&gt; Log Timestamp</code>选择类型就可以输出时间了。</p>
<h2 id="UE4的LOG输出日志文件"><a href="#UE4的LOG输出日志文件" class="headerlink" title="UE4的LOG输出日志文件"></a>UE4的LOG输出日志文件</h2><p>由于我没有调查过，UE4的日志输出文件应该也有功能，有时间一定要调查一下，或者说有需求着手之前一定要调查。</p>
<h1 id="使用UE4之外的手段输出LOG"><a href="#使用UE4之外的手段输出LOG" class="headerlink" title="使用UE4之外的手段输出LOG"></a>使用UE4之外的手段输出LOG</h1><p>即我之前傻傻的未调查UE4的LOG系统可以做到什么程度，直接使用<a href="https://github.com/SergiusTheBest/plog" target="_blank" rel="noopener">plog</a>来进行Log日志的保存。但是我觉得效果还是一样的。</p>
<p>至少不用每次都写UE4那个看起来就长的输出用的LOG宏<code>UE_LOG(xxx)</code>。</p>
<p>等我有兴致再整理吧。</p>
<h1 id="使用UE-LOG输出各种数据类型"><a href="#使用UE-LOG输出各种数据类型" class="headerlink" title="使用UE_LOG输出各种数据类型"></a>使用UE_LOG输出各种数据类型</h1><p>在UE4的使用中真的不可避免的使用LOG输出，使用VS的Deebug模式也是很方便而且更准确，但是根据Debug模式的不同，有些地方编译器会进行优化设置断点也未必能取到有效的数据。</p>
<p>这篇算是总结和记录<code>UE_LOG</code>宏的各种数据类型的输出样例，方便我以后查看。</p>
<h2 id="FString"><a href="#FString" class="headerlink" title="FString"></a>FString</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"output message %s"</span>), *(FDateTime::Now().ToString()));</span><br></pre></td></tr></table></figure>
<p>这个我在其它的文章里也有一点记录，算是重复了。</p>
<h2 id="FName"><a href="#FName" class="headerlink" title="FName"></a>FName</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FName MyName;</span><br><span class="line"> UE_LOG(LogTemp, Warning, TEXT(<span class="string">"My Name: %s"</span>), *MyName.ToString());</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-需要时常关注的文章更新和视频更新</title>
    <url>/ue4-follow/</url>
    <content><![CDATA[<p>不断地学习最新的知识，则需要集思广益而且要与时俱进，这篇文章主要是为了记录一些需要时时查看的文章和链接，学习最新的知识。<br><a id="more"></a></p>
<h1 id="与时俱进的文章"><a href="#与时俱进的文章" class="headerlink" title="与时俱进的文章"></a>与时俱进的文章</h1><h2 id="Qitta"><a href="#Qitta" class="headerlink" title="Qitta"></a>Qitta</h2><ul>
<li><a href="https://qiita.com/EGJ-Ken_Kuwano" target="_blank" rel="noopener">Ken Kuwano</a></li>
</ul>
<p>这个大佬的文章会介绍新出的特性，而且是虚幻日本官方的技术支持。还回答过我的问题。</p>
<ul>
<li><a href="https://qiita.com/advent-calendar/2020/ue4" target="_blank" rel="noopener">[Unreal Engine 4 (UE4) Advent Calendar 2020]</a></li>
</ul>
<p>喜欢分享各种UE4技术文章的人的聚集地，时常瞅几眼肯定会学到很多。</p>
<h1 id="与时俱进的视频"><a href="#与时俱进的视频" class="headerlink" title="与时俱进的视频"></a>与时俱进的视频</h1><h2 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h2><ul>
<li><a href="https://www.youtube.com/c/UnrealEngineJP/videos" target="_blank" rel="noopener">Unreal Engine JP</a></li>
</ul>
<p>油管的虚幻日本频道有一些喜欢积极分享技术的人时常聚在一起分享见解，氛围非常的令人羡慕，也会时常更新最新的特性，超级有用。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE44</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-RayTracing学习</title>
    <url>/ue4-learning-raytracing/</url>
    <content><![CDATA[<p>很久之前就听说过这个酷炫的功能了，但是一直都没有提笔记录和学习，可以建模？！那更应该赶紧学了。</p>
<a id="more"></a>
<p>先放文章</p>
<ul>
<li><a href="https://3dnchu.com/archives/ue4-ray-tracing-night-week/" target="_blank" rel="noopener">UE4 Ray Tracing Night Week - 今週は2020年8月17日から連日Unreal Engineのレイトレーシング系動画が公開されるよ！</a></li>
</ul>
<p>拖到官方博客链接失效，我也是真够了。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-UMG相关知识点</title>
    <url>/ue4-learning-umg/</url>
    <content><![CDATA[<p>本篇文章用来记录使用UE4的UMG功能时遇到的问题和知识点。逐步了解UMG，UE4中的UI制作。</p>
<a id="more"></a>
<h1 id="UMG"><a href="#UMG" class="headerlink" title="UMG"></a>UMG</h1><p>首先是对UMG这个概念的解读，<strong>Unreal Motion Graphics UI设计</strong> 是UE4提供的可以方便展示UI的设计框架，这个框架本质上还是使用<strong>Slate</strong>搭建的。</p>
<p>提到UMG也还会经常听到HUD这个词，在UE4中的HUD主要是指</p>
<ul>
<li>UE3那里继承来的Head-Up Display功能，在UE4中主要是用来Debug</li>
<li>向画布上添加图形图元的功能，表示文字的功能，还有简单的HitBox处理，用来检测鼠标等</li>
</ul>
<p>但是由于这些功能UMG都可以干，所以UE4的HUD功能也不是需要一定要掌握了，HUD自身也有许多比如说执行才能被渲染不执行无法确认，文字表现不尽人意，旧版本的功能稳定性之类的问题。</p>
<p>点线图形之类图元的图形渲染UMG的<code>OnPaint</code>函数也可以实现。</p>
<p>而非常重要的<strong>Slate</strong>的话题，Slate是不依靠某个平台的UI框架，UE4的Editor和游戏中的UI都是使用Slate构建的。也就是说想要对UE4的Editor进行比较深度的扩展就一定要动Slate才行。但是网上关于Slate的文章有但是不是很多，需要仔细的挖掘和学习总结了。更多Slate的内容我想在ActionRPG那篇文章中记录。</p>
<p>回到UMG的话题，UMG是什么呢，又是为了什么而存在的呢？</p>
<p>UMG说白了就是对Slate进行了扩展方便在游戏中使用的框架</p>
<ul>
<li>首先是继承了UObject使得Blueprint也可以方便使用</li>
<li>方便在UE4的Editor上确实渲染结果</li>
<li>简单的制作UI动画</li>
</ul>
<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>使用UMG的话，应该第一个需要接触的就是Widget这个概念了，而实际上使用UMG的时候，基本上都要跟Widget打交道了。</p>
<p>Widget是UE4提供的部件，可以方便的使用蓝图进行操作，嵌套之类的都支持。</p>
<p>UE4提提供了许多有用的Widget部件，大概像这样<br><img src="WidgetsList.png" alt="Widgets"></p>
<p>关于不同类型的Widget，我觉得很重要，有一些不知道的话不知道使用就得不偿失了，有时间一定要整理学习。</p>
<p>参考资料</p>
<ul>
<li><a href="https://www.slideshare.net/EpicGamesJapan/umg-80334310" target="_blank" rel="noopener">猫でも分かるUMG</a></li>
</ul>
<h3 id="给Widget添加动画"><a href="#给Widget添加动画" class="headerlink" title="给Widget添加动画"></a>给Widget添加动画</h3><p>在Widget的蓝图中可以很方便的制作Widget的animation片段动画，当我们使用了上面的绑定方式之后，就可以使用人家准备好的<code>UUserWidget::PlayAnimation</code>函数进行动画的再生了，C++的方式还是BP的方式都很容易找到。</p>
<p>很好的参考文章</p>
<ul>
<li><a href="http://monsho.blog63.fc2.com/blog-entry-158.html" target="_blank" rel="noopener">[UE4] UMGのアニメーションと動的な配置</a></li>
</ul>
<h4 id="UUMGSequencePlayer"><a href="#UUMGSequencePlayer" class="headerlink" title="UUMGSequencePlayer"></a>UUMGSequencePlayer</h4><p>在对Widget动画的PlayAnimation函数的使用过程中发现这个类<code>UUMGSequencePlayer</code>貌似是一个很重要的概念，有时间需要好好了解一下。</p>
<h2 id="UMG使用的Tips"><a href="#UMG使用的Tips" class="headerlink" title="UMG使用的Tips"></a>UMG使用的Tips</h2><h3 id="BindWidget"><a href="#BindWidget" class="headerlink" title="BindWidget"></a>BindWidget</h3><p>先来一个邪门的，快速的建立C++和UMG Blueprint中Widget控件的联系</p>
<ul>
<li><a href="https://benui.ca/unreal/ui-bindwidget/" target="_blank" rel="noopener">Connect C++ to UMG Blueprints with BindWidget</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPROPERTY(BlueprintReadWirte, meta = (BindWidget))</span><br><span class="line">class UTextBlock* ItemText;</span><br></pre></td></tr></table></figure>
<p>Meta信息设置为BindWidget之后，在继承这个C++类的蓝图中声明一个同名同类型的控件，编译之后就建立了联系。</p>
<p>关于上面的邪门的知识，在使用过程中我遇见的坑，就是按照那个规则创建了控件之后蓝图编译总是报错，说是没有这个类型的控件，这个时候解决方案是，C++的那边修改一下变量名然后再编译。</p>
<p>###<br>不光是Widget中的Widget控件，Widget中的Animation也一样是可以使用类似上面的方式绑定的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPROPERTY(BlueprintReadWirte, meta = (BindWidgetAnim))</span><br><span class="line">class UWidgetAnimation* WidgetAnimationA;</span><br></pre></td></tr></table></figure></p>
<p>WidgetAnimation可以简单的在Widget中实现动画效果。</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/427948/get-widget-animation-in-c.html" target="_blank" rel="noopener">Get Widget Animation in C++</a></li>
</ul>
<h2 id="UMG中的一些控件介绍"><a href="#UMG中的一些控件介绍" class="headerlink" title="UMG中的一些控件介绍"></a>UMG中的一些控件介绍</h2><h3 id="UMG的RichTextBlock"><a href="#UMG的RichTextBlock" class="headerlink" title="UMG的RichTextBlock"></a>UMG的RichTextBlock</h3><p>UE4除了提供了提供了简单的文本显示的控件之外还提供了可以方便自定义格式的RichTextBlock。记录一下使用的方法。</p>
<p>RichTextBlock使用了UE4的<strong>DataTable</strong>来对其进行自定义和添加样式。使用<strong>DataTable</strong>，我们可以创建想要的Style和自定义的<strong>Decorator类</strong>。UE4内置了一个样例Decorator类：<code>RichTextBlockImageDecorator</code>类，可以参考。</p>
<p>想要使用自定义的文本格式之前先创建一个<strong>DataTableAsset</strong>方便我们使用。在创建DataTable的时候有两种行的结构供我们选择：</p>
<ul>
<li>Rich Image Row</li>
<li>Rich Text Style Row</li>
</ul>
<p>由名字就可以注意到一个是用来显示图片的一个是用来显示文本的。首先是使用文本的栗子：</p>
<p><img src="RichTextDataTableSample.png" alt="sample"></p>
<p>可以观察到添加了一个默认行，（当然<code>Default</code>的名字是要自己修改的），作为使用的默认样式。貌似第一行的行名默认就是Default，遵循这个规则。</p>
<p>然后是要把这个格式应用到Widget的<strong>RichTextBlock</strong>上去。找到自己创建的<strong>RichTextBlock</strong>  控件，然后找到<strong>Appearence</strong>设置好我们创建的TextStyle：<br><img src="RichTextDataTableSample01.png" alt="sample01"></p>
<p>这里需要注意的是检查一次字体的格式有没有好好设置，要不然会显示不了文字。</p>
<p>做完上面，我们就简单的获得了一个自定义的雏形。</p>
<p>但是我们想要在一个TextBlock中有多个文字样式，那么就需要在上面我们制作的DataTable中添加新的样式数据并应用它。添加一个新的格式;<br><img src="RichTextDataTableSample02.png" alt="sample02"></p>
<p>然后应用它：<br><img src="RichTextDataTableSample03.png" alt="sample03"></p>
<p>就是<code>&lt;RowName&gt;Text&lt;/&gt;</code>的格式，把想要应用的文本包围起来就可以实现了。</p>
<p>关于更多的RichText的使用，还有上面提到的Decorator类的内容，需要找时间整理学习。</p>
<p>最近关于UE4的本地化策略(Localization)调查了很多，其中也涉及到了很多关于这个<strong>RichTextBlock</strong>的内容。</p>
<p>对上面的内容进行一点点的总结，首先是上面的<strong>Appearence</strong>需要我们指定的<strong>TextStyleSet</strong>，在这里我们可以指定文本的格式，字体什么的设定内容，到这里为止我们只要创建一个DataTable，Row结构体是<code>RichTextStyleRow</code>的表填入相应的字体信息，增加各种行的信息，就可以在RichTextBlock中实现各种字体的效果。</p>
<p>但是如果想在这个基础上添加图片等其他的数据则需要我们对<strong>Decorator</strong>进行深入的使用。</p>
<p>首先是最简单的使用UE4原本提供的图片格式进行简单的应用，即对上面的<code>RichImageRow</code>表的内容进行简单的利用。为此我们需要为这个RichTextBlack添加DecoratorClass。<br><img src="DecoratorClassSample.png" alt="DecoratorClass"></p>
<p>UE4为我们提供了式样案例<code>RichTextBlockImageDecorator</code>这个类，之后将会对这个类的源码实现进行学习。其实实现的方法很简单，就是新建一个BP继承<code>RichTextBlockImageDecorator</code>，然后把这个新建的类指定到上面RichTextBlock的DecoratorClass中。</p>
<p>然后打开这个BP，会发现有一个<code>Appearence-&gt;ImageSet</code>的项目，这里指定我们上面创建的RichTextStyleRow的DataTable。在RichText中使用<code>&lt;img id=&quot;Row_Name&quot;/&gt;</code>这样的标签就可以指定表中的对应的行的图片进行显示了。</p>
<p>到这里的参考资料</p>
<ul>
<li><a href="https://www.unrealengine.com/ja/tech-blog/advanced-text-styling-with-rich-text-block" target="_blank" rel="noopener">Rich Text Block を使ったテキストの高度なスタイル設定</a></li>
<li><a href="https://docs.unrealengine.com/en-US/InteractiveExperiences/UMG/UserGuide/UMGRichTextBlock/index.html" target="_blank" rel="noopener">UMG Rich Text Block</a></li>
</ul>
<p>以上是简单的为RichTextBlock添加图片实现，如果要对Decorator进行自定义则需要参考这个<code>RichTextBlockImageDecorator</code>示例源码实现了。</p>
<h4 id="新建我们自己的Decorator"><a href="#新建我们自己的Decorator" class="headerlink" title="新建我们自己的Decorator"></a>新建我们自己的Decorator</h4><p>首先是对UE4提供的<code>RichTextBlockImageDecorator</code>的示例源码进行解析。</p>
<ul>
<li><code>URichTextBlockDecorator</code></li>
<li><code>FRichTextDecorator</code></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-关于Subsystem</title>
    <url>/ue4-subsystem/</url>
    <content><![CDATA[<p>这次要学习的是UE4的Subsystem，由4.22版本实装的功能。简单来说就是被某个系统所管理，会被自动实例化并拥有生命周期的类。</p>
<a id="more"></a>
<h1 id="SububSystem概要"><a href="#SububSystem概要" class="headerlink" title="SububSystem概要"></a>SububSystem概要</h1><h2 id="GameInstanceSubsystem"><a href="#GameInstanceSubsystem" class="headerlink" title="GameInstanceSubsystem"></a>GameInstanceSubsystem</h2><p>多说无用，先介绍我目前最急迫使用的<strong>GameInstance Subsubsystem</strong>：</p>
<p><code>UGameInstance</code>进行管理 <br></p>
<p>参考的文章：</p>
<ul>
<li><a href="https://qiita.com/unknown_ds/items/afcff802ab17db486822" target="_blank" rel="noopener">UE4 プログラミングサブシステムを試してみる</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www2.slideshare.net/EpicGamesJapan/ue4-subsystem" target="_blank" rel="noopener">猫でも分かるUE4.22から入ったSubsystem</a></li>
</ul>
<p>与之配套的讲解视频：  <a href="https://www.youtube.com/watch?v=Wbq3KO3ZJaI" target="_blank" rel="noopener">第4回UE4何でも勉強会 in 東京 アーカイブ動画</a></p>
<p>我很早就应该看到但是却没有的文档：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Framework/GameFlow/index.html" target="_blank" rel="noopener">Game Flow Overview</a></li>
</ul>
<p>这里面的大图片想方法给它抠出来…</p>
<p>在使用这个Subsystem的时候需要对整个UE4的各种类的生命周期做些深入的了解：</p>
<ul>
<li><a href="https://www2.slideshare.net/com044/ue4-in" target="_blank" rel="noopener">UE4プログラマー勉強会 in 大阪 -エンジンの内部挙動について</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-ActionRPG解析</title>
    <url>/ue4-actionrpg/</url>
    <content><![CDATA[<p>今天我们来聊聊UE4提供的一个开源工程-ActionRPG，一句话形容就是，浑身都是宝。</p>
<a id="more"></a>
<p>首先是先对ActionRPG有些了解</p>
<ul>
<li><a href="https://www2.slideshare.net/EpicGamesJapan/ue4action-rpg" target="_blank" rel="noopener">猫でも分かる UE4の新しいサンプル「Action RPG」について</a></li>
</ul>
<p>应该配合视频更好，都是一个系列的有时间找一下看看。</p>
<h1 id="LoadScreenModule实现和相关内容"><a href="#LoadScreenModule实现和相关内容" class="headerlink" title="LoadScreenModule实现和相关内容"></a>LoadScreenModule实现和相关内容</h1><h2 id="Load-Screen-Module"><a href="#Load-Screen-Module" class="headerlink" title="Load Screen Module"></a>Load Screen Module</h2><p>首先是UE4的异步加载界面的实现。</p>
<p>其中感觉很重要但是我目前还没有仔细调查的MoviePlayer，不知道是否可以实现Loading界面播片的问题，需要调查。</p>
<p>很不错的介绍AsyncLoadingScreen的视频，还顺便介绍了一个很重要的概念，TransitionLevel</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ON1_dEHoNDg" target="_blank" rel="noopener">Async Loading Screens and Transition Levels | Unreal Fest Europe 2019 | Unreal Engine</a></li>
</ul>
<h2 id="UE4的Slate"><a href="#UE4的Slate" class="headerlink" title="UE4的Slate"></a>UE4的Slate</h2><p>UE4deSlate是UMG框架下的一部分。UMG我会在其它文章中介绍具体的使用方法。UI的制作肯定是要用UMG来实现的，但是这里用到Slate的理由是，我们想要实现异步加载界面的实现。</p>
<p>首先UE4的Scene的加载只能在Gam线程中完成，也就是主线程，异步加载界面的实现，而Slate刚好是在别的线程中实现的，至于什么线程我还不清楚…</p>
<p>我想利用这个特性，于是开始了解Slate。当然还有<code>MoviePlayer</code>这个东西。</p>
<h3 id="Slate-Hello"><a href="#Slate-Hello" class="headerlink" title="Slate, Hello"></a>Slate, Hello</h3><p>加载界面需要了解UE4的<strong>Slate</strong>，先上教学：</p>
<ul>
<li><a href="https://nerivec.github.io/old-ue4-wiki/pages/slate-hello.html" target="_blank" rel="noopener">Slate, Hello</a></li>
</ul>
<p>目前我对Slate的理解也仅限于制作一个简陋的加载界面，还有一些高级的功能没有涉及到。关于如何自己设置项目中的Slate的API使用我就不详细的记录了，只记录一些关键的步骤。</p>
<p>添加模块依赖(貌似默认生成的Build文件中都有，只不过貌似是被注释掉的，如果我没记错的话)：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PrivateDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Slate"</span>, <span class="string">"SlateCore"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>如何快速输出一个简单的Slate制作的Hello World!`参照代码很快就可以制作出来，为了方便查阅复制到这里吧。代码中的注释解说非常珍贵。</p>
<details><br>    <summary><mark><font color="darked">StandardHUD.h</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/HUD.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StandardHUD.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ A predeclaration of SStandardSlateWidget that we need. The .h will be added to .cpp instead.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SStandardSlateWidget</span>;</span></span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOSLATE_API</span> <span class="title">AStandardHUD</span> :</span> <span class="keyword">public</span> AHUD</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ++ Reference to an SCompoundWidget, TSharedPtr adds to the refcount of MyUIWidget</span></span><br><span class="line">    <span class="comment">// MyUIWidget will not self-destruct as long as refcount &gt; 0. refcount will be (refcout-1) if HUD is destroyed.</span></span><br><span class="line">    TSharedPtr&lt;SStandardSlateWidget&gt; MyUIWidget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++ Called as soon as game starts, create SCompoundWidget and give Viewport access</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<details><br>    <summary><mark><font color="darked">StandardHUD.cpp</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StandardHUD.h"</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SStandardSlateWidget.h"</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++ The SWeakWidget we are using</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Widgets/SWeakWidget.h"</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++ To use GEngine. You can also import just "Engine.h" but some people mention this compiles slower than this header.</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Runtime/Engine/Classes/Engine/Engine.h"</span> </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> AStandardHUD::BeginPlay()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// So far only TSharedPtr&lt;SMyUIWidget&gt; has been created, now create the actual object.</span></span><br><span class="line">        <span class="comment">// Create a SMyUIWidget on heap, our MyUIWidget shared pointer provides handle to object</span></span><br><span class="line">        <span class="comment">// Widget will not self-destruct unless the HUD's SharedPtr (and all other SharedPtrs) are destroyed first.</span></span><br><span class="line">        MyUIWidget = SNew(SStandardSlateWidget).OwnerHUDArg(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pass our viewport a weak ptr to our widget</span></span><br><span class="line">        <span class="comment">// Viewport's weak ptr will not give Viewport ownership of Widget</span></span><br><span class="line">        GEngine-&gt;GameViewport-&gt;AddViewportWidgetContent( </span><br><span class="line">            SNew(SWeakWidget)</span><br><span class="line">            .PossiblyNullContent(MyUIWidget.ToSharedRef())</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set widget's properties as visible (sets child widget's properties recursively)</span></span><br><span class="line">        MyUIWidget-&gt;SetVisibility(EVisibility::Visible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p>总结来说就是我们在HUD中保持了一个智能指针：<code>TSharedPtr&lt;SStandardSlateWidget&gt; MyUIWidget</code>，<code>SStandardSlateWididget</code>是我们接下来想要创建的Slate的类。然后我们在构造函数中真正创建了这个类。</p>
<p>接下来是真正的对Slate类进行实现了：</p>
<p><strong>StandardSlateWidget.h:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Widgets/SCompoundWidget.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HELLOSLATE_API</span> <span class="title">SStandardSlateWidget</span> :</span> <span class="keyword">public</span> SCompoundWidget</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SLATE_BEGIN_ARGS(SStandardSlateWidget)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ++ We add a new argument called OwnerHUDArg</span></span><br><span class="line">    SLATE_ARGUMENT(TWeakObjectPtr&lt;class AStandardHUD&gt;, OwnerHUDArg);</span><br><span class="line"></span><br><span class="line">    SLATE_END_ARGS()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructs this widget with InArgs. Needed for every widget. Builds this widget and any of it's children</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Construct</span><span class="params">(<span class="keyword">const</span> FArguments&amp; InArgs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ++ Pointer to our parent HUD. To make sure HUD's lifetime is controlled elsewhere, use "weak" ptr.</span></span><br><span class="line">    <span class="comment">// ++ HUD has a "strong" pointer to Widget, circular ownership would prevent/break self-destruction of hud/widget (cause a memory leak).</span></span><br><span class="line">    TWeakObjectPtr&lt;<span class="class"><span class="keyword">class</span> <span class="title">AStandardHUD</span>&gt; <span class="title">OwnerHUD</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中出现的宏进行说明：</p>
<p><em>SLATE_BEGIN_ARGS</em>和<em>SLATE_END_ARGS</em>实际上创建了一个包含一些变量(variables)的结构体(struct)，而这些变量则是使用<em>SLATE_ARGUMENT</em>, <em>SLATE_ATTRIBUTE</em>, <em>SLATE_EVENT</em>之类的宏添加的。而添加的变量的名字则是<code>_TheNameYouGaveIt</code></p>
<p><em>SLATE_ARGUMENT</em>宏创建你想要类型的变量，<code>SLATE_ARGUMENT(int, MyThing)</code>则是创建了一个<code>int</code>类型的名为<code>_MyThing</code>的变量。</p>
<p><em>SLATE_ATTRIBUTE</em>宏创建你想要类型的<code>TAttribute</code>，<code>SLATE_ATTRIBUTE(int, MyThing)</code>则是创建了一个<code>TAttribute</code>类型的变量，名为<code>_MyThing</code></p>
<p>所以说<code>TAttribute</code>是什么类型？我暂时不太清楚<a href="https://docs.unrealengine.com/en-US/API/Runtime/Core/Misc/TAttribute/index.html" target="_blank" rel="noopener">TAttribute</a></p>
<p>除此之外这些宏还基于所给的变量名字定义了Set函数。这一点我没有验证过。</p>
<p><strong>StandardSlateWidget.cpp:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SStandardSlateWidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SlateOptMacros.h"</span></span></span><br><span class="line"></span><br><span class="line">BEGIN_SLATE_FUNCTION_BUILD_OPTIMIZATION</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ This is needed in order to use the localization macro LOCTEXT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="meta-string">"SStandardSlateWidget"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SStandardSlateWidget::Construct(<span class="keyword">const</span> FArguments&amp; InArgs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ++ Asign the argument to our local variable</span></span><br><span class="line">        <span class="comment">// name will be _OwnerHUDArg instead of OwnerHUDArg, see comments about SLATE_ARGUMENT before</span></span><br><span class="line">    OwnerHUD = InArgs._OwnerHUDArg;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ++ Add all this Slate code</span></span><br><span class="line">    <span class="comment">// If the code below doesn't look like C++ to you it's because it (sort-of) isn't,</span></span><br><span class="line">    <span class="comment">// Slate makes extensive use of the C++ Prerocessor(macros) and operator overloading,</span></span><br><span class="line">    <span class="comment">// Epic is trying to make our lives easier, look-up the macro/operator definitions to see why.</span></span><br><span class="line"></span><br><span class="line">    ChildSlot</span><br><span class="line">    .VAlign(VAlign_Fill)</span><br><span class="line">    .HAlign(HAlign_Fill)</span><br><span class="line">    [</span><br><span class="line">        SNew(SOverlay)</span><br><span class="line">        + SOverlay::Slot()</span><br><span class="line">        .VAlign(VAlign_Top)</span><br><span class="line">        .HAlign(HAlign_Center)</span><br><span class="line">        [</span><br><span class="line">            <span class="comment">// Inside lies a text block with these settings</span></span><br><span class="line">            SNew(STextBlock)</span><br><span class="line">            .ShadowColorAndOpacity(FLinearColor::Black)</span><br><span class="line">            .ColorAndOpacity(FLinearColor::Red)</span><br><span class="line">            .ShadowOffset(FIntPoint(<span class="number">-1</span>, <span class="number">1</span>)) </span><br><span class="line">            .Font(FSlateFontInfo(<span class="string">"Veranda"</span>, <span class="number">16</span>))</span><br><span class="line">                        <span class="comment">// localized text to be translated with a generic name HelloSlateText</span></span><br><span class="line">            .Text(LOCTEXT(<span class="string">"HelloSlateText"</span>, <span class="string">"Hello, Slate!"</span>)) </span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ We need to undefine this namespace after we finish creating the Slate widget</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br><span class="line"></span><br><span class="line">END_SLATE_FUNCTION_BUILD_OPTIMIZATION</span><br></pre></td></tr></table></figure></p>
<p>如何将外部变量传入Slate内部应该还可以验证，参照上面的各种宏和HUD的参照的传递，应该还有很多可以挖掘的内容，等到想用到的时候再挖吧。</p>
<p>至于文章其他的内容因为很简单就直接省略。</p>
<h3 id="很好的源码参考方式"><a href="#很好的源码参考方式" class="headerlink" title="很好的源码参考方式"></a>很好的源码参考方式</h3><p>有一个偏方，就是使用UE4的<strong>Widget Reflector</strong>工具，直接查看引擎Editor实现的源代码。因为Editor就是用Slate制作的。</p>
<p>Window -&gt; Developer Tools -&gt; Widget Reflector</p>
<p>Window -&gt; Developer Tools -&gt; Debug Tools 中找到 Test Suite</p>
<p>可以发现很多UE4准备好的UI例子，直接抓取源码方便参照。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>官方参考资料，据官网所说这篇适合反复的阅读</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/Slate/Architecture/index.html" target="_blank" rel="noopener">Slate Architecture</a></li>
</ul>
<p>关于Slate的一些实现参考例子，但我还是推荐上面的那种方法。感觉有些枯燥，但是会更加系统的介绍</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/Slate/Widgets/index.html" target="_blank" rel="noopener">Slate Widget Examples</a></li>
</ul>
<p>这里有一篇我无意中发现的文章，使用Slate制作了一点东西，感觉有可能会用的上</p>
<ul>
<li><a href="https://historia.co.jp/archives/13304/" target="_blank" rel="noopener">[UE4] Slateで検索可能なコンボボックスを自作する</a></li>
</ul>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="UE4中的Interface"><a href="#UE4中的Interface" class="headerlink" title="UE4中的Interface"></a>UE4中的Interface</h3><p>关于UE4或者说C++的一些接口的用法进行一些记录。原本是ActionRPG中的Module开始调查，就先从Module的接口开始说起，不过除了调查这个是什么的接口，更重要的是了解接口的使用方式，不仅仅是UE4中的有重要作用的接口。</p>
<p>C++的接口的一些特性使用方法更为重要。</p>
<h4 id="IModuleInterface"><a href="#IModuleInterface" class="headerlink" title="IModuleInterface"></a>IModuleInterface</h4><h4 id="UInterface"><a href="#UInterface" class="headerlink" title="UInterface"></a>UInterface</h4><p>UINTERFACE()</p>
<h5 id="UINTERFACE修饰符"><a href="#UINTERFACE修饰符" class="headerlink" title="UINTERFACE修饰符"></a>UINTERFACE修饰符</h5><h3 id="FGCObject"><a href="#FGCObject" class="headerlink" title="FGCObject"></a>FGCObject</h3><ul>
<li><a href="https://qiita.com/go_astrayer/items/11b99ef8849b43796fee" target="_blank" rel="noopener">UPROPERTY を使わずにオブジェクトをガーベジ コレクションの対象から外す方法</a></li>
</ul>
<h1 id="AssetManager的Asset管理"><a href="#AssetManager的Asset管理" class="headerlink" title="AssetManager的Asset管理"></a>AssetManager的Asset管理</h1><p>除了在上面的ActionRPG的Slide中有提到这个AssetManager之外（需要整理），还有我需要额外参照理解的文章</p>
<ul>
<li><a href="https://qiita.com/EGJ-Kaz_Okada/items/4616c0a21b8e9842a14a" target="_blank" rel="noopener">[UE4] Asset Managerのアセットの非同期ロード機能について その3 (PrimaryDataAsset, PrimaryAssetLabelはいいぞ編) - Qiita</a></li>
<li><a href="https://unrealengine.hatenablog.com/entry/2017/08/24/235153" target="_blank" rel="noopener">UE4 アセットマネージメントフレームワークについて - Let’s Enjoy Unreal Engine</a></li>
</ul>
<h1 id="SaveGame存档管理"><a href="#SaveGame存档管理" class="headerlink" title="SaveGame存档管理"></a>SaveGame存档管理</h1><p>利用UE4提供的<code>SaveGame</code>类实现游戏的存档管理。</p>
<p>首先需要看一下UE4提供的<code>SaveGame</code>类：<br><img src="SaveGame.jpg" alt="SaveGame"></p>
<p>根据上面的类的情报，注释的内容，大概理解了SaveGame的使用方式，和需要使用的函数。</p>
<p>但是我这里着重理解ActionRPG内的实现。还是有一些不同的，<code>SaveGameToSlot</code>和<code>LoadGameFromSlot</code>使用的则是异步版本：<code>AsyncLoadGameFromSlot</code>和<code>AsyncSaveGameToSlot</code>函数。</p>
<p>首先看GameInstance在初始化阶段进行存档的读取的步骤：<br><img src="BPGameInstance1.jpg" alt="BPGameInstance"></p>
<p><code>Init</code>函数是GameInstance的Native函数，提供了一个供BP实现的版本，实际的函数名字是<code>ReceiveInit</code>，不过无关紧要，只要知道在初始化阶段会被自动调用就行了。</p>
<p>图片有些大只截取了前半部分，先除去不相关的节点，<strong>第一步</strong>，先是确认是否开启了Save/Load功能，方便我们随时关闭开启存档功能：<code>SetSavingEnable</code>函数。</p>
<p><strong>SetSavingEnable:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Sets rather save/load is enabled. If disabled it will always count as a new character */</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = Save)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetSavingEnabled</span><span class="params">(<span class="keyword">bool</span> bEnabled)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Rather it will attempt to actually save to disk */</span></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    <span class="keyword">bool</span> bSavingEnabled;</span><br></pre></td></tr></table></figure></p>
<p>其实就是控制<code>bSavingEnable</code>变量，很简单的函数。</p>
<p><strong>第二步</strong>是取得SaveSlot的情报，主要为了获取想要的<code>SlotName</code>和<code>UserIndex</code>，即<code>GetSavingSlotInfo</code>函数。</p>
<p><strong>第三步</strong>，也是我们的核心步骤之一，<code>AsyncLoadGameFromSlot</code>，由于这一步使用了BP，效果就像图片中展示的那样。</p>
<p><img src="BPGameInstance2.jpg" alt="BPGameInstance2"></p>
<p><strong>第四步</strong>，对取得的<code>SaveGame</code>对象进行处理，如果是我们想要的结果，那就采用这个对象，并取出我们想要的数据。如果不是我们想要的结果，那就新建也好，取决于需求。对<code>HandleSaveGameLoaded</code>进行记录：</p>
<p><strong>HandleSaveGameLoaded:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="comment">/** Handle the final setup required after loading a USaveGame object using AsyncLoadGameFromSlot. Returns true if it loaded, false if it created one */</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = Save)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HandleSaveGameLoaded</span><span class="params">(USaveGame* SaveGameObject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">bool</span> URPGGameInstanceBase::HandleSaveGameLoaded(USaveGame* SaveGameObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> bLoaded = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!bSavingEnabled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// If saving is disabled, ignore passed in object</span></span><br><span class="line">        SaveGameObject = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Replace current save, old object will GC out</span></span><br><span class="line">    CurrentSaveGame = Cast&lt;URPGSaveGame&gt;(SaveGameObject);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (CurrentSaveGame)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Make sure it has any newly added default inventory</span></span><br><span class="line">        AddDefaultInventory(CurrentSaveGame, <span class="literal">false</span>);</span><br><span class="line">        bLoaded = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// This creates it on demand</span></span><br><span class="line">        CurrentSaveGame = Cast&lt;URPGSaveGame&gt;(UGameplayStatics::CreateSaveGameObject(URPGSaveGame::StaticClass()));</span><br><span class="line"> </span><br><span class="line">        AddDefaultInventory(CurrentSaveGame, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    OnSaveGameLoaded.Broadcast(CurrentSaveGame);</span><br><span class="line">    OnSaveGameLoadedNative.Broadcast(CurrentSaveGame);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bLoaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于<code>AddDefaultInventory</code>函数放在最后说明。</p>
<p>这一步进行了之后如果成功的取得了我们想要的存储数据，那就ok了，如果没有取到则需要我们写入一个新的数据进去，也就是默认的数据。同时这个写的操作应该是我们这个部分最重要的部分了。即<code>WriteSaveGame</code>函数：</p>
<p><strong>WriteSaveGame:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="comment">/** Writes the current save game object to disk. The save to disk happens in a background thread*/</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = Save)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WriteSaveGame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">bool</span> URPGGameInstanceBase::WriteSaveGame()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bSavingEnabled)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bCurrentlySaving)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Schedule another save to happen after current one finishes. We only queue one save</span></span><br><span class="line">            bPendingSaveRequested = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Indicate that we're currently doing an async save</span></span><br><span class="line">        bCurrentlySaving = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// This goes off in the background</span></span><br><span class="line">        UGameplayStatics::AsyncSaveGameToSlot(GetCurrentSaveGame(), SaveSlot, SaveUserIndex, FAsyncSaveGameToSlotDelegate::CreateUObject(<span class="keyword">this</span>, &amp;URPGGameInstanceBase::HandleAsyncSave));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>HandleAsyncSave:</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="comment">/** Called when the async save happens */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleAsyncSave</span><span class="params">(<span class="keyword">const</span> FString&amp; SlotName, <span class="keyword">const</span> int32 UserIndex, <span class="keyword">bool</span> bSuccess)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> URPGGameInstanceBase::HandleAsyncSave(<span class="keyword">const</span> FString&amp; SlotName, <span class="keyword">const</span> int32 UserIndex, <span class="keyword">bool</span> bSuccess)</span><br><span class="line">&#123;</span><br><span class="line">    ensure(bCurrentlySaving);</span><br><span class="line">    bCurrentlySaving = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (bPendingSaveRequested)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Start another save as we got a request while saving</span></span><br><span class="line">        bPendingSaveRequested = <span class="literal">false</span>;</span><br><span class="line">        WriteSaveGame();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现内容很短，使用的时候参照一下就好了。</p>
<p>还有一些函数没有记录进去，不是特别重要，但是也有作用，比如说上面的<code>bPendingSaveRequested</code>，但是在制作的时候大概都会想到，再添加进去也来得及，主要是直接去看ActionRPG的源码更快，这里我只是稍加记录，方便自己理解回忆。</p>
<p>实现上面的话应该就可以了，为什么是”应该“？因为我还没有验证过，只是趁着为数不多的时间理解并记录了一下，等之后我需要在自己的项目中实现一下。</p>
<h2 id="数据的序列化-Serialize"><a href="#数据的序列化-Serialize" class="headerlink" title="数据的序列化(Serialize)"></a>数据的序列化(Serialize)</h2><p>在初步的尝试使用<code>SaveGame</code>来进行数据的存储之后，稍微复杂一点的数据结构或者说是数据类型就没有办法保存了。比如说指针类型。</p>
<p>Pointer类型的数据没有办法保存。<code>UObject*</code>或者<code>AActor*</code>类型，取出来都是NULL，还好还是有救的。</p>
<p>这里先只贴上链接，等到以后真要使用了在验证整理吧…</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/35618/savingloading-an-array-of-objects.html" target="_blank" rel="noopener">What is the best way to handle Saving/Loading an Array of Objects?</a></li>
</ul>
<p>上面的问题的回答应该算是官方解答了，具体我没有验证过，等我需要验证的时候再到这里找答案吧。</p>
<ul>
<li><a href="https://www.gamedev.net/forums/topic/685514-complex-saving-and-loading-techniques-in-unreal-engine-4/" target="_blank" rel="noopener">Complex Saving and Loading Techniques in Unreal Engine 4</a></li>
<li><a href="http://runedegroot.com/saving-and-loading-actor-data-in-unreal-engine-4/" target="_blank" rel="noopener">Saving and loading actor data in Unreal Engine 4</a></li>
<li><a href="https://www.ue4community.wiki/legacy/savegame-pointers-and-structs-8wlg0qms" target="_blank" rel="noopener">Legacy/SaveGame Pointers and Structs</a></li>
<li><a href="https://historia.co.jp/archives/1457/" target="_blank" rel="noopener">[UE4] 独自のアセットを実装する方法(6)　独自のシリアライズを実装する</a></li>
</ul>
<p>上面的链接都是很好的参考资料。应该。找时间整理一下。</p>
<p>下面这篇文章我没有读过，但是我觉得我应该花时间把这篇文章研读整理一下，说不定就能明白UE4中的序列化的问题。</p>
<ul>
<li><a href="https://michaeljcole.github.io/wiki.unrealengine.com/Save_System,_Read_&amp;_Write_Any_Data_to_Compressed_Binary_Files/" target="_blank" rel="noopener">#Save System, Read &amp; Write Any Data to Compressed Binary Files</a></li>
</ul>
<p>所以最终我没有尝试验证上面的方法可行不可行的原因之一是，上面的方法都指向了自己序列化数据类型然后自己设置二进制文件进行保存，没有用到UE4提供的<code>SaveGame</code>类，更不用说<code>LoadGameFromSlot</code>函数和和它的异步版本(AsyncLoad/Save)了，这样的话我又要改造。</p>
<p>原因之二也是最重要的原因是我用<strong>Struct</strong>来代替指针类型了，非常方便。</p>
<h2 id="拓展-1"><a href="#拓展-1" class="headerlink" title="拓展"></a>拓展</h2><p>在学习这个<code>SaveGame</code>的过程中遇到了几个知识点。</p>
<h3 id="CreateLambda"><a href="#CreateLambda" class="headerlink" title="CreateLambda"></a>CreateLambda</h3><p>使用UE4的Delegate遇到的<code>CreateLambda</code>函数，没想到会在UE4里遇见你啊，有时间要整理。</p>
<ul>
<li><a href="https://qiita.com/sy_/items/541fd18e460f5a881c75" target="_blank" rel="noopener">Unreal Engine 4メモ：デリゲートをprivateで書く</a></li>
</ul>
<p>上面的文章关于Delegate的各种意义上蛮重要的。</p>
<h3 id="NewObject添加构造函数参数"><a href="#NewObject添加构造函数参数" class="headerlink" title="NewObject添加构造函数参数"></a>NewObject添加构造函数参数</h3><p>这是我在寻找为UE4的<code>NewObject</code>新建一个UObject的时候是否能使用带参数的初始化函数进行初始化的时候找到的解决方案，因为使用NewObject的时候顶多添加一个Outer，我所知道的，查不到可以调用带参数的构造函数方法，这个时候我搜到了这个：</p>
<blockquote>
<p>Hey, here’s one way round I use to construct and init my UObjects in one call. In one sentence: make a static function that takes in the desired parameters, creates the UObject, inits it with the params and returns it at the end.</p>
</blockquote>
<ul>
<li><a href="https://answers.unrealengine.com/questions/156055/passing-arguments-to-constructors-in-ue4.html" target="_blank" rel="noopener">Passing arguments to constructors in UE4?</a>这里的回答</li>
</ul>
<p>我觉得这个想法特别重要，于是便那么做了。主要是我不知道在UE4中直接使用<strong>new</strong>关键字生成UObject好不好用。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>ActionRPG</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-ImGui使用</title>
    <url>/ue4-imgui/</url>
    <content><![CDATA[<p>ImGui是一个UE4的插件，方便用来制作Debug的工具界面。</p>
<a id="more"></a>
<h1 id="Unreal-ImGui"><a href="#Unreal-ImGui" class="headerlink" title="Unreal ImGui"></a>Unreal ImGui</h1><ul>
<li><a href="https://github.com/segross/UnrealImGui" target="_blank" rel="noopener">Unreal ImGui</a></li>
</ul>
<h1 id="Dear-ImGui"><a href="#Dear-ImGui" class="headerlink" title="Dear ImGui"></a>Dear ImGui</h1><ul>
<li><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a></li>
</ul>
<h2 id="ImGui各种控件的实现"><a href="#ImGui各种控件的实现" class="headerlink" title="ImGui各种控件的实现"></a>ImGui各种控件的实现</h2><ul>
<li><a href="https://qiita.com/ousttrue/items/ae7c8d5715adffc5b1fa" target="_blank" rel="noopener">ImGuiのWidgets</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>ImGui</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-反射机制</title>
    <url>/ue4-reflection/</url>
    <content><![CDATA[<p>反射在其它的比如说C#，JAVA语言中比较常见。反射概况的来说是描述类在运行时的状态，反射中包含的信息有类名，类数据成员，数据成员类型，还有每个成员位于对象内存映像的偏移(offset)，类所有成员函数的信息。</p>
<a id="more"></a>
<p>C++本身是不支持反射的，4在C++的基础上搭建了自己的一套反射机制。</p>
<h1 id="UE4的反射机制原理"><a href="#UE4的反射机制原理" class="headerlink" title="UE4的反射机制原理"></a>UE4的反射机制原理</h1><ul>
<li><a href="https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection?sessionInvalidated=true&amp;lang=en-US" target="_blank" rel="noopener">Unreal Property System (Reflection)</a></li>
</ul>
<p>Property system的层级<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UField</span><br><span class="line">        UStruct</span><br><span class="line">                UClass (C++ class)</span><br><span class="line">                UScriptStruct (C++ struct)</span><br><span class="line">                UFunction (C++ function)</span><br><span class="line"></span><br><span class="line">        UEnum (C++ enumeration)</span><br><span class="line"></span><br><span class="line">        UProperty (C++ member variable <span class="keyword">or</span> function parameter)</span><br><span class="line"></span><br><span class="line">                (Many subclasses <span class="keyword">for</span> different types)</span><br></pre></td></tr></table></figure></p>
<p>上面的文章虽然是很久之前文章，但是还是很厉害。</p>
<h2 id="利用反射对属性进行读写"><a href="#利用反射对属性进行读写" class="headerlink" title="利用反射对属性进行读写"></a>利用反射对属性进行读写</h2><p>最近在搞使用ImGui对ini文件进行读写的功能，同时又希望像UE4的Editor那样，对于添加的UCLASS的类中的UPROPERTY属性自动的显示各种类型的UI。于是就研究了一下反射，虽然原理什么的我还是不是很清楚，希望能多读读上面的文章而不是只是单纯的记录下来，终归动还是能动的。</p>
<p>直接贴上代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Debug settings UI</span></span><br><span class="line"><span class="keyword">bool</span> show_about_app = <span class="literal">true</span>;</span><br><span class="line">ImGui::Begin(<span class="string">"DebugSettings"</span>, &amp;show_about_app, ImGuiWindowFlags_AlwaysAutoResize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creaete DebugUI for UObject</span></span><br><span class="line"><span class="keyword">bool</span> AnyPropertiesEdited = <span class="literal">false</span>;</span><br><span class="line">UClass* obj = DebugSettings-&gt;GetClass();</span><br><span class="line"><span class="keyword">for</span>(TFieldIterator&lt;FProperty&gt; PropertyIterator(obj); PropertyIterator; ++PropertyIterator)</span><br><span class="line">&#123;</span><br><span class="line">        FProperty* Property = *PropertyIterator;</span><br><span class="line">        <span class="keyword">if</span>(FBoolProperty* BoolProperty = CastField&lt;FBoolProperty&gt;(Property))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// UE_LOG(LogTemp, Log, TEXT("cast bool property successed."));</span></span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">bool</span> sampleBool = BoolProperty-&gt;GetPropertyValue_InContainer(DebugSettings);</span><br><span class="line">                ImGui::Checkbox(TCHAR_TO_ANSI(*BoolProperty-&gt;GetName()), &amp;sampleBool);</span><br><span class="line">                <span class="keyword">if</span>(ImGui::IsItemEdited())</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Apply changes</span></span><br><span class="line">                        BoolProperty-&gt;SetPropertyValue(BoolProperty-&gt;ContainerPtrToValuePtr&lt;<span class="keyword">bool</span>&gt;(DebugSettings), sampleBool);</span><br><span class="line">                        AnyPropertiesEdited = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(FIntProperty* IntProperty = CastField&lt;FIntProperty&gt;(Property))</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="comment">// UE_LOG(LogTemp, Log, TEXT("cast int property successed."));</span></span><br><span class="line">                <span class="keyword">static</span> <span class="keyword">int</span> sampleInt = IntProperty-&gt;GetPropertyValue_InContainer(DebugSettings);</span><br><span class="line">                ImGui::InputInt(TCHAR_TO_ANSI(*IntProperty-&gt;GetName()), &amp;sampleInt);</span><br><span class="line">                <span class="keyword">if</span>(ImGui::IsItemEdited())</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// Apply changes</span></span><br><span class="line">                        IntProperty-&gt;SetPropertyValue(IntProperty-&gt;ContainerPtrToValuePtr&lt;<span class="keyword">int</span>&gt;(DebugSettings), sampleInt);</span><br><span class="line">                        AnyPropertiesEdited = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(AnyPropertiesEdited)</span><br><span class="line">&#123;</span><br><span class="line">        DebugSettings-&gt;SaveConfig();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImGui::End();</span><br></pre></td></tr></table></figure></p>
<p>没有对应所有的类型，但是知道了方法就行了。</p>
<p>这其中有一篇文章很重要：</p>
<ul>
<li><a href="https://www.ayumax.net/entry/2020/03/22/144226" target="_blank" rel="noopener">UProperty -&gt; FPropertyへの変化(UE4 4.25)</a></li>
</ul>
<p>UE4.25版本更改了<code>UProperty-&gt;FProperty</code>，跟之前写法会有些出入</p>
<p>还参考了其他人的提问的文章</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/108323-how-to-list-uproperties-of-an-uobject-at-runtime-read-write-uproperty" target="_blank" rel="noopener">How to list UProperties of an UObject at runtime? Read/write UProperty?</a></li>
</ul>
<h2 id="利用反射对函数进行操作"><a href="#利用反射对函数进行操作" class="headerlink" title="利用反射对函数进行操作"></a>利用反射对函数进行操作</h2><p>有一天突发奇想，UE4的反射机制可不可以遍历<code>UObject</code>中的<code>UFUNCTION</code>？然后根据<code>UUFUNCTION</code>的的类型，比如说根据Meta修饰符来切换ImmGui的UI类型，Button啥的。</p>
<p>遍历<code>UFUNCTION</code>貌似是可行的:</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1461760-how-i-get-all-functions-of-one-object" target="_blank" rel="noopener">How I Get All Functions of one Object??? - Unreal Engine Forums</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UMyClass::ListAllObjectUFunctions(<span class="keyword">const</span> UObject* Object) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( TFieldIterator&lt;UFunction&gt; FIT ( Object-&gt;GetClass(), EFieldIteratorFlags::IncludeSuper ); FIT; ++FIT) &#123;</span><br><span class="line"></span><br><span class="line">        UFunction* Function = *FIT;</span><br><span class="line">        UE_LOG ( LogTemp, Log, TEXT( <span class="string">"Function Found:  %s();"</span> ), *Function-&gt;GetName() );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于自定义的Meta修饰符，我还没开始调查。啧。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/mohuak/article/details/81913532?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.add_param_isCf&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.add_param_isCf" target="_blank" rel="noopener">UE4反射原理的探究</a></li>
<li><a href="https://www.cnblogs.com/ghl_carmack/p/5698438.html" target="_blank" rel="noopener">虚幻4属性系统（反射）翻译</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/60622181" target="_blank" rel="noopener">UE4反射机制</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25098685" target="_blank" rel="noopener">《InsideUE4》UObject（四）类型系统代码生成</a></li>
</ul>
<p>感觉上面的文章都很重要。尤其是最后一篇。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4.25</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-版本4.25新特性</title>
    <url>/ue4-4.25-version-newfunction/</url>
    <content><![CDATA[<p>最近看了一些UE4.25版本更新内容的视频，不知道记录在哪个部分好就新开了一篇文章。用来记录我遇到的UE4 4.25版本的新特性。</p>
<a id="more"></a>
<h1 id="UE4-25版本新特性"><a href="#UE4-25版本新特性" class="headerlink" title="UE4.25版本新特性"></a>UE4.25版本新特性</h1><h2 id="IOStore"><a href="#IOStore" class="headerlink" title="IOStore"></a>IOStore</h2><ul>
<li><a href="https://www.youtube.com/watch?v=i31wSiqt-7w" target="_blank" rel="noopener">【UE4.25 新機能】ロードの高速化機能「IOStore」について</a></li>
</ul>
<h2 id="Unversioned-Property-Serialization"><a href="#Unversioned-Property-Serialization" class="headerlink" title="Unversioned Property Serialization"></a>Unversioned Property Serialization</h2><ul>
<li><a href="https://www.youtube.com/watch?v=V5tUNlfiJ5s" target="_blank" rel="noopener">【UE4.25 新機能】新しいシリアライゼーション機能「Unversioned Property Serialization」について</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4.25</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-对工程进行DEBUG的正确姿势</title>
    <url>/ue4-debug-your-project/</url>
    <content><![CDATA[<p>这篇文章目的是用来记录我在调查对UE4工程进行DEBUG需要的知识点的一些记录。一开始应该会非常杂乱，等有了更多的精力再好好整理吧。</p>
<a id="more"></a>
<h1 id="保留项目中的设定"><a href="#保留项目中的设定" class="headerlink" title="保留项目中的设定"></a>保留项目中的设定</h1><h2 id="对-ini-文件的读写"><a href="#对-ini-文件的读写" class="headerlink" title="对 ini 文件的读写"></a>对 ini 文件的读写</h2><p>UE4中的基本上所有的设定都是保存在ini文件中的。而我今天就要了解如何在UE4的Editor-ProjectSettings中对ini文件进行读写操作。</p>
<p>首先我们需要的是一个<strong>config object</strong>，然后把保存着设定数据的对象暴露给UE4的Editor方便其与接口对接进行操作，而不是直接对ini文件进行读写。</p>
<details><br>    <summary> Creating you settings object (Click to expand) </summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015 Moritz Wundke. All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Released under MIT.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CustomGameSettings.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Setting object used to hold both config settings and editable ones in one place</span></span><br><span class="line"><span class="comment"> * To ensure the settings are saved to the specified config file make sure to add</span></span><br><span class="line"><span class="comment"> * props using the globalconfig or config meta.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UCLASS(config = Game, defaultconfig)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UCustomGameSettings</span> :</span> <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UCustomGameSettings(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Sample bool property */</span></span><br><span class="line">    UPROPERTY(EditAnywhere, config, Category = Custom)</span><br><span class="line">    <span class="keyword">bool</span> bSampleBool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Sample float property that requires a restart */</span></span><br><span class="line">    UPROPERTY(EditAnywhere, config, Category = Custom, meta = (ConfigRestartRequired = <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">float</span> SampleFloatRequireRestart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Sample string list */</span></span><br><span class="line">    UPROPERTY(config, EditAnywhere, Category = Custom)</span><br><span class="line">    TArray&lt;FString&gt; SampleStringList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Or add min, max or clamp values to the settings */</span></span><br><span class="line">    UPROPERTY(config, EditAnywhere, Category = Custom, meta = (UIMin = <span class="number">1</span>, ClampMin = <span class="number">1</span>))</span><br><span class="line">    int32 ClampedIntSetting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** We can even use asset references */</span></span><br><span class="line">    UPROPERTY(config, EditAnywhere, Category = Materials, meta = (AllowedClasses = <span class="string">"MaterialInterface"</span>))</span><br><span class="line">    FStringAssetReference StringMaterialAssetReference;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>这里重要的有两处：</p>
<ul>
<li><code>UCLASS(config=Game, defaultconfig)</code> : 表明这是一个Config对象的UObject，存储的设定(ini)文件在默认的位置。</li>
<li><code>UPROPERTY(config)</code> : 将属性暴露给Editor的关键字，想要保存在ini文件中的属性一定要带上这个属性修饰符。</li>
</ul>
<p>之后就是空的构造函数的实现，这里直接省略了代码。</p>
<p>接下来是将我们准备好的<strong>config object</strong>登录到我们想要是有的Module上。这会让我们的configobject适用于任何的Module甚至是Plugins。这需要我们继承<strong>IModuleInterface</strong>接口并实现。由于plugins和工程的Module一般都是会继承这个接口，所以我们不需要刻意去实现，只要利用已经存在的<code>StartupModule</code>函数就足够了。</p>
<details><br>    <summary> Registering the object with our module (click to expand) </summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015 Moritz Wundke.All Rights Reserved.</span></span><br><span class="line"><span class="comment">// Released under MIT.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CustomSettings.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Settings</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CustomGameSettings.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ISettingsModule.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ISettingsSection.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ISettingsContainer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCTEXT_NAMESPACE <span class="meta-string">"CustomSettings"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FCustomSettingsModule</span> :</span> <span class="keyword">public</span> FDefaultGameModuleImpl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartupModule</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            RegisterSettings();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ShutdownModule</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (UObjectInitialized())</span><br><span class="line">            &#123;</span><br><span class="line">                    UnregisterSettings();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">SupportsDynamicReloading</span><span class="params">()</span> override</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Callback for when the settings were saved.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HandleSettingsSaved</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            UCustomGameSettings* Settings = GetMutableDefault&lt;UCustomGameSettings&gt;();</span><br><span class="line">            <span class="keyword">bool</span> ResaveSettings = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// You can put any validation code in here and resave the settings in case an invalid</span></span><br><span class="line">            <span class="comment">// value has been entered</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ResaveSettings)</span><br><span class="line">            &#123;</span><br><span class="line">                    Settings-&gt;SaveConfig();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RegisterSettings</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="comment">// Registering some settings is just a matter of exposing the default UObject of</span></span><br><span class="line">            <span class="comment">// your desired class, feel free to add here all those settings you want to expose</span></span><br><span class="line">            <span class="comment">// to your LDs or artists.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;(<span class="string">"Settings"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="comment">// Create the new category</span></span><br><span class="line">                    ISettingsContainerPtr SettingsContainer = SettingsModule-&gt;GetContainer(<span class="string">"Project"</span>);</span><br><span class="line"></span><br><span class="line">                    SettingsContainer-&gt;DescribeCategory(<span class="string">"CustomSettings"</span>,</span><br><span class="line">                            LOCTEXT(<span class="string">"RuntimeWDCategoryName"</span>, <span class="string">"CustomSettings"</span>),</span><br><span class="line">                            LOCTEXT(<span class="string">"RuntimeWDCategoryDescription"</span>, <span class="string">"Game configuration for the CustomSettings game module"</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Register the settings</span></span><br><span class="line">                    ISettingsSectionPtr SettingsSection = SettingsModule-&gt;RegisterSettings(<span class="string">"Project"</span>, <span class="string">"CustomSettings"</span>, <span class="string">"General"</span>,</span><br><span class="line">                            LOCTEXT(<span class="string">"RuntimeGeneralSettingsName"</span>, <span class="string">"General"</span>),</span><br><span class="line">                            LOCTEXT(<span class="string">"RuntimeGeneralSettingsDescription"</span>, <span class="string">"Base configuration for our game module"</span>),</span><br><span class="line">                            GetMutableDefault&lt;UCustomGameSettings&gt;()</span><br><span class="line">                            );</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Register the save handler to your settings, you might want to use it to</span></span><br><span class="line">                    <span class="comment">// validate those or just act to settings changes.</span></span><br><span class="line">                    <span class="keyword">if</span> (SettingsSection.IsValid())</span><br><span class="line">                    &#123;</span><br><span class="line">                            SettingsSection-&gt;OnModified().BindRaw(<span class="keyword">this</span>, &amp;FCustomSettingsModule::HandleSettingsSaved);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnregisterSettings</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="comment">// Ensure to unregister all of your registered settings here, hot-reload would</span></span><br><span class="line">            <span class="comment">// otherwise yield unexpected results.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ISettingsModule* SettingsModule = FModuleManager::GetModulePtr&lt;ISettingsModule&gt;(<span class="string">"Settings"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                    SettingsModule-&gt;UnregisterSettings(<span class="string">"Project"</span>, <span class="string">"CustomSettings"</span>, <span class="string">"General"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IMPLEMENT_PRIMARY_GAME_MODULE( FCustomSettingsModule, CustomSettings, <span class="string">"CustomSettings"</span> );</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LOCTEXT_NAMESPACE</span></span><br></pre></td></tr></table></figure><br><br></details>

<p>像上面这样我们就在UE4的<code>Project Settings</code>就能看到我们新添加的Category：CustomSettings，<br><img src="Screenshot 2020-11-14 150422.jpg" alt="Register the settings"></p>
<p>从函数的名称可以猜测，UE4的ProjectSettings的界面分成了Container，Category，Section。</p>
<p>在我参照的文章的最后提到了一个最简单的向ProjectSettings中追加新的Category的方法。就是直接使用<code>UDeveloperSettings</code>类，这样默认的就是直接在ProjectSetting中的Game的Section中出现我们新的项目</p>
<details><br>    <summary> Using Auto-discovery Settings : Click to expand </summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UCLASS(config=Game, defaultconfig, meta=(DisplayName=<span class="string">"My Settings"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOADINGSCREEN_API</span> <span class="title">UMyDeveloperSettings</span> :</span> <span class="keyword">public</span> UDeveloperSettings</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_UCLASS_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add all your properties here as we did before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details>

<p>这样我们就可以使用UE4准备的接口进行差不多全部的设定的读写了。但是对UE4是如何管理ini文件的流程完全没有深入的了解。</p>
<h3 id="Config-ConfigName"><a href="#Config-ConfigName" class="headerlink" title="Config=ConfigName"></a>Config=ConfigName</h3><p>关于UCLASS的限定修饰符<strong>config</strong></p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers/index.html" target="_blank" rel="noopener">Class Specifiers</a></li>
</ul>
<blockquote>
<p>Config=ConfigName</p>
<p>Indicates that this class is allowed to store data in a configuration file (.ini). If there are any class properties declared with the config or globalconfig Specifiers, this Specifier causes those properties to be stored in the named configuration file. This Specifier is propagated to all child classes and cannot be negated, but child classes can change the config file by re-declaring the config Specifier and providing a different ConfigName. Common ConfigName values are “Engine”, “Editor”, “Input”, and “Game”.</p>
</blockquote>
<p>经过验证，UCLASS中的<strong>config</strong>修饰符决定了ini文件的名称，<strong>defaultconfig</strong>决定了ini文件的路径。关于还有没有其他的关键字我不清楚。应该还有。</p>
<ul>
<li><code>config=Game, defaultconfig</code> : 会存在<em>ProjectName/Config/DefaultGame.ini</em>设定文件中。</li>
</ul>
<p>同理将Game替换为上面的”Engine”, “Editor”, “Input”，就会保存在各种的<em>DefaultEngine.ini</em>，<em>DefaultEditor.ini</em>，<em>DefaultInput.ini</em>文件中。</p>
<p>但是于此同时在<em>Project/Saved/Config/Windows</em>文件夹下也会相应的生成<em>Game.ini</em>，<em>Engine.ini</em>， <em>Editor.ini</em>，<em>Input.ini</em>文件，这涉及到了一些更复杂的机制。Game，Engine，Editor这些都是在创建项目的时候UE4为我们自动创建的，也是基本上常用的设定文件。但是当我们决定使用我们自己的设定文件的时候，比如说这样写：</p>
<ul>
<li><code>config=DebugSettings, defaultconfig</code></li>
</ul>
<p>那么我们会发现在<em>Project/Config</em>的默认的设定文件文件夹中出现了<em>DefaultDebugSettings.ini</em>设定文件，同时在Saved的文件中的设定文件中的出现了<em>DebugSettings.ini</em>文件夹。这就涉及到了UE4的ini设定文件的管理问题了，说实话我只是观察到了现象，对于源码并没有进行深入的了解。</p>
<p>当我们不使用<em>defaultconfig</em>修饰符的话，我们的<em>Project/Config</em>文件夹下就不会生成设定文件，只有Saved文件夹下会生成相应的ini文件。</p>
<p>除了藉由UE4的Editor的SettingsModule对ini文件进行读写之外，还可以使用提供的函数。</p>
<ul>
<li>SaveConfig</li>
<li>LoadConfig</li>
</ul>
<p>关于自定义读写和对UE4的设定文件的更详细的说明，我发现了一篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/u012999985/article/details/52801264" target="_blank" rel="noopener">UE4 Config配置文件详解（2017.4.1更新）</a></li>
</ul>
<p>这篇文章说的额非常详细，也涉及到了我在简略的读这一部分代码的时候遇到的一些类方法的说明，有时间的话可以把这篇文章的内容摘抄一下嘿嘿。</p>
<h3 id="从命令行对设定进行重写"><a href="#从命令行对设定进行重写" class="headerlink" title="从命令行对设定进行重写"></a>从命令行对设定进行重写</h3><p>ini文件设定是可以在UE4启动的时候用命令行的形式对其进行重新赋值的，就像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-ini:inifile:[section1]:parameter1=value1,[section2]:parameter2=value2,...</span><br></pre></td></tr></table></figure></p>
<ul>
<li>inifile : 是<strong>configfile</strong>的名字，应该就是UCLASS修饰符的<code>config=ConfigName</code>中的ConfigName，比如说DefaultEngine.ini的情况就是<code>Engine</code>。</li>
<li>section : 是ini文件中的section名字，类似于[/Script/Engine.Engine]</li>
<li>parameter1=value1 : 重新值的方式</li>
</ul>
<p>由于我并没有直接验证过，估计要以后使用了才会知道，只记录下我找的资料链接</p>
<ul>
<li><a href="https://www.cc2.co.jp/blog/?p=21872" target="_blank" rel="noopener">第006回 コマンドラインからConfig設定を上書きする時の注意点</a></li>
</ul>
<h3 id="LOCTEXT"><a href="#LOCTEXT" class="headerlink" title="LOCTEXT"></a>LOCTEXT</h3><p>硬要说的话是上面的代码中：<code>LOCTEXT_NAMESPACE</code>的作用，这涉及到了UE4的LocalizationSystem的问题，我也是完全不知道啊，反正遇到的上面的问题就是在我使用<code>LOCTEXT</code>的时候，没有在开始定义那个NAMESPACE的时候就会报错。</p>
<p>简单的贴一下链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/849059/view.html?sort=oldest" target="_blank" rel="noopener">#define LOCTEXT_NAMESPACE “Something”</a></li>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html" target="_blank" rel="noopener">Text Localization</a></li>
</ul>
<p>涉及到了本地化的内容，感觉超级重要，先记录下来链接之后一定要另外整理：</p>
<ul>
<li><a href="https://www.slideshare.net/EpicGamesJapan/ue4-ue4-localization-deep-dive-191115517" target="_blank" rel="noopener">UE4のローカライズ機能紹介 (UE4 Localization Deep Dive)</a></li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>基本上都是参照这一篇的内容。</p>
<ul>
<li><a href="https://nerivec.github.io/old-ue4-wiki/pages/customsettings.html" target="_blank" rel="noopener">Custom Settings</a></li>
<li><a href="https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles/index.html" target="_blank" rel="noopener">Configuration Files</a></li>
</ul>
<h2 id="对ini文件的深度读写"><a href="#对ini文件的深度读写" class="headerlink" title="对ini文件的深度读写"></a>对ini文件的深度读写</h2><p>上面的内容只是单纯的介绍了使用UE4的Editor来对ini文件进行读写，由于很多读写的细节被封装到了Editor当中，使用自制的Debug工具的时候少不了对ini文件的读写。所以这一部分用来记录我调查的内容。</p>
<p>关于ImGui的内容在另一篇文章。</p>
<p>关于如何做到自己对ini文件读写，首先我无意间看到这篇文章：</p>
<ul>
<li><a href="https://blog.cnu.jp/2015/12/19/hidden-parameter/" target="_blank" rel="noopener">設定ファイルのヒミツ - Happy My Life</a></li>
</ul>
<p>这之后应该是对源码的解析，和自己使用ini文件的案例的分析和记录。</p>
<h1 id="Asset加载的实时观测"><a href="#Asset加载的实时观测" class="headerlink" title="Asset加载的实时观测"></a>Asset加载的实时观测</h1><p>最近在调查如何在Realtime情况下观测UE4中Assets的Load和UnLoad，好像调查方向有点走偏了。</p>
<h2 id="Asset-Registry"><a href="#Asset-Registry" class="headerlink" title="Asset Registry"></a>Asset Registry</h2><p>在我苦苦追寻有没有什么函数回调可以追踪UE4中的Asset的加载的时候找到了这个Module，就一些人所说，</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/812628/track-assets-loaded-inside-the-game.html" target="_blank" rel="noopener">Track assets loaded inside the game</a></li>
</ul>
<p>在<code>FAssetRegistryModule</code>和<code>IAssetRegistry</code>API源码中可以寻找答案，更准确的说是<code>OnInMemoryAsset</code>事件。</p>
<p>结果是否答案在它们身上我也不是很清楚，因为我对UE4本身的资源管理不是了解的缘故，我也不敢随便下结论。首先是<strong>AssetRegistry</strong>这个是什么开始。</p>
<blockquote>
<p>The Asset Registry is an editor subsystem which gathers information about unloaded assets asynchronously as the editor loads. This information is stored in memory so the editor can create lists of assets without loading them. The information is authoritative and is kept up to date automatically as assets are changed in memory or files are changed on disk. The Content Browser is the primary consumer for this system, but it may be used anywhere in editor code.</p>
</blockquote>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/Assets/Registry/index.html" target="_blank" rel="noopener">Asset Registry</a></li>
</ul>
<p>首先是官网的解读，AssetRegistry是Editor的子系统，用来收集各种Asset的加载信息。这些情报被加载在内存当中，Editor会根据这些情报管理那些加载和未被加载的Asset。而AssetRegistry的主要消费对象是Editor的<strong>Content Browser</strong>。</p>
<p>其实调查到这里我就觉得有点偏了，因为这个感觉主要面向对象是UE4的Editor，想要自己制作Debugger的话，不知道能不能用啊。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FAssetRegistryModule&amp; AssetRegistryModule = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(<span class="string">"AssetRegistry"</span>);</span><br><span class="line">TArray&lt;FAssetData&gt; AssetData;</span><br><span class="line"><span class="keyword">const</span> UClass* Class = UStaticMesh::StaticClass();</span><br><span class="line">AssetRegistryModule.Get().GetAssetsByClass(Class, AssetData);</span><br></pre></td></tr></table></figure>
<p>很遗憾官网上的这段代码并不能执行，函数的参数类型对不上。</p>
<p>下面这段至少是我在UE4.25版本的时候执行可以顺利运行的代码。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FAssetRegistryModule&amp; AssetRegistryModule = FModuleManager::LoadModuleChecked&lt;FAssetRegistryModule&gt;(<span class="string">"AssetRegistry"</span>);</span><br><span class="line">        TArray&lt;FAssetData&gt; AssetDatas;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // const FName ClassName = </span></span><br><span class="line"><span class="comment">        AssetRegistryModule.Get().GetAssetsByClass("StaticMesh", AssetDatas);</span></span><br><span class="line"><span class="comment">        if(AssetDatas.Num() &gt; 0)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">                for (FAssetData Element : AssetDatas)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                        UE_LOG(LogTemp, Log, TEXT("%s"), *(Element.AssetName.ToString()));</span></span><br><span class="line"><span class="comment">                        // if(Element.IsAssetLoaded())</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        AssetRegistryModule.Get().GetAllAssets(AssetDatas);</span><br><span class="line">                <span class="keyword">if</span>(AssetDatas.Num() &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">for</span> (FAssetData Element : AssetDatas)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="comment">// UE_LOG(LogTemp, Log, TEXT("%s"), *(Element.AssetName.ToString()));</span></span><br><span class="line">                        <span class="keyword">if</span>(Element.IsAssetLoaded())</span><br><span class="line">                        &#123;</span><br><span class="line">                                UE_LOG(LogTemp, Log, TEXT(<span class="string">"%s"</span>), *(Element.AssetName.ToString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里注目的是两个函数：</p>
<ul>
<li><code>GetAllAssets(AssetDatas)</code>: 直接查看代码的话，这个函数会返回在这个Registry中所有的Assets，但是比较慢，推荐使用另一个有Filter版本的函数。</li>
<li><code>IsAssetLoaded()</code> : 检查Asset是否被加载。</li>
</ul>
<p>还有就是判断一个Asset是否已经被加载的判断是已被加载的Asset是可以被<code>FindObject</code>到的，但也是我读了代码的一点推测而已。</p>
<p>关于AssetRegistry更加详细的解释，我发现了这样的文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/76964514" target="_blank" rel="noopener">UE4 AssetRegistry分析</a></li>
</ul>
<p>再就是官方文档和源码了，由于时间关系，先理解到这里。</p>
<p>关于AssetRegistry更加准确，或说是更好的概括的一个答案：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/877592/what-is-asset-registry-used-for.html" target="_blank" rel="noopener">What is Asset Registry used for?</a></li>
</ul>
<blockquote>
<p>To understand what asset registry is you need to understand what asset is in technical term.</p>
<p>Asset is a UObject that can be dumped down to file (uasset package) and can be loaded back to the memory from that file and in is mainly used to store game resources, when you load them they are avable in memory as UObject objects like UBlueprint, UTexture2D, USkeletalMesh. USoundWave and so on. Every type of asset you see in content browser has corresponding class and each asset you see in “content Browser” is a UObject that is in memory or can be loaded in memory.</p>
<p>As assets are UObjects normally you would seek them out from reflection system. But because assets exists also on files and don’t need to be loaded to memory all the time when they are unused (they would just waste memory space), there need to be object that needs to keep track of them regardless if they are loaded or not. Searching them in reflection system is pointless if they are not loaded first. And that what AsssetRegistry is. it allows you to list out assets, get there regestry entry (FAssetData) and load them up, it also a to more optimized way to seek assets that are loaded already, as well as edit there registry information. And yes “Content Browser” in reality is Asset Registry explorer and it mainly use AssetRegistry to list and edit assets in there. It also provides event delegates which let you track live any changes done to asset registry.</p>
<p>Best way to just look in API refrence to see what function it gives:</p>
<p><a href="https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/IAssetRegistry/index.html" target="_blank" rel="noopener">https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/IAssetRegistry/index.html</a></p>
<p>You can always access from anywhere via:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  AssetRegistryModule.Get()-&gt;...</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>Assets in registry are stored in paths (which you see as folder structure in content browser), if you want to request specific asset you need to know path for it (you can get it by right clicking asset and clicking Copy Reference). but you can also whole sets of assets using diffrent identificators. for example you can get all assets of specific class (class name as name if the asset class without U prefix:</p>
<p><a href="https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/IAssetRegistry/GetAssetsByClass/index.html" target="_blank" rel="noopener">https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/IAssetRegistry/GetAssetsByClass/index.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;  TArray&lt;FAssetData&gt; Assets;</span><br><span class="line">&gt;  AssetRegistryModule.Get()-&gt;GetAssetsByClass(FName(&quot;Texture2D&quot;),Assets,true);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>And oyu will get registry entires of assets in form of array of FAssetData structures:</p>
<p><a href="https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/FAssetData/index.html" target="_blank" rel="noopener">https://api.unrealengine.com/INT/API/Runtime/AssetRegistry/FAssetData/index.html</a></p>
<p>And you can load and get asset UObject it self by calling GetAsset()</p>
<p>LoadObject is a function that loads UObject form the file, it function is useful if you want to load asset (or not) that is outside of asset registry.</p>
<p>Find Object on other hand finds assets that is already loaded in memory.</p>
</blockquote>
<h2 id="Memreport命令抓取Asset的加载情况"><a href="#Memreport命令抓取Asset的加载情况" class="headerlink" title="Memreport命令抓取Asset的加载情况"></a>Memreport命令抓取Asset的加载情况</h2><p>这个命令的的得知来自于</p>
<ul>
<li><a href="https://www.unrealengine.com/ja/blog/debugging-and-optimizing-memory" target="_blank" rel="noopener">デバッグとメモリーの最適化</a></li>
</ul>
<p>在工程的命令行直接输入<code>Memrepory</code>，则会瞬间抓取这一帧的内存加载情况，结果会输出到你的<em>YourGame/Saved/Profiling/MemReports</em>文件夹中。</p>
<p><code>Memreport -Full</code>命令则会输出更详细的内容。BaseEngine.ini中的[MemReportCommands] Section下（带有-Full的情况下则是[MemReportFullCommands]）的所有命令都会在Memreport的命令执行后被执行</p>
<p>还有一些其他的命令等待我去发现。</p>
<h3 id="抓取数据"><a href="#抓取数据" class="headerlink" title="抓取数据"></a>抓取数据</h3><p>应用的启动参数(Standalone模式启动的额外参数)指定<code>Loadtime</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-trace=Loadtime</span><br></pre></td></tr></table></figure></p>
<p>想要获取更多情报的话，CPUEvent或者I/O事件的情报，添加更多参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-trace=Loadtime,File,Cpu -statnamedevents</span><br></pre></td></tr></table></figure></p>
<p>至于其他的命令，遇见在做记录吧。</p>
<h2 id="Unreal-Insight-Asset-Loading-Insight"><a href="#Unreal-Insight-Asset-Loading-Insight" class="headerlink" title="Unreal Insight - Asset Loading Insight"></a>Unreal Insight - Asset Loading Insight</h2><p>最近研究如何使用UnrealInsights吃了一点闭门羹，隐藏的有点深啊，各种使用方法。这次参照的是UnealEngineJP的官方视频：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=NhehQI98lis&amp;app=desktop" target="_blank" rel="noopener">UE4.25 Update - Unreal Insights -</a></li>
</ul>
<p>只参照了AssetLoadingInsights的部分。</p>
<p><strong>Package(Shipping以外)可以使用。</strong></p>
<h2 id="Unreal-Insights-Memory-Innsights"><a href="#Unreal-Insights-Memory-Innsights" class="headerlink" title="Unreal Insights - Memory Innsights"></a>Unreal Insights - Memory Innsights</h2><p>UE4.26版本增加了Beta特性MemoryInsinsights的功能。</p>
<p>使用方法很普通的UnrealInsights差不多，以Standalone模式启动，添加额外的启动命令行参数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">-trace=memory</span><br></pre></td></tr></table></figure></p>
<p>参考资料：</p>
<ul>
<li><a href="https://qiita.com/EGJ-Ken_Kuwano/items/83425f450f6da100a9d0" target="_blank" rel="noopener">[UE4] Memory Insightsを使用したメモリトラッキング</a></li>
</ul>
<h2 id="Low-Level-Memory-Tracker"><a href="#Low-Level-Memory-Tracker" class="headerlink" title="Low-Level Memory Tracker"></a>Low-Level Memory Tracker</h2><p>据说是从4.18版本实装的一个可以追踪内存使用情况的工具。</p>
<blockquote>
<p>LLM supports PlayStation 4 and XboxOne. Windows is supported as an experimental feature.</p>
</blockquote>
<p>先简单介绍一下用法。</p>
<ul>
<li>打开LLM：Editor的话以Standalone模式，添加<code>-llm</code>启动参数</li>
<li>使用命令：<code>Stat LLM</code>, <code>Stat LLMFull</code>等命令就可以查看内存使用情况了。</li>
</ul>
<p>但是乍看一下输出的内存使用情况就很粗略，还有就是可以输出到CSV文件中查看，我暂时还不清楚使用CSV是否更好一些。</p>
<h3 id="LLMTAGSETS"><a href="#LLMTAGSETS" class="headerlink" title="LLMTAGSETS"></a>LLMTAGSETS</h3><p>这个功能是<strong>Experimenttal</strong>的功能，但是感觉的确是我想用的，便试了一下但是并不顺利。</p>
<p>首先由于还是实验性的功能，据其它的文章所说，我们需要开启这个功能：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Engine\Source\Runtime\Core\Public\HAL\LowLevelMemTracker.h 中可以找到</span></span><br><span class="line">    <span class="comment">// using asset tagging requires a significantly higher number of per-thread tags, so make it optional</span></span><br><span class="line">    <span class="comment">// even if this is on, we still need to run with -llmtagsets=assets because of the sheer number of stat ids it makes</span></span><br><span class="line">    <span class="comment">// LLM Assets can be viewed in game using 'Stat LLMAssets'</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> LLM_ALLOW_ASSETS_TAGS 0</span></span><br></pre></td></tr></table></figure></p>
<p>源码是0，所以我改成了1，重新编译之后就发生了错误，原因是：<code>FStatGroup_STATGROUP_LLMAssets: undeclared identifier</code>。总而言之调查结果就是在相同路径下的<code>LowLevelMemStats.h</code>文件中的内容出了问题，因为当中的所有代码都没有被编译进去。</p>
<p>原因是一开始的编译条件中有一个<strong>WITH_ENGINE</strong>的宏定义值为0，为什么啊，我又搜了一下这个是什么</p>
<ul>
<li><a href="https://imzlp.me/posts/5214/" target="_blank" rel="noopener">Macro defined by UBT in UE4</a></li>
</ul>
<p>也就在这种文章中有所提及，貌似是涉及到UE4的UBT的配置问题，但是我对UBT也不是特别了解。</p>
<h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/Development/Tools/LowLevelMemoryTracker/index.html" target="_blank" rel="noopener">Low-Level Memory Tracracker</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/78005333" target="_blank" rel="noopener">UE4 Low Level Memory Tracker 使用</a></li>
<li><a href="https://qiita.com/donbutsu17/items/dd410cd6ee53b0b348ca" target="_blank" rel="noopener">[UE4] LLM (Low Level Memory Tracker)を使用したメモリトラッキング</a></li>
</ul>
<h1 id="一些优化的小技巧"><a href="#一些优化的小技巧" class="headerlink" title="一些优化的小技巧"></a>一些优化的小技巧</h1><p>在对UE4的逐渐学习理解过程中，会遇见一些常见的优化小技巧。</p>
<h2 id="Uin8变量的使用"><a href="#Uin8变量的使用" class="headerlink" title="Uin8变量的使用"></a>Uin8变量的使用</h2><p>在UE4的源码中经常会见到一些看起来比较违和的变量声明：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uint8 bCanBeDamaged : <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>之前我什么都不懂，以为只是一种布尔型变量的初始化，上面的就是初始化为true的意思，实际上就是我真的什么都不懂。</p>
<p>按照别人的解答，这样的写法，首先是UE4默认的布尔类型变量的声明是以小写字母<code>b</code>开始的，而数字<code>1</code>的含义则是只使用1bit位。这是节省内存的表现，相比于布尔类型的数据。这是它们的唯一的不同。</p>
<p>为了方便理解原文，贴上原答案：</p>
<blockquote>
<p>All booleans in Unreal are prefixed with b. If you see a uint with the b prefix it is declared as a bit field like <code>uint8 bCanBeDamaged:1</code> The 1 in the end indicates that it only uses 1 bit. <code>bCanBeDamaged == true</code> is perfectly fine to do even though it is a uint8. The reason a bit field is used instead of a bool is to save memory and the only difference between a uint8 bit field and a bool is the way it is declared.</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/888947/uint8-confusion-why-not-bool.html" target="_blank" rel="noopener">Uint8 Confusion .. Why not bool?</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-一个Actor的生命周期</title>
    <url>/ue4-actor-lifecycle/</url>
    <content><![CDATA[<p>关于Actor的生命周期，与很多初始化的操作相关联，准备整理到这篇文章中。</p>
<a id="more"></a>
<h1 id="Actor-Lifecycle"><a href="#Actor-Lifecycle" class="headerlink" title="Actor Lifecycle"></a>Actor Lifecycle</h1><ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/ActorLifecycle/index.html" target="_blank" rel="noopener">Actor Lifecycle - What actually happens when an Actor is loaded or spawned, and eventually dies.</a></li>
</ul>
<p>首先是官方文档。</p>
<h1 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h1><h3 id="SpawnActorDeferred"><a href="#SpawnActorDeferred" class="headerlink" title="SpawnActorDeferred"></a>SpawnActorDeferred</h3><p>遇到了一个Actor的生成问题，不过关于物体的动态生成一直都是一个非常重要的问题。</p>
<p>首先看一下GASDocumentation中的一段代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, Meta = (ExposeOnSpawn = <span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">float</span> Range;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, Meta = (ExposeOnSpawn = <span class="literal">true</span>))</span><br><span class="line">    FGameplayEffectSpecHandle DamageEffectSpecHandle;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">    AGDProjectile* Projectile = GetWorld()-&gt;SpawnActorDeferred&lt;AGDProjectile&gt;(ProjectileClass, MuzzleTransform, GetOwningActorFromActorInfo(), Hero, ESpawnActorCollisionHandlingMethod::AlwaysSpawn);</span><br><span class="line">    Projectile-&gt;DamageEffectSpecHandle = DamageEffectSpecHandle;</span><br><span class="line">    Projectile-&gt;Range = Range;</span><br><span class="line">    Projectile-&gt;FinishSpawning(MuzzleTransform);</span><br></pre></td></tr></table></figure></p>
<h4 id="Deferred-Spawn"><a href="#Deferred-Spawn" class="headerlink" title="Deferred Spawn"></a>Deferred Spawn</h4><p>这种生成Actor的方法被这样称为</p>
<blockquote>
<p>An Actor can be Deferred Spawned by having any properties set to “Expose on Spawn.”</p>
<ol>
<li><p><strong>SpawnActorDeferred</strong> - meant to spawn procedural Actors, allows additional setup before Blueprint construction script.</p>
</li>
<li><p>Everything in SpawnActor occurs, but after PostActorCreated the following occurs:</p>
<ol>
<li>Do setup / call various “initialization functions” with a valid but incomplete Actor instance.</li>
<li><strong>FinishSpawningActor</strong> - called to Finalize the Actor, picks up at ExecuteConstruction in the Spawn Actor line.</li>
</ol>
</li>
</ol>
</blockquote>
<p>就像上面描述的和那样的使用方法。</p>
<h4 id="Expose-on-Spawn"><a href="#Expose-on-Spawn" class="headerlink" title="Expose on Spawn"></a>Expose on Spawn</h4><p>上面的例子提到了了这个属性修饰符，在Blueprint中也能找到这个条目。</p>
<p>感觉就是因为这个属性才会用到<strong>DeferredSpaen</strong>，经常在Blueprint中会有<code>SpawnActorByClass</code>的时候，当我们在C++使用了上面的修饰符和写法之后，在这个函数的里面就会出现”Exposed“属性。</p>
<p>所以就像上面说的那样，允许在BP的Construction之前做一些设置。</p>
<p>嘛先记住吧总归是有好处的。</p>
<ul>
<li><a href="https://papersloth.hatenablog.com/entry/2018/04/13/232533" target="_blank" rel="noopener">UE4 C++でのExposeOnSpawnについて</a></li>
</ul>
<p>按照上面的文章内容所说，在蓝图中设置的时候除了<strong>Expose on Spawn</strong>需要check之外，<strong>instance editable</strong>一项也需要被check，理由暂时不太清楚。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-多人游戏框架理解</title>
    <url>/ue4-multiplay-framework/</url>
    <content><![CDATA[<p>UE4中有对多人游戏模式的支持，本篇会记载一些与之相关的比较繁杂的知识点，一上来还是不可能就对所有的框架就能进行归纳总结的吧。</p>
<a id="more"></a>
<h1 id="UE4框架总览"><a href="#UE4框架总览" class="headerlink" title="UE4框架总览"></a>UE4框架总览</h1><p>首先是对UE4的框架进行认知，UE4是以什么样的模式来定义多人游戏的。首先是官方文档的描述</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Overview/index.html" target="_blank" rel="noopener">Networking Overview</a></li>
</ul>
<p>即<strong>Server/Client</strong>的构成，我目前所知的就两种：</p>
<ul>
<li>Listen Server</li>
<li>Dedicated Server</li>
</ul>
<p>下面的这篇是关于多人游戏设计的文章，总结了很多重要的知识。</p>
<ul>
<li><a href="https://www.slideshare.net/EpicGamesJapan/online-multiplay-game-design" target="_blank" rel="noopener">Online MultiPlay Game Design</a></li>
</ul>
<p>下面让我开始真正的UE4多人框架理解之旅。</p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>首先是一些基础的概念，暂时还不需要对实现进行深究，但至少要知道。</p>
<p>首先是UE4中提供的几种网络模式和服务器类型。当然这些大多数是上面的官方文档的内容，我感觉用中文表达出来更方便我查找和回忆。</p>
<h3 id="Network-Modes-and-Sever-Types"><a href="#Network-Modes-and-Sever-Types" class="headerlink" title="Network Modes and Sever Types"></a>Network Modes and Sever Types</h3><p>要以什么样的方式来开发，单人还是多人。在UE4的运行界面选定自己想要开始运行的网络模式。</p>
<style>

  table {
    table-layout: fixed;
    /*width: 1000px;*/ /*表格宽度*/
    max-width: 1000px; /*表格最大宽度，避免表格过宽*/
    border: 1px solid #dedede; /*表格外边框设置*/
    margin: 15px auto; /*外边距*/
    border-collapse: collapse; /*使用单一线条的边框*/
    word-break:break-all;
    word-wrap:break-word;
    empty-cells: show; /*单元格无内容依旧绘制边框*/
  }
  table th,
  table td {
    height: 35px; /*统一每一行的默认高度*/
    border: 1px solid #dedede; /*内部边框样式*/
    padding: 0 10px; /*内边距*/
  }
  table th {
    font-weight: bold; /*加粗*/
    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/
    background: rgba(158,188,226,0.2); /*背景色*/
  }

  table tbody tr:nth-child(2n) {
    background: rgba(158,188,226,0.12);
  }

  table th {
    white-space: nowrap; /*表头内容强制在一行显示*/
  }

  table th:nth-of-type(1){
    width: 20%;
  }
  table th:nth-of-type(2){
    width: 80%;
  }

</style>

<table>
<thead>
<tr>
<th>Network Mode</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Standalone</strong></td>
<td>就是以Server模式来运行，不接受任何来自别的客户端的连接</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>就是以Client模式来运行，不会执行服务器端的任何逻辑代码</td>
</tr>
<tr>
<td><strong>Listen <br> Server</strong></td>
<td>以Server模式来运行，也会接受来自其他客户端的网络连接(connections)而且存在一个本地玩家(Local Player)</td>
</tr>
<tr>
<td><strong>Dedicated <br> Server</strong></td>
<td>以Server模式来运行而且也会接受来自其他Client的连接，但是不存在本地玩家。所以这个模式下可以忽略画面，声音，用户输入，或者其他用户相关的特性，以此来提高Server的执行效率。这也是<strong>非常多的多人</strong> 游戏会采取的网络模式。</td>
</tr>
</tbody>
</table>
<h3 id="Actor-Replication"><a href="#Actor-Replication" class="headerlink" title="Actor Replication"></a>Actor Replication</h3><p><strong>Replication</strong>是我很早之前就接触到的名词，但是一直都很懵逼，不知道这个是干什么的。</p>
<blockquote>
<p><strong>Replication is the process of reproducing game state information between different machines in a network session.</strong></p>
</blockquote>
<p><strong>Replication</strong>(复制)是网络同步的一个非常非常重要的过程。恰当且正确的设置Replication，可以实现不同机器之间游戏状态的同步。默认情况下，Actor的Replication功能是关闭的，也就是说仅会在本地执行，不会将现在的状态同步到其他机器。可以很方便的通过C++设置<code>bReplicates = true</code>或者在Blueprint中把<strong>Replicates</strong>设置为<strong>true</strong>。</p>
<p>关于一些常见的Replication特性，使用Actor的Replication可以做什么事情</p>
<table>
<thead>
<tr>
<th>Replication Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Creation <br> and <br> Destruction</strong></td>
<td>如果一个具有权威(Authority)版本的并且被标记为Replicate(=true)的Actor于Server生成(Spawn)，它就会自动的生成一个远程代理(remote proxies)用来同步所有与之相连的客户端的数据。如果你销毁了这个Actor，它也会销毁这些代理。</td>
</tr>
<tr>
<td><strong>Movement <br> Replication</strong></td>
<td>如果Authoritative Actor的<strong>Replicate Movement</strong> 被激活(或者在C++中设置<code>bReplicateMovement</code>)，那么它的Location，Rotation，Velocity都会被同步。</td>
</tr>
<tr>
<td><strong>Variable <br> Replication</strong></td>
<td>Authoritive Actor中的变量如果被标记为<strong>Replicated</strong>，那么当该变量值被修改的时候，也会通过远程代理将修改同步到其它远程上。</td>
</tr>
<tr>
<td><strong>Component <br> Replication</strong></td>
<td>Actor的Components replicate同于其所属的的Actor，被标记为<strong>Replicated</strong>的变量同样会被复制，Component中的RPCs调用跟Actor类中的RPCs调用表现一致。</td>
</tr>
<tr>
<td><strong>Remote <br> Procedure <br> Calls(RPCs)</strong></td>
<td>RPCs是一种特殊的函数可以用来与特定的某个远程机器进行通信，不论是从哪一方调用。它可以被指定为<strong>Server(only runs on the server), Client(only runs on the Actor’s owning client), NetMulticast(runs on every machine conneted to the session, including the server)</strong>。</td>
</tr>
</tbody>
</table>
<p>这里举几个反例，几个常见的特性在，Actor，Pawns，Characters中不需要replicate的：</p>
<ul>
<li><strong>Skeletal Mesh</strong> and <strong>Static Mesh</strong> Components</li>
<li><strong>Materials</strong></li>
<li><strong>Animation Blueprints</strong></li>
<li><strong>Particle Systems</strong></li>
<li><strong>Sound Emitters</strong></li>
<li><strong>Physics Objects</strong></li>
</ul>
<blockquote>
<p>Each of these runs separately on all clients. However, if the variables that drive these visual elements are replicated, it will ensure that all client has the same information and therefore simulates them in approximately the same way.</p>
</blockquote>
<p>嘛，翻译过来总感觉不太对劲，大概就是那个意思。</p>
<h4 id="Actor-Replication的方式"><a href="#Actor-Replication的方式" class="headerlink" title="Actor Replication的方式"></a>Actor Replication的方式</h4><p>关于Actor的Replication是一个很大的课题，知道UE4为Replication到底做到了哪一步很重要。官网中说</p>
<blockquote>
<p>As mentioned in the networking overview, Actors are the main workhorse for replication. The server will maintain a list of actors, and will update the client periodically so that the client will maintain a close approximation of each actor (that is marked to be replicated).</p>
</blockquote>
<p>这一段来自<a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/index.html" target="_blank" rel="noopener">Actor Replication - The various aspects of replicating Actor objects and their components.</a></p>
<p>大意是说Actor是Replicate的主要的推动者，服务器会维护一个需要Replicate的Actor列表，定期的更新客户端数据，方便客户端维护这些Actor的值。</p>
<p>还有一种说法就是，Replication是以Actor为单位进行状态的复制的，我觉得这很贴切了。</p>
<p>Actor的更新主要通过两种方式：</p>
<ul>
<li>Property updates</li>
<li>RPCs (Remote Procedure Calls)</li>
</ul>
<p>两者之间的区别在于属性更新当属性的值改变的时候自动Replicate，而RPCs只有在被执行的时候会Replicate。</p>
<p>这里官网中所说，自动进行属性值的更新并不代表完全没有任何代价，在判断属性值是否有被修改这个过程中还是存在着一点CPU的资源占用。取而代之的就是未修改的属性不会占用我们带宽(network bandwidth)。</p>
<p>关于各种Replication的具体使用，在上面的链接中有一些介绍，暂时先等用到的时候再逐一整理了。</p>
<h4 id="Replicates-NetLoadOnClient"><a href="#Replicates-NetLoadOnClient" class="headerlink" title="Replicates NetLoadOnClient"></a>Replicates NetLoadOnClient</h4><p>在设置Actor的Replication的时候会遇到一些标志位，<strong>Replicates</strong>, <strong>NetLoadOnClient</strong>等等，它们之间有什么影响进行了验证。当然一开始我也是不知道的，于是问了公司的前辈，没想到前辈虽然不太清楚但是用非常详细的方式帮我验证了，这就是我跟强者之间的差距吗…</p>
<p>废话不多说直接上结论：</p>
<p><strong>就初级功能而言，Replicates和NetLoadOnClient的效果是一样的，在Server中无论哪个被设置为true，Actor都会在各个客户端生成。</strong></p>
<p>但是这也是仅针对初级功能而言：在游戏未运行的时候Server设置好，都会在Client中生成Actor，也就是说当你在UE4的Editor中把两个的任何一个设置为true，或者全部设置为true，都能观察到这个Actor在各个Client中都会被生成(以ListenServer模式运行)。当这两个都设置为false的时候，会发现这个只会在本地存在实例，不会被同步Spawn到其他远程上。</p>
<p>但是<strong>NetloadOnClient</strong>默认是true的，所以一般情况下没有必要特意的设置为false，除非是特殊情况只想生成本地实例。NetLoadOnClient貌似只是负责游戏最开始Play的时候是否要进行Actor的Creation Replication，还有最后游戏结束的Actor的Destruction Replication。</p>
<p>而<strong>Replicates</strong>则相当于更负责任的版本，除了Creation和Destruction的Replication之外，还会负责Variable的Replication。Actor的变量想要Replicate一定要把<strong>Replicates</strong>设置为true。</p>
<p>还有一种特殊的情况是当Actor的生成是动态的情况，也就是游戏运行的是Runtime生成Actor的时候，这两个变量对Replication的影响。结论就是：<strong>只有Replicates设置为true的时候，Actor会在各个Client生成远程版本，即Replication成功</strong>。</p>
<p>也就是说NetLoadOnClient对动态生成的Actor的Replication没有什么贡献。</p>
<p>那既然<strong>Replicates</strong>就足够用了，那我可以不可以手贱把Replicates设置为true，同时吧NetLoadOnClient设置为false呢？</p>
<p>答就是不要手贱，因为在Level.cpp中的Ulevel::InitializeNetworkActors()的处理中有这样的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!bIsServer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Actor-&gt;bNetLoadOnClient)</span><br><span class="line">    &#123;</span><br><span class="line">        Actor-&gt;Destory(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br></pre></td></tr></table></figure></p>
<p>不是Server的时候这个Actor直接会被Destroy掉，但是由于Replicates设置为true，Server又会让该Client重新Spawn这个Actor，就没必要。</p>
<p>所以这两个标志位的情况应该是这样：</p>
<ol>
<li>NetLoadOnClient = true (default), Replicates = true</li>
<li>NetLoadOnClient = true (default), Replicates = false (default)</li>
<li>NetLoadOnClient = false , Replicates = false (default)</li>
</ol>
<h4 id="bReplicateFlag的动态切换"><a href="#bReplicateFlag的动态切换" class="headerlink" title="bReplicateFlag的动态切换"></a>bReplicateFlag的动态切换</h4><p>在程序运行中很大程度上代表着Actor的Replication标识的bReplicate标识符可以动态的进行切换，我没有实际验证过，只是看到别人的总结的文章内容，就是下面那个<strong>Network处理流程</strong>中出现的那篇<a href="https://www.slideshare.net/EpicGamesJapan/ue4howtocreatemultiplayergame" target="_blank" rel="noopener">UE4でマルチプレイヤーゲームを作ろう</a></p>
<ul>
<li>False -&gt; True 切换<ul>
<li>登记到Replication列表(具体是什么列表？)，Client上没有被复制的Actor也会被复制</li>
</ul>
</li>
<li>True -&gt; False 切换<ul>
<li>被从列表删除，不再进行Replication复制，减轻CPU和带宽的负荷</li>
<li>被生成的<strong>ActorChannel</strong>仍然会维持原样</li>
<li>在Client上被复制(Replicate)过一次的Character不会消失！</li>
<li>Actor在被破坏的时候，即使是忘掉了bReplicate(应该是说想把其置为false)其ActorChannel的破坏联动使Client上的Actor也能被破坏掉。</li>
</ul>
</li>
</ul>
<p>这里面有些不知道的东西，比如说</p>
<ul>
<li>列表<ul>
<li>被登录到列表上的Actor会被复制，这个list说的是哪个list</li>
</ul>
</li>
<li>ActorChannel<ul>
<li>这个又是用来做什么的？</li>
<li>为什么生成的ActorChannel不会被一起释放掉？</li>
</ul>
</li>
<li>Character<ul>
<li>为什么曾经被Replicate过的Character不会消失？</li>
<li>是为了重连吗？</li>
</ul>
</li>
</ul>
<h3 id="Network-Role-and-Authority"><a href="#Network-Role-and-Authority" class="headerlink" title="Network Role and Authority"></a>Network Role and Authority</h3><p>一个拥有Authority权限的Actor决定了它是Network中的控制角色，控制Actor的状态(state)并且会将ReplicationInfomation同步到其它远程。<strong>远程代理(remote Proxy)</strong> 是在远程上的机器的复制，它会接收来自于Authority权限的Actor的ReplicationInformation用来同步自己的状态。</p>
<p><strong>Local Role</strong>和<strong>Romote Role</strong>变量用来指定这些Actor的Role：</p>
<table>
<thead>
<tr>
<th>Network Role</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>None</strong></td>
<td>代表着Actor在这个网络中不拥有role，不会被复制(replicate)</td>
</tr>
<tr>
<td><strong>Authority</strong></td>
<td>Actor具有Authority权限，会复制(replicate)自己到其他的远程代理(remote proxy)上。</td>
</tr>
<tr>
<td><strong>Simulated Proxy</strong></td>
<td>是完全由另外一个远程上具有Authority权限的Actor复制的远程代理。Netwrok中大多数的Actor，像拾取物，子弹，可交互物体大多表现为远程客户端的SimulatedProxy角色。</td>
</tr>
<tr>
<td><strong>Autonomous Proxy</strong></td>
<td>这种Actor是一种可以执行自己本地功能的远程代理(remote proxy)，但是会收到其他远程的AuthorityActor的校正，这种角色一般是直接控制玩家的角色准备的。比如Pawn</td>
</tr>
</tbody>
</table>
<p>UE4的默认模式是<strong>server-authoritative</strong>，也就是服务器端拥有Authority权限，总是会从Server到Client这样replicate。</p>
<p>更多的Actor的network roles信息可以参照<a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/Roles/index.html" target="_blank" rel="noopener">Actor Role and RemoteRole-The various aspects of replicating Actor objects.</a></p>
<p>简单的用表格来表示：</p>
<p><img src="Role_Replication.jpg" alt="Role_Replication"></p>
<p>不过说到这里这张图看得我还是不懂。有的时候还会搞错，直到我最近真正敲代码进行实战之后才搞明白。</p>
<p>就是总而言之，<strong>Server上的LocalRole都是Authority，而在Client上的PlayerController和Pawn是Autonomous之外，其它都是Simulated</strong>。</p>
<p>当然这种情况下的Actor都是设置正确的情况下，就是说在Server的Actor的Replication对象存在在Client上。那种Client纯本地生成的不好说。</p>
<p>Tips：</p>
<ul>
<li>Editor中检查是否是Server端<ul>
<li>C++中使用<code>GetNetMode() == ENetMode::NM_ListenServer</code>，函数放这里了，具体直接去源码找。参考这里<a href="https://answers.unrealengine.com/questions/416305/how-to-know-if-listenserverclient-owner-for-rpc.html" target="_blank" rel="noopener">How to know if listenserver/client, owner for rpc?</a></li>
<li>Blueprint中貌似可以直接使用<code>IsServer</code>节点</li>
</ul>
</li>
</ul>
<h3 id="Client-Ownership"><a href="#Client-Ownership" class="headerlink" title="Client Ownership"></a>Client Ownership</h3><p>这里可以参照<strong>Owning Connection</strong>部分。</p>
<h3 id="Relevance-and-Priority"><a href="#Relevance-and-Priority" class="headerlink" title="Relevance and Priority"></a>Relevance and Priority</h3><h3 id="Variable-Replication"><a href="#Variable-Replication" class="headerlink" title="Variable Replication"></a>Variable Replication</h3><h4 id="RepNotifies"><a href="#RepNotifies" class="headerlink" title="RepNotifies"></a>RepNotifies</h4><h3 id="Remote-Procedure-Calls-RPCs"><a href="#Remote-Procedure-Calls-RPCs" class="headerlink" title="Remote Procedure Calls (RPCs)"></a>Remote Procedure Calls (RPCs)</h3><p>参考官网的内容</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html" target="_blank" rel="noopener">RPCs - Designating function replication across the network</a></li>
</ul>
<p>这里的内容非常重要，有时间需要整理。</p>
<h4 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h4><h4 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h4><h3 id="Tips-and-Further-Reading"><a href="#Tips-and-Further-Reading" class="headerlink" title="Tips and Further Reading"></a>Tips and Further Reading</h3><h4 id="Basic-Replicated-Actor-Checklist"><a href="#Basic-Replicated-Actor-Checklist" class="headerlink" title="Basic Replicated Actor Checklist"></a>Basic Replicated Actor Checklist</h4><p>To create a replicated Actor, follow these steps:</p>
<ul>
<li><p>Set the Actor’s Replicated setting to True.</p>
</li>
<li><p>If the replicated Actor needs to move, set Replicates Movement to True.</p>
</li>
<li><p>When you spawn or destroy a replicated Actor, ensure that you do it on the server.</p>
</li>
<li><p>Set any variables that must be shared between machines to replicate. This usually applies to gameplay-essential variables.</p>
</li>
<li><p>Use Unreal Engine’s pre-made Movement Components whenever possible, as they are already built for replication.</p>
</li>
<li><p>If you are using a server-authoritative model, make sure any new actions that the player can perform are triggered by Server functions.</p>
</li>
</ul>
<h4 id="Networking-Tips"><a href="#Networking-Tips" class="headerlink" title="Networking Tips"></a>Networking Tips</h4><ul>
<li><p>Use as few RPCs or replicated Blueprint functions as possible. If you can use a RepNotify instead, you should.</p>
</li>
<li><p>Use Multicast functions especially sparingly, as they create extra network traffic for each connected client in a session.</p>
</li>
<li><p>Server-only logic does not necessarily have to be contained in a server RPC if you can guarantee that a non-replicated function will only execute on the server.</p>
</li>
<li><p>Be cautious when binding Reliable RPCs to player input. Players can repeatedly press buttons very rapidly, and that will overflow the queue for Reliable RPCs. You should use some way of limiting how often players can activate these.</p>
</li>
<li><p>If your game calls an RPC or replicated function very often, such as on Tick, you should make it Unreliable.</p>
</li>
<li><p>Some functions can be recycled by calling them in response to gameplay logic, then calling them in response to a RepNotify to ensure that clients and servers have parallel execution.</p>
</li>
<li><p>You can check an Actor’s network role to see if it is ROLE_Authority or not. This is a useful method for filtering execution in functions that activate on both server and client.</p>
</li>
<li><p>You can check if a Pawn is locally controlled by using the IsLocallyControlled function in C++ or the Is Locally Controlled function in Blueprint. This is useful for filtering execution based on whether it is relevant to the owning client.</p>
</li>
<li><p>Avoid using IsLocallyControlled in constructor scripts, as it is possible for a Pawn not to have a Controller assigned during construction.</p>
</li>
</ul>
<p>上面的英文内容是我直接复制粘贴过来的，有些是知识比较繁杂现在整理太费时间，就先做个标题，算是占位符了。</p>
<h2 id="Network处理流程"><a href="#Network处理流程" class="headerlink" title="Network处理流程"></a>Network处理流程</h2><p>为了深入理解UE4的Network处理，其实我觉得直接看源码会更深入，但是，还是作为最后的后手吧…</p>
<p><a href="https://www.slideshare.net/EpicGamesJapan/ue4howtocreatemultiplayergame" target="_blank" rel="noopener">UE4でマルチプレイヤーゲームを作ろう</a></p>
<p>是由上面的Slide开始进行的理解：</p>
<p>首先看一下Network的<strong>Tick</strong>的处理都做了哪些工作。摘抄自上面的Slide</p>
<ol>
<li>UWorld::Tick<ol>
<li><strong>UNetworkDriver</strong> ::TickDispatch<ol>
<li>Packet受信 &gt; <strong>Bunch</strong> 分解<ol>
<li><strong>Bunch</strong>を<strong>ActorChannel</strong>に流して、プロパティを<strong>レプリケート＋RPCの実行</strong></li>
<li>PostReceivedBunch &gt; <strong>RepNotify</strong> 処理</li>
</ol>
</li>
</ol>
</li>
<li>タスクグラフのループ<ol>
<li>RPCの呼び出し(ServerMoveなど)</li>
</ol>
</li>
<li><strong>UNetworkDriver</strong> ::TickFlush<ol>
<li><strong>BuildConsiderList</strong> 考慮するべき<strong>NetActor</strong> のリストを作る</li>
<li><strong>Connection</strong> 毎のループ<ol>
<li><strong>PrioritizeActors</strong> </li>
<li>ProcessePrioritizedActors<ol>
<li><strong>ActorChannel</strong> 毎にプロパティの差分を抽出して<strong>Bunch</strong>を書き出す</li>
</ol>
</li>
</ol>
</li>
<li><strong>Connection</strong> 毎のループ - <strong>UNetConnection</strong> ::Tick<ol>
<li><strong>UNetConnection</strong>::FlushNet()</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>甚至还夹杂着日语，请多担待。</p>
<p>还有官网中的描述<a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationFlow/index.html" target="_blank" rel="noopener">Detailed Actor Replication Flow - A detailed description of low-level Actor replication</a></p>
<blockquote>
<p>The bulk of actor replication happens inside UNetDriver::ServerReplicateActors. This is where the server will gather all of the actors that it has determined to be relevant for each client, and send any properties that have changed since the last time each connected client was updated.</p>
</blockquote>
<p><strong>UNetDriver::ServerReplicateActors</strong>看样子是非常重要的部分，Actor的Replication发生在这里，很多Actor的相关操作都在这里。</p>
<p>非常重要的一些Flow：</p>
<ul>
<li><code>AActor::NetUpdateFrequency</code> - Used to determine how often an actor replicates<ul>
<li>决定了Actor的Replication频度</li>
</ul>
</li>
<li><code>AActor::PreReplication</code> - Called before any replication occurs<ul>
<li>Replication发生之前被调用</li>
</ul>
</li>
<li><code>AActor::bOnlyRelevantToOwner</code> - True if this actor replicates to owner<ul>
<li>只对Owner进行Replicate，具体情况不太清楚</li>
</ul>
</li>
<li><code>AActor::IsRelevancyOwnerFor</code> - Called to determain relevancy when bOnlyRelevantToOwner is true</li>
<li><code>AActor::ISNetRelevantFor</code> - Called to determine relevancy when bOnlyRelevantToOwner is false</li>
</ul>
<p>关于Actor的<strong>Relevancy</strong> ，翻译是说关联性，是Actor的Replication的很重要的概念。但是目前对于这个属性的理解并不是很透彻。</p>
<p>高度抽象一下的流程就像下面这样，(参考上面的官网链接，我只是试着翻译一下)</p>
<ul>
<li>遍历所有的Actor检查<strong>replicating</strong> 活动性(<code>AActor::SetReplicates(true)</code>)<ul>
<li>确认Actor初期是否处于睡眠状态(DORM_Initial)，如果是，则跳过</li>
<li>确认actor是否需要更新，通过检查<code>NetUpdateFrequency</code>的值，如果不需要更新，则跳过</li>
<li>如果<code>AActor::bOnlyRelevantToOwner</code>为true，通过调用<code>AActor::IsRelevancyOwnerFor</code>来检查这个Actor在<strong>owning connection</strong>上的相关联性(relevancy)。如果relevancy为true，则添加到这个<strong>connection</strong> 的<strong>relevant list</strong> 中。<ul>
<li>在这个case中，这个Actor会仅仅发送一个<strong>single connection</strong> (这里不是很清楚)</li>
</ul>
</li>
<li>对于所有这些进行过初始检查(initial check↑上面的检查)的Actor，都会调用<code>AActor::PreReplication</code>函数。<ul>
<li>PreReplication是一个你可以决定是否为<strong>connection</strong>进行<strong>properties replicate</strong> 的地方。使用<code>DOREPLIFETIME_ACTIVE_OVERRIDE</code></li>
</ul>
</li>
<li>上面的操作都经历了之后，将其添加到<strong>considered list</strong></li>
</ul>
</li>
<li>对于每一个<strong>connection</strong> <ul>
<li>对上面的每一个<strong>considered actor</strong> <ul>
<li>判断是否睡眠(dormant)</li>
<li>如果还没有<strong>channel</strong><ul>
<li>判断client的actor所在的level是否已经加载<ul>
<li>没有加载，则跳过</li>
</ul>
</li>
<li>判断actor的相关性，通过调用<code>AActor::IsNetRelevantFor</code>(检查connection与actor的relevancy)<ul>
<li>如果不相关，则跳过</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>将上面的actor添加到其<strong>connection</strong> 拥有的<strong>relevant list</strong> 中</li>
<li>此时我们就拥有了一个与这个<strong>connection</strong>相关联的actor的列表(a list of actors are relevant for this connection)</li>
<li>通过优先级(<strong>priority</strong>)对actor进行排序(Sort)</li>
<li>对每一个已排序的Actor：<ul>
<li>如果<strong>connection</strong>还没有加载这个Actor所在的<strong>level</strong>，则关闭这个<strong>channel(if any)</strong>, 然后continue</li>
<li>每隔一秒，判断actor(与connection)的相关性(relevancy)，通过<code>AActor::IsNetRelevantFor</code>函数</li>
<li>如果持续5秒不相关(not relevant),则关闭<strong>channel</strong></li>
<li>如果相关但是没有channel开启，则开启一个</li>
<li>如果这个<strong>connection</strong>已经饱和(If at any point this connection is saturated)<ul>
<li>对于剩下的actors<ul>
<li>如果相关的时间小于1秒，下一个Tick阶段强制更新</li>
<li>如果相关的时间大于1秒，调用<code>AActor::IsNetRelevantFor</code>来判断下一个Tick是否更新</li>
</ul>
</li>
</ul>
</li>
<li>对于任何通过上述操作的Actor，都会经由其connection对Actor进行replicate，通过调用<code>UChannel::ReplicateActor</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Replicating-an-Actor-to-a-Connection"><a href="#Replicating-an-Actor-to-a-Connection" class="headerlink" title="Replicating an Actor to a Connection"></a>Replicating an Actor to a Connection</h3><p>关于如何将Actor的Replication复制到connection上</p>
<p><code>UChannel::ReplicateActor</code>是主要用来Replicate一个Actor和它所有的Component的内容到一个connection中，流程大致说明：</p>
<ul>
<li>判断自这个<strong>actor channel</strong>被打开后是否是第一次更新<ul>
<li>如果是，则序列化其需要的信息(initial location, rotation.etc)</li>
</ul>
</li>
<li>判断这个connection是否拥有这个actor(owning connection)<ul>
<li>如果不属于，并且这个actor的<strong>role</strong>是<code>ROLE_AutonomousProxy</code>,将其降格为<code>ROLE_SimulatedProxy</code></li>
</ul>
</li>
<li>Replicate这个actor有变动的属性(changed properties)</li>
<li>Replicate这个Actor每一个component有变动的属性(component’s changed properties)</li>
<li>对于任何被删除掉的components，发送特殊的删除命令</li>
</ul>
<p>算是大致翻译了一下这篇文章，有些明白了，但是有些还是不太清楚。</p>
<h3 id="NetDormancy-休眠"><a href="#NetDormancy-休眠" class="headerlink" title="NetDormancy 休眠"></a>NetDormancy 休眠</h3><p>可以通过Server的<code>AActor::SetNetDormancy</code>之类的函数来设置Actor的休眠状态，减少Actor的Replication的检查，达到减轻负荷的目的，是优化的一种手段。</p>
<p>进入休眠状态的Actor可以使用<code>FlushNetDormancy()</code>函数来唤醒。这个函数也会在Actor的Properties有更新的时候自动被UE4调用，也就是说<strong>休眠状态的控制某种程度上是自动的</strong>。</p>
<p>对于一段时间没有变化的Actor使其进入睡眠状态是可以某种程度上减少Replication的处理时间，但是如果频繁的进行睡眠状态的切换也只是增加处理时间。</p>
<p>关于休眠状态的设定：<br>在Actor的Replication一栏可以设置<strong>Net Dormancy</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DORM_Never</td>
<td>DORM_Awake一样</td>
</tr>
<tr>
<td>DORM_Awake(Default)</td>
<td>如果是休眠状态的话将其唤醒，并保持唤醒状态</td>
</tr>
<tr>
<td>DORM_DormantAll</td>
<td>进行向休眠状态迁移的检查，如果条件满足则迁移到睡眠状态</td>
</tr>
<tr>
<td>DORM_DormantPartila</td>
<td>可以根据每个Connection进行自定义切换，需要对AActor::GetNetDormancy进行实现</td>
</tr>
<tr>
<td>DORM_Initial</td>
<td>初期就会被从NetActorList中除外，进入休眠，当其FlushNetDormancy被调用则变成DORM_DormantAll</td>
</tr>
</tbody>
</table>
<p>对大多数情况下进行总结就是：</p>
<p><strong>几乎不变的Actor设置为DromantAll，Level中的背景Actor推荐设置为Initial</strong></p>
<h3 id="NetRelevancy-关联性"><a href="#NetRelevancy-关联性" class="headerlink" title="NetRelevancy 关联性"></a>NetRelevancy 关联性</h3><p>在上面也有提到<strong>Relevancy</strong>这个词，在Server上每一个connection也会依据<strong>距离之类</strong>的关联性参数来判断Actor的Replication行为。</p>
<p>生成NetActorList -&gt; 优先级排序 -&gt; <strong>关联性检查</strong> -&gt; 取得修改并发送</p>
<h4 id="NetCullDistanceSquared"><a href="#NetCullDistanceSquared" class="headerlink" title="NetCullDistanceSquared"></a>NetCullDistanceSquared</h4><p><code>AActor::IsNetRelevantFor()</code>进行基于距离的剔除。</p>
<h4 id="AlwaysRelevant"><a href="#AlwaysRelevant" class="headerlink" title="AlwaysRelevant"></a>AlwaysRelevant</h4><p>把上面的无效化的Flag。</p>
<h3 id="NetPriority-通信优先级"><a href="#NetPriority-通信优先级" class="headerlink" title="NetPriority 通信优先级"></a>NetPriority 通信优先级</h3><p>Actor中的决定Replicate优先顺序的参数，优先级越高越容易排在复制通信的前面，相对频繁的获得复制的机会。</p>
<p>使用一些特殊的函数(ForceNetUpdate，override AActor::GetNetPriority()函数)可以实现改变优先级的操作。</p>
<h3 id="NetUpdateFrequency"><a href="#NetUpdateFrequency" class="headerlink" title="NetUpdateFrequency"></a>NetUpdateFrequency</h3><p>Actor的状态复制频率，单位是 <code>N次/s</code> 。</p>
<p>被执行了Replicate的Actor会在<code>1/N</code>的时间里从NetActorList中剔除。</p>
<p>可以适当的调整这个参数，把不需要经常更新的或者没必要迅速做出反应的Actor的更新频度降低，减少CPU和带宽的消耗。</p>
<p>AActor:ForceNetUpdate可以重置<code>1/N</code>的间隔时间，也就是立即再次执行呗。</p>
<h4 id="MinNetUpdateFrequency"><a href="#MinNetUpdateFrequency" class="headerlink" title="MinNetUpdateFrequency"></a>MinNetUpdateFrequency</h4><p>只有在AdaptiveNetUpdateFrequency有效的时候才会起作用的参数，默认是OFF状态。</p>
<p>也就是UE4的Replication的一种自动调节功能，根据复制的评价值来让复制的操作在Min~NetUpdateFrequency之间自动调节。</p>
<h3 id="NetLoadOnClient"><a href="#NetLoadOnClient" class="headerlink" title="NetLoadOnClient"></a>NetLoadOnClient</h3><p>这个标志位在之前就有讲过，本来以为是个不起眼的功能，没想到是为GameMode准备的。</p>
<style>
table th:first-of-type {
    width: 15%;
}
table th:nth-of-type(2) {
    width: 20%;
}
table th:nth-of-type(3) {
    width:15%;
}
table th:nth-of-type(4) {
    width:50%;
}
</style>


<table>
<thead>
<tr>
<th></th>
<th>NetLoadOnClient</th>
<th>bReplicates</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>AGameMode</td>
<td>false</td>
<td>false</td>
<td>Client上不生成</td>
</tr>
<tr>
<td>ANavigationData</td>
<td>false</td>
<td>false</td>
<td>Client上不生成</td>
</tr>
<tr>
<td>APlayerState</td>
<td>false</td>
<td>true</td>
<td>Level初始化的时候被从Client上删除然后再经由Server的Replication复制</td>
</tr>
<tr>
<td>AGameState</td>
<td>false</td>
<td>true</td>
<td>同上</td>
</tr>
</tbody>
</table>
<h3 id="NetworkDriver"><a href="#NetworkDriver" class="headerlink" title="NetworkDriver"></a>NetworkDriver</h3><p>NetworkDriver是网络处理的源头，链接多人游戏世界(World)的主要部分。</p>
<p>Server和Client都持有NetworkDriver。</p>
<h4 id="NetConnection"><a href="#NetConnection" class="headerlink" title="NetConnection"></a>NetConnection</h4><p>NetConnection是不同World之间NetworkDriver的链接通道，Client生成一个，Server会根据连接的Player数量生成。</p>
<p><img src="NetConnection.PNG" alt="NetConnection"></p>
<h4 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h4><p>之前还是之后，这篇文章哪个地方有提到，PlayerController就是为了Connection而生的类，应该就是说的这个功能了。</p>
<p>APlayerController会在登录到Server的时候生成，与NetworkConnection是一对一的关系。</p>
<p>ServerRPC，ClientRPC能够向特定对象传送消息的前提是该Player属性持有有效的NetworkConnection。<br>(APawn::GetNetConnection &amp; APlayerController::GetNetConnection)</p>
<h4 id="NetworkObjectList"><a href="#NetworkObjectList" class="headerlink" title="NetworkObjectList"></a>NetworkObjectList</h4><p>NetworkDriver中的存储需要进行网络通信的ActorList，类型是NetworkObjectInfo</p>
<p>跟NetUpdateFrequency的计算有关，但是我还不是很清楚。</p>
<p>貌似并不是每一个connection都会持有这样的列表。</p>
<h4 id="ActorChannel-and-ChannelIndex"><a href="#ActorChannel-and-ChannelIndex" class="headerlink" title="ActorChannel and ChannelIndex"></a>ActorChannel and ChannelIndex</h4><p>ActorChannel是复制对象Actor一对一分配的通信管道，而ChannelIndex是静态的已经被确保的通信管道的序列索引。</p>
<p>和通信的另一端的Actor，就是通过这个索引建立起来联系。</p>
<h4 id="FNetworkGUID"><a href="#FNetworkGUID" class="headerlink" title="FNetworkGUID"></a>FNetworkGUID</h4><p>32位整数ID。用来建立进程间Object的联系。</p>
<p>Level中的静态物体被分配为奇数，动态物体为偶数。</p>
<blockquote>
<p>サーバー側で初めてプロパティとして扱う必要が出た時Objectに対して割り当てられます。</p>
</blockquote>
<p>不止局限于复制对象的Actor，通信过程中的包含的所有Object都是其对象。（比如说玩家所站立的地板）</p>
<p>使用<code>net.ListNetGUIDs</code>可以确认Actor的登录情况。</p>
<p>使用Blueprint确认</p>
<p><img src="FNetworkGUID.PNG" alt="BP_FNetworkGUID"></p>
<p>传送的对象的World不存在的Actor的情况下是NULL</p>
<h4 id="Bunch"><a href="#Bunch" class="headerlink" title="Bunch"></a>Bunch</h4><p>UE4的Replication状态复制处理的数据的输出单位。基本上就是</p>
<p>1ReplicationActor = 1Bunch</p>
<p>各个Bunch被送到上面提到的ChannelIndex那里，送到连接的另一端对应的Actor</p>
<p>UNetConnection::ReceivedPacket 查看具体内容</p>
<p>Network送信的包（Packet）中含有复数个Bunch</p>
<h4 id="收信应答-ACK-NAK"><a href="#收信应答-ACK-NAK" class="headerlink" title="收信应答 ACK/NAK"></a>收信应答 ACK/NAK</h4><p>ACK - ACKnowledgement<br>NAK - Negative-Acknowledge</p>
<p>是网络处理中的一般用语，并不是UE4专门术语。</p>
<p>用来表示有没有接收到包（Packet）</p>
<p>以bit数据的形式保存在包的Header部分，确认重要的包的送收信或者Reliable通信的确认等时候有用。</p>
<h4 id="Variable-Replicate-amp-RPCs"><a href="#Variable-Replicate-amp-RPCs" class="headerlink" title="Variable Replicate &amp; RPCs"></a>Variable Replicate &amp; RPCs</h4><p>变量的复制</p>
<p>不要过多的依赖PRCs，能用Property的Replication就尽量使用这个。</p>
<p>こういうものはRPC向け</p>
<ul>
<li>RPCは「イベント」です<ul>
<li>10秒後に無くてもいいもの</li>
</ul>
</li>
<li>回数が重要なもの<ul>
<li>音声</li>
<li>VFX生成</li>
</ul>
</li>
</ul>
<p>ReliableRPC<br>RPCs函数被调用之后，会被立即放入包(Packet)的Buffer中。其他需要传送的数据就会被占用了空间而变少。</p>
<p>非ReliableRPC会丢失，ReliableRPC则一定会送达。对方如果回答了<strong>Nak</strong>就会重新发送包数据。</p>
<p>即使是Reliable，由于距离等的元素导致ActorChannel没有开启的情况下，RPC不会送信。</p>
<p><img src="ReliableRPCs1.png" alt="ReliableRPC-1"><br><img src="ReliableRPC2.png" alt="ReliableRPC-2"></p>
<p>変数の複製 PropertyReplication<br>「変数の複製」は裏切らない</p>
<p>こういうものは変数の複製向け</p>
<ul>
<li>アクターの状態を表す変数 <ul>
<li>途中参加したときに復元しないと困るプロパティ </li>
</ul>
</li>
<li>10秒後に失われては困るもの <ul>
<li>ライフ </li>
<li>所持アイテム<br>-キャラクターの見た目</li>
</ul>
</li>
</ul>
<p>关于变量的赋值一定要慎重，Authority检查很有必要。</p>
<p>总结：</p>
<ul>
<li>Stat net命令执行时表示的参数都在Driver中控制的</li>
<li>NetworkDriver把Level串联起来实现了多人游戏的网络控制</li>
</ul>
<h3 id="CharacterMovement"><a href="#CharacterMovement" class="headerlink" title="CharacterMovement"></a>CharacterMovement</h3><p>关于CharacterMovement的问题在上面的那个Slide有涉及到，我准备花点时间另起一篇文章理解一下。</p>
<p><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/CharacterMovementComponent/index.html" target="_blank" rel="noopener">Character Movement ComponentDetailed explanation of Character Movement Component</a></p>
<h3 id="Replication-Graph"><a href="#Replication-Graph" class="headerlink" title="Replication Graph"></a>Replication Graph</h3><p>这是UE4为超多人游戏而准备的一个Plugin，具体使用方法不清楚，上面的Slide也有介绍。</p>
<p><a href="https://docs.unrealengine.com/en-US/Engine/Networking/ReplicationGraph/index.html" target="_blank" rel="noopener">Replication Graph - Overview of the Replication Graph feature and Replication Graph Nodes.</a></p>
<h1 id="重要的基础概念"><a href="#重要的基础概念" class="headerlink" title="重要的基础概念"></a>重要的基础概念</h1><p>关于理解UE4的多人框架的一些基础概念，由于不知道应该放在哪个部分好，就先放到这个里面，以后有更好的位置就再移动。</p>
<h2 id="Owning-Connection"><a href="#Owning-Connection" class="headerlink" title="Owning Connection"></a>Owning Connection</h2><ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/OwningConnections/index.html" target="_blank" rel="noopener">Actor and their Oening Connection</a></li>
</ul>
<p>上面链接来自于官网。可能会经常听到说Actor的<em>owning Connection</em>(我反正之前没怎么听说过），我也不知道该怎么翻译，<strong>所属连接</strong>?反正叫OwningConnection就对了，每一个connection都有一个PlayerController，或者说PlayerController的创建正是为了这个connection的。想知道一个Actor是否属于这个connection，那么就查询这个Actor的outer owner是否是PlayerController，而且这个PlayerController和这个connection所拥有的PlayerController是同一个，如果是同一个PlayerController那么这个Actor就属于这个connection。</p>
<p>Component在决定它的owning connection的时候有些特殊。它会向上遍历它的上级直到找到所属的Actor，然后像上面那样找到这个Actor的owning connection。这里原话是这样的我也不太确定自己理解的是否正确。</p>
<blockquote>
<p>Components are a little special in how they determine their owning connection. In this case, we first determine the components owner by walking the components outer chain until we find the owning actor, and then we continue as above by determining owning connection of this actor.</p>
</blockquote>
<p>理解OwningConnection对于一些功能非常重要：<br>RPCs需要知道并决定哪一个Client去执行run-on-clinet的命令，影响RPC Actor Repliation和connection relevancy * Actor property replication conditions等设定。</p>
<p>这对RPC非常重要，因为当你尝试对一个Actor调用一个RPC函数的时候，除非这个函数的多播(multicast)，它需要知道是哪个一个client去执行这一条RPC指令，它会通过找到自己的owningconention来借由这个connection来发送这条RPC指令。</p>
<p>ConnectionOwnership被用于Actor的Replication期间，决定了每个Actor所属的connection被更新。对于Actor来说，只有当<code>bOnlyRelevantToOwner</code>被设置为true的时候，connection才会为其所拥有的Actor接受属性更新( receive property update)。默认情况下，所有的PlayerController都设置了这个属性(bOnlyRelevantToOwner)，这就是为什么Client仅为他持有的PlayerController接收更新情报。这样做有很多原因，最主要的原因则是为了防止作弊和提高效率。</p>
<p>ConnectionOwnership对于property replication involving conditions也很重要，但是我现在还不是很理解这句话。</p>
<blockquote>
<p>Connection ownership is important during property replication involving conditions that use the owner. For example. When COND_OnlyOwner is used, only the owners of that actor will receive these property updates.</p>
</blockquote>
<p>关于上面的property replication involving conditions,官方文档的说明;</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/Properties/Conditions/index.html" target="_blank" rel="noopener">Conditional Property Replication</a></li>
</ul>
<p>貌似是对Actor的属性(Properties)进行进一步的细节设置Replication。</p>
<p>最后，ConnectionOwnership对autonomous proxies的Actor(Role is ROLE_AutonomousProxy)很重要。对于这些Actor来说，如果它们的属性被Replicate到一个并不拥有这Actor的connect上的时候(这个connect并不拥有这些Actors)，它们就会被降格到ROLE_SimulatedProxy。</p>
<p>在进行详细说明之前，我想对已经大概理解的内容进行巩固和深入理解。</p>
<h2 id="PlayerController-1"><a href="#PlayerController-1" class="headerlink" title="PlayerController"></a>PlayerController</h2><p>这个部分是以PlayerController开头却是想引出UE4的GameplayFramework的内容的。刚开始的时候总是会遇见一些名词，GameMode，GameState什么的，之前完全不是很理解这些内容。</p>
<p>在学习GameplayAbility的过程中又遇到了PlayerState这个东西，就觉得把这些很基础的内容串起来是很有必要的了。当然这些事情都有些好人帮我做了…</p>
<p>我就直接贴上链接了</p>
<ul>
<li><a href="http://www.main-function.com/entry/2017/11/22/220527" target="_blank" rel="noopener">【UE4】GameMode、GameState、PlayerState、PlayerControllerの関連を確認してみる</a></li>
</ul>
<p>关于官网上对于GameplayFramework的介绍：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Framework/QuickReference/index.html" target="_blank" rel="noopener">Gameplay Framework Quick Reference</a></li>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/index.html" target="_blank" rel="noopener">Game Mode and Game State</a></li>
</ul>
<p>我先把别人的劳动成果窃取过来，实在对不住。</p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><ul>
<li>这个只存在于服务器(Server)上。</li>
</ul>
<h3 id="GameState"><a href="#GameState" class="headerlink" title="GameState"></a>GameState</h3><ul>
<li>每个Machine都存在实例</li>
<li>拥有一个PlayerArray变量，是用来保存PlayerState的</li>
<li>没有Owner(GetOwner() == nullptr)</li>
</ul>
<h3 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h3><ul>
<li>每台machine上，所有的Player都存在一个PlayerState</li>
<li>Owner就是PlayerController (GetOwner()会返回PlayerController)</li>
</ul>
<h3 id="PlayerController-2"><a href="#PlayerController-2" class="headerlink" title="PlayerController"></a>PlayerController</h3><ul>
<li>没有Owner (GetOwner() == nullptr)</li>
<li>持有玩家操作的Pawn (GetControlledPawn取得)</li>
<li>OnPossess(Overridable native function for when this controller possesses a pawn)</li>
</ul>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>实际操作生成的PlayerPawn。</p>
<ul>
<li>PossessedBy中指定PlayerController</li>
</ul>
<h3 id="SinglePlay的情况"><a href="#SinglePlay的情况" class="headerlink" title="SinglePlay的情况"></a>SinglePlay的情况</h3><p><img src="SinglePlay.png" alt="singleplay"></p>
<h3 id="MultiPlay的情况"><a href="#MultiPlay的情况" class="headerlink" title="MultiPlay的情况"></a>MultiPlay的情况</h3><p><img src="MultiPlay-Server.png" alt="multiplay-server"></p>
<p><img src="MultiPlay-Client1.png" alt="multiplay-client1"></p>
<p><img src="MultiPlay-Client2.png" alt="multiplay-client2"></p>
<p>后面还有一些检验正确性的部分，输出LOG什么的，我就省略了。</p>
<h2 id="Instigator"><a href="#Instigator" class="headerlink" title="Instigator"></a>Instigator</h2><p>原意为”煽动者，始作俑者”，具体的我暂时还不是很清楚，是在Blueprint中遇到的：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/Game/GetInstigator/index.html" target="_blank" rel="noopener">Get Instigator</a></li>
<li><a href="https://docs.unrealengine.com/en-US/BlueprintAPI/Game/GetInstigatorController/index.html" target="_blank" rel="noopener">Get Instigator Controller</a></li>
</ul>
<p>从官网的介绍貌似是可以取得负责造成Damage的Pawn对象。<a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/FActorSpawnParameters/Instigator/index.html" target="_blank" rel="noopener">Instigator</a></p>
<p>具体的使用情况不明…</p>
<h2 id="Replicated-and-ReplicatedUsing"><a href="#Replicated-and-ReplicatedUsing" class="headerlink" title="Replicated and ReplicatedUsing"></a>Replicated and ReplicatedUsing</h2><p>在这里讲讲这两个关键字，或者说<code>UPROPERTY()</code>的属性修饰符(Property Specifiers)</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html" target="_blank" rel="noopener">Proerty Specifiers - Keywords used when declaring UProperties to specify how the property behaves with various aspects of the Engine and Editor.</a></li>
</ul>
<p>在自己的Actor中想要Replicate自身的属性的时候，就需要自己手动操作的，这里我有一个地方不敢确定的是：</p>
<ol>
<li>自定义的变量类型需要手动登录该变量，内置类型的变量在设置了Replicated为true之后仍需要登录变量到Actor的Replicated中去吗？</li>
</ol>
<p>目前看来是要的。</p>
<p>因为Actor的Replication是很重要的一部分内容，关于如何使用在GAS的文章中可能会记载一些实际的使用方法，而概念说明在上面应该也有涉及到。这里主要是对这两个属性修饰符的用法和不同进行一些记录。</p>
<p>还有就是<code>OnRep_FUNCTION</code>跟RPCs之间又有什么区别，简单的先记录一下。</p>
<p>首先，让一个Actor中的Property能够完成Replicate需要以下三步：</p>
<ol>
<li><code>bReplicates = true</code>开启Actor的Replication</li>
<li><code>UPROPERTY(Replicated) float a</code> 添加属性修饰符</li>
<li>重写Actor的<code>virtual void GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) const override;</code>函数</li>
</ol>
<p><code>GetLifetimeReplicatedProps</code>在有自定义的属性想要进行状态复制(Replication)的话，则需要把该属性登录到NetworkReplication上。</p>
<blockquote>
<p>GetLifetimeReplicatedProps 官网</p>
<p>Returns the properties used for network replication, this needs to be overridden by all actor classes with native replicated properties</p>
</blockquote>
<p>当然重写也是有一些内容的:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AmyActor::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">    DOREPLIFETIME(AMyActor, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>DOREPLIFETIME</code>宏使用是必要的的。</p>
<p>这样就能实现简单的<strong>PropertyReplication</strong>了。</p>
<p>那么<strong>ReplicatedUsing</strong>又是做什么用的呢?</p>
<p>简单看一下实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">    UPROPERTY(ReplicatedUsing = OnRep_Change)</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line"></span><br><span class="line">    UFUNCTION()</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRep_Change</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">void</span> AMyActor::OnRep_Change()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// UE_LOG(Log, Temp, TEXT("a value changed!"));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>作用就是在变量Replicated之后可以添加一个Callback函数，可以做一些方便的事情。</p>
<p>在这里还有两个需要注意的事情:</p>
<ul>
<li><p>上述的<code>OnRep_Change</code>函数的参数问题</p>
<ul>
<li><p>事实上在其它的地方我还看到了类似下面的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其它内容不变，但是函数声明的时候有了参数</span></span><br><span class="line">UFUNCTION()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRep_Change</span><span class="params">(<span class="keyword">float</span> PreviousA)</span></span>;</span><br></pre></td></tr></table></figure>
<p>也就是多了一个参数，应该是变更前的值，但是只是我的猜测。<br>-函数前的 <code>UFUNCTION()</code>是必须的</p>
</li>
</ul>
</li>
<li>关于<code>DOREPLIFETIME</code>宏的问题<ul>
<li>需要<code>#include &quot;Net/UnrealNetwork.h&quot;</code> 头文件</li>
<li>还有<code>DOREPLIFETIME_CONDITION</code>之类的宏</li>
</ul>
</li>
</ul>
<p><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/Properties/Conditions/index.html" target="_blank" rel="noopener">Conditional Property Replication - Detailed information about how to conditionally replicate Actor properties.</a></p>
<p>关于属性的Replication条件控制上面的官方文档中有介绍，有时间要好好看。</p>
<p>其实我还想在这里讨论一下RPCs的实现的，对比一下这之间的不同</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/25318-onrep-vs-multicast" target="_blank" rel="noopener">OnRep vs multicast</a></li>
</ul>
<p>先偷个懒，之后整理。</p>
<h2 id="RPCs"><a href="#RPCs" class="headerlink" title="RPCs"></a>RPCs</h2><p>RPCs是一个很重要的部分，需要对其中的知识点进行理解和记录，先放一个占位符</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html" target="_blank" rel="noopener">RPCs</a></li>
</ul>
<h1 id="深入理解UE的Multiplayer-Online"><a href="#深入理解UE的Multiplayer-Online" class="headerlink" title="深入理解UE的Multiplayer Online"></a>深入理解UE的Multiplayer Online</h1><p>结合上面的内容，也随着项目越来越深入，逐渐想对UE4的多人游戏框架进行更深入的了解。</p>
<p>首先是很不错的文章链接</p>
<ul>
<li><a href="https://historia.co.jp/archives/6750/https://historia.co.jp/archives/6750/" target="_blank" rel="noopener">[UE4] Multiplayer Online Deep Dive で講演してきました</a></li>
</ul>
<h2 id="Traveling理解"><a href="#Traveling理解" class="headerlink" title="Traveling理解"></a>Traveling理解</h2><p>参照的上面的文章中的一个Slide，这里直接贴出Slide的链接：</p>
<ul>
<li><a href="https://www.slideshare.net/EpicGamesJapan/ue4-multiplayer-online-deep-dive-traveling-ue4dd?ref=https://historia.co.jp/" target="_blank" rel="noopener">UE4 MultiPlayer Online Deep Dive 基礎編2 -Traveling</a></li>
</ul>
<p>这一部分将对UE4中的Map的Traveling概念进行学习理解。有些在意的还有<strong>OnlineSubsystem</strong>和<strong>Session</strong>这两个部分，都是我目前还不了解的。</p>
<p>时间有限我就简单对这个章节的内容做一些记录。</p>
<p>普通的比如说单机模式在下，切换Map的情况的话只要简单的调用<code>OpenLevel</code>函数就可以实现了。但是多人情况下，简单的调用实现不了这个功能，那同时双方都调用这个函数肯定是可以的，但是这样耿直未免有些傻气。</p>
<p>UE4提供了<strong>Traveling</strong>功能，可以实现多人游戏模式下的地图(Map)切换的同步。</p>
<h3 id="以Listen-Server的形式打开Map"><a href="#以Listen-Server的形式打开Map" class="headerlink" title="以Listen Server的形式打开Map"></a>以Listen Server的形式打开Map</h3><p>首先我们多人模式需要Server端以<strong>Listen Server</strong>的的模式打开Map：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Start Server */</span></span><br><span class="line">UGameplayStatics::OpenLevel(GetWorld(), <span class="string">"LevelName"</span>, <span class="literal">true</span>, <span class="string">"listen"</span>);</span><br></pre></td></tr></table></figure></p>
<p>也算是重新打开一次map，只不过是带有<code>listen</code>命令</p>
<h4 id="Option-String"><a href="#Option-String" class="headerlink" title="Option String"></a>Option String</h4><p>关于这个命令，我稍作了解，自己的理解就是创建<code>UWorld</code>的时候会带有一些<code>Option</code>,这些<code>Option</code>就是命令，有固定格式的写法，也有方法读取。</p>
<p>这个<code>Option</code>中添加的字符串(也就是“listen“)会作为被加载的Level的<code>GameMode</code>的<code>OptionString</code>属性被保存。</p>
<p>至于读取方法我没有验证过，这里只贴上链接：</p>
<ul>
<li><a href="http://monsho.blog63.fc2.com/blog-entry-121.html" target="_blank" rel="noopener">[UE4] Levelを開く</a></li>
</ul>
<p>我自己又稍微看过一点源码，所以我了解到在打开map的时候<code>UWorld</code>会更新一个WorldContent还是什么的结构体，这个结构体是由GameInstance保存的貌似，然后还有一个LastURL的属性，记录上次打开map的命令，我用这个来判断是否是ListenServer模式了，不知道对不对。</p>
<p>上面我有空要准确的更新一下，找一找源码。</p>
<h4 id="以ListenServer打开Level的流程图"><a href="#以ListenServer打开Level的流程图" class="headerlink" title="以ListenServer打开Level的流程图"></a>以ListenServer打开Level的流程图</h4><p><img src="ServerWithlisten.PNG" alt="Server"></p>
<h3 id="ServerTravel"><a href="#ServerTravel" class="headerlink" title="ServerTravel"></a>ServerTravel</h3><p>然后Server端只要在想要进行map的的跳转是调用<code>ServerTravel</code>函数，与之相连的Client也会一起跳转。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Start ServerTravel */</span></span><br><span class="line">GetWorld()-&gt;ServerTravel(<span class="string">"LevelName"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="Server端开始Traveling的流程"><a href="#Server端开始Traveling的流程" class="headerlink" title="Server端开始Traveling的流程"></a>Server端开始Traveling的流程</h4><p><img src="server1.PNG" alt="Server"></p>
<p>Client的流程：<br><img src="client3.PNG" alt="Client"></p>
<p>也就是说，根据上面的图得到的结论就是，每一次<code>ServerTravel</code>被调用跳转到下一个Map的时候，Client端向Server端的Login处理都要再执行一次。</p>
<p><code>ServerTravel</code>这其实也就是UE4已经包装好的RPCs，而且在Server调用，Client接收到通知准备跳转之前还有一个Callback，我使用这个回调来实现Client端的加载界面表示。</p>
<p>关于这个函数回调和这个RPCs的详细内容之后补上。</p>
<h3 id="ClientTravel"><a href="#ClientTravel" class="headerlink" title="ClientTravel"></a>ClientTravel</h3><p>关于Client的Traveling内容目前我还不是非常的清楚，等到真正需要用到的时候再仔细验证整理吧。</p>
<p>应该是重连的部分会用到。</p>
<p><img src="ClientTraveling.PNG" alt="ClientTravel"></p>
<h4 id="Cllient的Traveling流程图"><a href="#Cllient的Traveling流程图" class="headerlink" title="Cllient的Traveling流程图"></a>Cllient的Traveling流程图</h4><p><img src="client1.PNG" alt="client"><br><img src="client2.PNG" alt="client"></p>
<h5 id="UPendingNetGame"><a href="#UPendingNetGame" class="headerlink" title="UPendingNetGame"></a>UPendingNetGame</h5><ul>
<li>Control Channel で Server に Hello メッセージして待っている間、 UPendingNetGame オブジェクトが Server からの返答待ち及び、 Server が Closed になっていないかどうかの監視を行う</li>
</ul>
<h5 id="Control-Channel"><a href="#Control-Channel" class="headerlink" title="Control Channel"></a>Control Channel</h5><ul>
<li>C/S 間の接続の制御に利用されるチャンネル</li>
<li>UConnection 生成時に一つ生成される</li>
</ul>
<p>这个Slide的后面还有<strong>Network Version</strong>, <strong>PreLogin</strong>之类的看似很重要的内容，因为暂时还没有急切的需要用到，就先占个位，到时候再遇到再理解整理吧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="Server-Client-Traveling.PNG" alt="总结内容"></p>
<h3 id="SeamlessTravel解决每次map跳转Client都要再Login的问题"><a href="#SeamlessTravel解决每次map跳转Client都要再Login的问题" class="headerlink" title="SeamlessTravel解决每次map跳转Client都要再Login的问题"></a>SeamlessTravel解决每次map跳转Client都要再Login的问题</h3><p>利用<strong>SeamlessTravel</strong>的特性，经由一个<strong>TransitionMap</strong>再跳转到目标Map，则可以保持Client的连接进行跳转，还可以保持一些对象一起跳转到下一个Map中。</p>
<p>使用方法等到真正用到的时候再整理吧。这里有许多需要注意的地方，参照原文。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-GameplayAbilitySystem学习</title>
    <url>/ue4-gameplay-ability-system/</url>
    <content><![CDATA[<p>这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中<strong>Action RPG</strong>这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。</p>
<a id="more"></a>
<p>这里涉及到一个相当大的概念，<strong>GamePlay</strong>，这个应该是UE4模式的游戏架构，理解的话需要花费很多精力，大量的名词我都闻所未闻，只能一点点的啃了。</p>
<h1 id="GamePlay-Guide"><a href="#GamePlay-Guide" class="headerlink" title="GamePlay Guide"></a>GamePlay Guide</h1><p>这是官网的标题，暂时我不会整理，先从别的部分一点点入手</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/index.html" target="_blank" rel="noopener">Gameplay Guide-Overviews and examples of gameplay functionality for programmers and visual scripters.</a></li>
</ul>
<p>UE4官网的文章都是有中文的，但是还是放着吧，机翻翻译的我不知所云。</p>
<h2 id="Gameplay-Ability-System"><a href="#Gameplay-Ability-System" class="headerlink" title="Gameplay Ability System"></a>Gameplay Ability System</h2><p>官网上对于GAS的介绍，也是这篇文章要搞明白的部分。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/GameplayAbilitySystem/index.html" target="_blank" rel="noopener">Gameplay Ability System-High-level view of the Gameplay Ability System</a></li>
</ul>
<h1 id="ActionRPG"><a href="#ActionRPG" class="headerlink" title="ActionRPG"></a>ActionRPG</h1><p>这里我要逐步理解GAS的组成，剖析这个项目的源码。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Resources/SampleGames/ARPG/index.html" target="_blank" rel="noopener">Action RPG Game - A sample game that shows how to use the Ability System plugin.</a></li>
</ul>
<h2 id="ActionRPG内容分析"><a href="#ActionRPG内容分析" class="headerlink" title="ActionRPG内容分析"></a>ActionRPG内容分析</h2><h2 id="ActionRPG练习"><a href="#ActionRPG练习" class="headerlink" title="ActionRPG练习"></a>ActionRPG练习</h2><p>这一部分的内容是针对ActionRPG源码的练习，同时也是在公司练手的时候的练习。旨在熟悉GAS的使用。</p>
<p>下一章节的<em>GameplayAbilities and you</em>中是对PlayerInput和Ability进行了绑定，而大多数情况我觉得用到的可能性很小。但是作为熟悉GAS的使用是足够了。下一步是对使用GameplayAbility作为事件的Trigger进行介绍。</p>
<h1 id="GameplayAbilities-and-you"><a href="#GameplayAbilities-and-you" class="headerlink" title="GameplayAbilities and you"></a>GameplayAbilities and you</h1><p>这是一篇本应在UnrealEngineforums上的文章，但是不知道为什么页面被关闭了，但是我找到了GitHub上有人转载了</p>
<ul>
<li><a href="https://github.com/michaeltchapman/MCGameplayAbilities/wiki/GameplayAbilities-and-You" target="_blank" rel="noopener">GameplayAbilities and you</a></li>
</ul>
<p>这是一篇相当晦涩难懂的文章，当然也包含了全是英文这个原因，但是也总好于上面的ActionRPG只有一个工程，其他的啥也没有的要好。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>关于GameplayAbility(一下简称GA)，在这篇文章或者官网中有介绍，或者上面的部分有提到这里不再赘述。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>所以让我直接开始正题，如何一步一步按照文章的步骤来初步理解GA的。</p>
<h3 id="Setting-up-the-Project"><a href="#Setting-up-the-Project" class="headerlink" title="Setting up the Project"></a>Setting up the Project</h3><p>第一步是建立我们的项目，首先我是使用的UE4.25版本，创建了一个完全空白的项目。这里文章中要求的是让我们导入<strong>C++ Third persion</strong>，就是那个第三人称的控制器。而在这里我遇见了一个挑战。</p>
<p>如何导入第三人称控制器。由于我创建的是初始的空白项目。</p>
<p>ContentBrows -&gt; Add New -&gt; Add Feature or Content Pack to the Project -&gt; C++ Feature -&gt; Third Person</p>
<p>就这样导入项目了，但是下一个问题又来了，导入项目的ThirdPerson编译错误。</p>
<p>绕了一大圈，最终发现是在项目源码的Build.cs中缺少了<strong>HeadMountedDisplay</strong>这个Module。至于为什么会缺少这个module的原因我猜测是</p>
<ul>
<li>BlankProject确实是没有这个Module的</li>
<li>在我禁用SteamVRPlugin的时候自动给我删除掉了</li>
</ul>
<p>当然我还是觉得第一种可能性是比较大的，而我也没想到这个第三人称的控制器需要用到VR相关的Module。最后的调整，编译无错的版本是这样的：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="创建第一个GamePlayAbility-blueprint"><a href="#创建第一个GamePlayAbility-blueprint" class="headerlink" title="创建第一个GamePlayAbility blueprint"></a>创建第一个GamePlayAbility blueprint</h4><p>这个就是创建一个GA蓝图，继承GameplayAbility蓝图类，这一步超级简单，然后打开创建的蓝图，会看到ActivateAbility的节点，在后面添加一个print节点，打印HelloWorld。</p>
<h3 id="Setting-up-our-Charactor"><a href="#Setting-up-our-Charactor" class="headerlink" title="Setting up our Charactor"></a>Setting up our Charactor</h3><p>哦对，在我们建立项目之后应该启用<strong>GameplayAbilityPlugin</strong>，以便于我们在项目中引用它。</p>
<p>在我们的Build.cs中添加GameplayAbility的Module，最终的感觉像这样：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span>, <span class="string">"GameplayAbilities"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>找到第三人称控制器的源码，我们将在源码中添加一些修饰。我自己的项目则是<strong>TP_ThirdPersonCharacter.h</strong>文件。</p>
<p>首先我们要为Charactor添加AbilitySystemComponent组件，在别的地方应该也有提到，这个组件是Actor必须的，非常关键的，对于GameplayAbilitySystem来说。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Camera boom positioning the camera behind the character */</span></span><br><span class="line">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">USpringArmComponent</span>* <span class="title">CameraBoom</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Follow camera */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UCameraComponent</span>* <span class="title">FollowCamera</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Our ability system */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Abilities, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UAbilitySystemComponent</span>* <span class="title">AbilitySystem</span>;</span></span><br></pre></td></tr></table></figure>
<p>因为我添加的代码跟文章中的差不多，所以直接复制粘贴了。</p>
<p>这之后，也是非常重要的，我们需要继承<code>IAbilitySystemInterface</code>接口并实现里面的方法。</p>
<blockquote>
<p>This interface here gives other actors an easy way to both know we have an ability system, and a way to get it without doing something dumb and inefficient like iterating through our components for an ability system.</p>
</blockquote>
<p>AbilitySystem貌似就是通过这个接口来确定Actor的AbilitySystem能否正常工作。实现的效果像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemInterface.h"</span> <span class="comment">//We add this include 别忘了添加头文件</span></span></span><br><span class="line">UCLASS(config=Game) <span class="class"><span class="keyword">class</span> <span class="title">AGameplayAbilitiesTutCharacter</span> :</span> <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface <span class="comment">//We add this parent.继承接口</span></span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span> override <span class="comment">//We add this function, overriding it from IAbilitySystemInterface. 接口的方法实现</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> AbilitySystem; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后我们需要对AbilitySystemComponnent进行创建，在头文件中只是声明了一下。实现的就像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TP_ThirdPersonCharacter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemComponent.h"</span></span></span><br><span class="line"><span class="comment">// 省略了与文章无关的头文件</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// ATP_ThirdPersonCharacter</span></span><br><span class="line"></span><br><span class="line">ATP_ThirdPersonCharacter::ATP_ThirdPersonCharacter()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 省略一些源码</span></span><br><span class="line">    <span class="comment">// Create a follow camera</span></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName); <span class="comment">// Attach the camera to the end of the boom and let the boom adjust to match the controller orientation</span></span><br><span class="line">    FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>; <span class="comment">// Camera does not rotate relative to arm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our ability system component 创建组件</span></span><br><span class="line">    AbilitySystem = CreateDefaultSubobject&lt;UAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystem"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character)</span></span><br><span class="line">    <span class="comment">// are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Once you have compiled, you can open your character blueprint(which inherits from your C++ character) and lo and behold, right under the character’s movement component you should see an AbilitySystemComponent.</p>
</blockquote>
<p>就像上面说的那样，当你编译之后就能在Map中的第三人称控制器的蓝图中找到我们创建的AbilitySystemComponent组件。</p>
<p>So far so good.</p>
<p>但是目前为止，我们还有很长的路。现在我们什么都没实现。</p>
<blockquote>
<p>That’s because the ability system doesn’t have any abilities to activate yet, nor does it have any inputs assigned to them, anyway, so trying to activate an ability you do not have is, obviously, a quite useless effort. We will work on fixing both things. You must do both things in C++.</p>
</blockquote>
<p>上面这句话有两个：</p>
<ul>
<li>需要一个ability去激活ability system</li>
<li>需要绑定输入(inputs)到它们身上</li>
</ul>
<h3 id="Binding-to-Character-input"><a href="#Binding-to-Character-input" class="headerlink" title="Binding to Character input"></a>Binding to Character input</h3><p>首先，我们需要将我们的AbilitySystem绑定到Character’s input。我们想把我们的abilitysystem绑定到UInputComponent上。</p>
<blockquote>
<p>We want to call AbilitySystem-&gt;BindAbilityActivationToInputComponent within the SetupPlayerInputComponent. It takes two parameters: The UInputComponent pointer at hand and a struct called FGameplayAbiliyInputBinds. This is not a typo! It is not called FGameplayAbilityInputBinds, but FGameplayAbiliyInputBinds!</p>
</blockquote>
<p>所以说FGameplayAbiliyInputBinds是什么？注意这里我还真拼错了一次。</p>
<blockquote>
<p>The constructor for FGameplayAbiliyInputBinds takes at least 3 parameters: The first two are strings, and represent the input names that will be used to define “Confirm” and “Cancel”-input commands. You do not necessarily need these depending on your game, but abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too, so generally it can’t hurt to have these even if you will never use them. The third parameter is the name of an arbitrary UEnum of all things. This is one of the witchcraft-ier aspects of the system: <strong>The ability system component will look into the enum whose name you’ve given and will map its ability slots to the names of the elements contained within the enum</strong>.</p>
</blockquote>
<p>顾名思义，应该就是负责存储对应Ability和键位映射的结构数据或者中间数据，FGameplayAbiliyInputBinds的构造函数至少有三个参数，前两个参数是字符串，代表着定义”Confirm”和”Cancel”两个输入命令(input commands)的输入名字。根据游戏的需要可能这并不是必须的。</p>
<p>这里我没怎么明白这前两个参数的具体意思，文章中说的<em>abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too</em>这里我也不是非常清楚，谁是谁，说的是谁我都不知道。</p>
<p>第三个参数是一个自定义的UENUM枚举，他说这里是这个GAS的神奇的地方，而我只觉得想骂人。</p>
<p>AbilitySystemComponent会取出自定义的枚举类型的名字，然后映射他的<strong>ability slots</strong>到这个枚举类型中所包含的名字上。下面是这个自定义枚举的举例实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Example for an enum the FGameplayAbiliyInputBinds may use to map input to ability slots.</span></span><br><span class="line"><span class="comment">//It's very important that this enum is UENUM, because the code will look for UENUM by the given name and crash if the UENUM can't be found. BlueprintType is there so we can use these in blueprints, too. Just in case. Can be neat to define ability packages.</span></span><br><span class="line">UENUM(BlueprintType) <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">AbilityInput</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    UseAbility1 UMETA(DisplayName = "Use Spell 1"), //This maps the first ability(input ID should be 0 in int) to the action mapping(which you define in the project settings) by the name of "UseAbility1". "Use Spell 1" is the blueprint name of the element.</span><br><span class="line">    UseAbility2 UMETA(DisplayName = "Use Spell 2"), //Maps ability 2(input ID 1) to action mapping UseAbility2. "Use Spell 2" is mostly used for when the enum is a blueprint variable.</span><br><span class="line">    UseAbility3 UMETA(DisplayName = "Use Spell 3"),</span><br><span class="line">    UseAbility4 UMETA(DisplayName = "Use Spell 4"),</span><br><span class="line">    WeaponAbility UMETA(DisplayName = "Use Weapon"), //This finally maps the fifth ability(here designated to be your weaponability, or auto-attack, or whatever) to action mapping "WeaponAbility".</span><br><span class="line"></span><br><span class="line">    <span class="comment">//You may also do something like define an enum element name that is not actually mapped to an input, for example if you have a passive ability that isn't supposed to have an input. This isn't usually necessary though as you usually grant abilities via input ID,</span></span><br><span class="line">    <span class="comment">//which can be negative while enums cannot. In fact, a constant called "INDEX_NONE" exists for the exact purpose of rendering an input as unavailable, and it's simply defined as -1.</span></span><br><span class="line">    <span class="comment">//Because abilities are granted by input ID, which is an int, you may use enum elements to describe the ID anyway however, because enums are fancily dressed up ints.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我直接复制粘贴了。将上面的Enum实现放到头文件，然后回到cpp文件中对键位进行绑定。</p>
<p>回到Cpp文件中的<code>SetupPlayerInputComponent</code>函数中,用户输入键位进行绑定。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AbilitySystem-&gt;BindAbilityActivationToInputComponent(PlayerInputComponent, FGameplayAbiliyInputBinds(<span class="string">"ConfirmInput"</span>, <span class="string">"CancelInput"</span>, <span class="string">"AbilityInput"</span>));</span><br></pre></td></tr></table></figure></p>
<p>所以到这一步为止，如果编译没有出错误的话，我们已经成功的将<strong>ability system’s sbility activation</strong>()绑定到了用户输入(player input)上。</p>
<h3 id="Giving-the-Character-an-Ability"><a href="#Giving-the-Character-an-Ability" class="headerlink" title="Giving the Character an Ability"></a>Giving the Character an Ability</h3><p>最后一步是给我们的AbilitySystem一个Ability，就如已经预备好的一样，我们要将这个Ability放到已经映射到PlayerInput的第一个ability slot上。</p>
<p>这里使用了蓝图的一个类似Unity的Inspector中拖拽搞定Reference的功能，我之前也有实现过，只不过拖拽是不支持的，可以在下拉菜单中选择自己定义好的蓝图而已，而这里则是选择我们一开始创建的那个GameplayAbility蓝图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Abilities)</span><br><span class="line">TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayAbility</span>&gt; <span class="title">Ability</span>;</span></span><br></pre></td></tr></table></figure>
<p>随后我们将在BeginPlay中调用AbilitySystem的GiveAbility函数，看名字就知道是干什么得了。但是需要注意的是我们必须，或者说只能在Server端执行Ability的赋予，这里应该是GAS的要求或者说实现，因为GAS是支持多人通信的系统，就文章所说如果在Client中赋予Ability的话，会崩溃，UE4和你都会崩溃（这是我加的）。</p>
<p>GiveAbility需要一个FGameplayAbilitySpec作为参数，FGameplayAbilitySpec是围绕着GameplayAbility的数据（类型），包含着level和input ID。</p>
<blockquote>
<p>GiveAbility requests an FGameplayAbilitySpec as parameters. An FGameplayAbilitySpec is the data surrounding a GameplayAbility, notably which level (the system has built-in support for a level variable, quite good for RPGs/MOBAs as mentioned) and which input ID it is.</p>
</blockquote>
<ul>
<li>level: 系统已经内置的关卡变量，对RPGs/MOBAs类的游戏非常友好。也就是关卡的标志，或许我以后会经常用到。</li>
<li>input ID: 这里终于跟上面连起来了，那个自定义的ENUM已经跟我们的AbilitySystem的AbilitySlots进行了绑定，这个Input ID则是可以对AbilitySlot进行指定（这是目前为止自己的理解）</li>
</ul>
<p>FGameplayAbilitySpec需要一个GameplayAbility对象作为参数，我们可以使用Ability的默认对象（class’s default object），就文章的作者而已：</p>
<blockquote>
<p>There is very little reason to use anything other than the default object of a GameplayAbility class as far as I’ve understood it from going through the source.</p>
</blockquote>
<p>关于默认对象的描述贴一段来自官网的内容：</p>
<blockquote>
<p><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html" target="_blank" rel="noopener">Objects</a></p>
<p>The UCLASS Macro</p>
<p>The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type. Each UCLASS maintains one Object called the ‘Class Default Object’, or CDO for short. The CDO is essentially a default ‘template’ Object, generated by the class constructor and unmodified thereafter. Both the UCLASS and the CDO can be retrieved for a given Object instance, though they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the GetClass() function.</p>
</blockquote>
<p>我们还要调用<strong>AbilitySystem-&gt;InitAbilityActorInfo</strong>函数，来告诉AbilitySystem谁是Owner谁是Avatar。</p>
<blockquote>
<p>Finally, while on the topic of BeginPlay, we should also call AbilitySystem-&gt;InitAbilityActorInfo. It tells the AbilitySystem what its Owner (the actor responsible for the AbilitySystem) and Avatar (the actor through which the AbilitySystem acts, uses Abilities from etc.) is. In our case our character is both.</p>
</blockquote>
<ul>
<li>Owner: AbilitySystem的持有Actor</li>
<li>Avatar:使用这个AbilitySystem的Ability的Actor？这里我不是太明白。</li>
</ul>
<p>BeginPlay中的实现效果：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> ATP_ThirdPersonCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">    Super::BeginPlay();</span><br><span class="line">    <span class="keyword">if</span> (AbilitySystem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HasAuthority() &amp;&amp; Ability) &#123;</span><br><span class="line">    AbilitySystem-&gt;GiveAbility(FGameplayAbilitySpec(Ability.GetDefaultObject(), <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    AbilitySystem-&gt;InitAbilityActorInfo(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有需要注意的是，我们必须要保证每当controller改变的时候，AbilitySystemComponent’s ActorInfo struct的内容被更新。这里贴上原作者的话:</p>
<blockquote>
<p>You also need to make sure that the AbilitySystemComponent’s ActorInfo struct is being updated each time the controller changes. On the surface much of the system will work without that, but in a multiplayer enviroment especially(where pawns may be spawned before the client controller possesses them) you will experience crashes and behaviour that can be difficult to debug should you not properly set the ActorInfo up.</p>
</blockquote>
<p>这里有我不太明白的地方，就下面的源码来看这个Controller指的是哪个Controller我都不知道，这里是知识盲区。实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController * NewController)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> AGameplayAbilitiesTutCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">   Super::PossessedBy(NewController);</span><br><span class="line">   AbilitySystem-&gt;RefreshAbilityActorInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里扫一下盲，关于PossessedBy函数的定义：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pawn.h</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when this Pawn is possessed. Only called on the server (or in standalone).</span></span><br><span class="line"><span class="comment">    * @param NewController The controller possessing this pawn</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>以上都编译好了之后，还有两步，一是把我们一开始创建好的GameplayAbility蓝图（输出HelloWorld）指定到我们预备好的AbilitySlot上。</p>
<p>在打开的Map中找到我们使用的第三人称控制器（ThirdPersonCharacter），在它的Details面板使用我们设置的Category-Abilities检索，便会找到我们准备好的AbilitySlot1，在这里我们指定我们制作的打印HelloWorld的GameplayAbility蓝图。</p>
<p>第二步是指定PlayerInput的映射，我们已经把Ability映射到了PlayerInput上了，但是没有指定哪一个Ability到哪一个键位，这个时候回想起那个我们制作的不知道干什么的UENUM枚举类型。</p>
<p>去Edit-&gt;Project Settings中找到Input，添加Action Mappings。</p>
<p>添加一个新的<strong>Action Mappings</strong>，名字指定为”UseAbility1”,这个名字跟你声明的Enum枚举类型里定义的变量名对应，注意是变量名字。然后指定键位，我这里指定的是Enter键。</p>
<p>好了以上就是我跟着做的过程的全部内容，运行游戏，然后按下Enter键，就会发现左上角打印出了HelloWorld！。</p>
<p>虽然只能触发一次。</p>
<p>这里文章还提到如果出现了问题，比如说UE4崩溃，或者AbilityActor is invalid之类的错误的话提供下面的解决方案：</p>
<blockquote>
<p>Note that if it crashes and spits out an error message talking about AbilityActorInfo being invalid, try adding this code just before the HasAuthority() check and seeing if it fixes the problem:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FGameplayAbilityActorInfo* ActorInfo = <span class="keyword">new</span> FGameplayAbilityActorInfo();</span><br><span class="line">ActorInfo-&gt;InitFromActor(<span class="keyword">this</span>, <span class="keyword">this</span>, AbilitySystem); AbilitySystem-&gt;AbilityActorInfo = TSharedPtr&lt;FGameplayAbilityActorInfo&gt;(actorInfo);</span><br></pre></td></tr></table></figure>
<p>然后我们枯燥的部分终于告一段落了。</p>
<h2 id="The-Essentials-要点"><a href="#The-Essentials-要点" class="headerlink" title="The Essentials (要点)"></a>The Essentials (要点)</h2><p>在解决了漫长的Setup设置之后，是对GAS的各种基础概念进行认知。但是这篇文章从现在开始的部分真的对我来说是晦涩难懂，每一句话太长了，让我陷入了不会英语的自责。。。</p>
<p>我只能一点点的理解。</p>
<p>这个章节是对GAS中的一些要点，关键概念进行总结和理解。</p>
<h3 id="GameplayAbilities"><a href="#GameplayAbilities" class="headerlink" title="GameplayAbilities"></a>GameplayAbilities</h3><h3 id="GameplayTasks"><a href="#GameplayTasks" class="headerlink" title="GameplayTasks"></a>GameplayTasks</h3><h3 id="GameplayEffects"><a href="#GameplayEffects" class="headerlink" title="GameplayEffects"></a>GameplayEffects</h3><h3 id="AttributeSet"><a href="#AttributeSet" class="headerlink" title="AttributeSet"></a>AttributeSet</h3><p>这里我先跨过前面的部分直接说AttributeSet。其实我是大概的看完了这个部分，然后又看了下面的文章才更新的这部分的内容的。</p>
<ul>
<li><a href="https://forums.unrealengine.com/community/community-content-tools-and-tutorials/116578-comprehensive-gameplayabilities-analysis-series" target="_blank" rel="noopener">Comprehensive GameplayAbilities Analysis Series</a></li>
</ul>
<p>这篇文章对AttributeSet的内容讲解的稍微深了些，或者说配合代码讲解，本应是很好理解的，但是我只理解了一半。有时间，或者再加深一些理解之后再来总结这篇文章吧。</p>
<h1 id="GASDocumentation"><a href="#GASDocumentation" class="headerlink" title="GASDocumentation"></a>GASDocumentation</h1><ul>
<li><a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a></li>
</ul>
<p>这是一个完整的关于GameplayAbilitySystem的框架的使用文章，这里面包含了很多的知识，也吃掉了我许多时间，实在是理解GAS的一个非常好非常重要的文章。</p>
<p>由于理解本身就已经非常费时费力，当然更多的是自己的摸鱼和工作不力，但还是希望能好好理解UE4这个框架</p>
<h2 id="GASDocumentation的个人翻译和理解"><a href="#GASDocumentation的个人翻译和理解" class="headerlink" title="GASDocumentation的个人翻译和理解"></a>GASDocumentation的个人翻译和理解</h2><p>在这里我准备把这个GitHub的文章的一些重要部分进行翻译和整理，当然不是全部，还有对其中的实现做一些记录。</p>
<h3 id="Intro-to-the-GameplayAbilitySystem-Plugin"><a href="#Intro-to-the-GameplayAbilitySystem-Plugin" class="headerlink" title="Intro to the GameplayAbilitySystem Plugin"></a>Intro to the GameplayAbilitySystem Plugin</h3><p>官网上的说明跳过不说，我自己的理解就是，GAS这个系统是为RPG和MOBA类游戏打造的框架，里面包含了升级啊角色技能冷却啊之类的要素的开箱即用的功能，即包装好的功能。由于在这个框架中实现了许多Multiplay的内容，相较于自己重新构建，学习使用这个框架的成本更低一些，嘛代价就是不能彻底理解UE4的多人游戏网络框架了。</p>
<p>但是有得必有失。由于GAS已经内置于UE4的源码中了，所以直接拿来用就好了。如果有不满的地方，那么之后再考虑如何对其进行扩展。</p>
<p>关于UE4中关于GAS提供的功能，在这篇文章中是这样形容的：</p>
<blockquote>
<p>The plugin provides an out-of-the-box solution in single and multiplayer games for:</p>
<ul>
<li>Implementing level-based character abilities or skills with optional costs and cooldowns (GameplayAbilities)</li>
<li>Manipulating numerical Attributes belonging to actors (Attributes)</li>
<li>Applying status effects to actors (GameplayEffects)</li>
<li>Applying GameplayTags to actors (GameplayTags)</li>
<li>Spawning visual or sound effects (GameplayCues)</li>
<li>Replication of everything mentioned above</li>
</ul>
</blockquote>
<p>在我整理这篇文章的时候已经对这篇文章和这个项目的源码进行了大致的理解和实现，所以对于不知所云的地方会加上一些标注。</p>
<p>GAS提供的一些开箱即用的功能有（包含单人和多人游戏）：</p>
<ul>
<li>基于等级的能力和技能的实现带有一些数值的消耗或者冷却时间，即GameplayAbility</li>
<li>操纵Actor的数值属性，即Attribute</li>
<li>应用一些“影响”到Actor当前的状态上，即GameplayEffect</li>
<li>将GameplayTags应用到Actor上，即一些GameplayTag的使用</li>
<li>生成一些特效或音效，即GameplayCue</li>
<li>上述提到的内容的状态复制，即Replication</li>
</ul>
<blockquote>
<p>In multiplayer games, GAS provides support for client-side prediction of:</p>
<ul>
<li>Ability activation</li>
<li>Playing animation montages</li>
<li>Changes to Attributes</li>
<li>Applying GameplayTags</li>
<li>Spawning GameplayCues</li>
<li>Movement via RootMotionSource functions connected to the CharacterMovementComponent.</li>
</ul>
</blockquote>
<p>关于GAS的一些高级特性，就是某种程度上提供了<strong>客户端本地预测</strong>。</p>
<ul>
<li>Ability的激活</li>
<li>Animation Montage的播放</li>
<li>Attribute的变动</li>
<li>应用GameplayTag</li>
<li>生成GameplayCue</li>
<li><span style="color: red; ">Movement via RootMotionSource functions connected to the CharacterMovementComponent.</span></li>
</ul>
<p>最后一个特性是我没有遇见过的也是没有验证过的，也不知道该怎么翻译</p>
<blockquote>
<p>Current issues with GAS:</p>
<ul>
<li>GameplayEffect latency reconciliation (can’t predict ability cooldowns resulting in players with higher latencies having lower rate of fire for low cooldown abilities compared to players with lower latencies).</li>
<li>Cannot predict the removal of GameplayEffects. We can however predict adding GameplayEffects with the inverse effects, effectively removing them. This is not always appropriate or feasible and still remains an issue.</li>
<li>Lack of boilerplate templates, multiplayer examples, and documentation. Hopefully this helps with that!</li>
</ul>
</blockquote>
<p>目前GAS上仍然需要解决的问题是以下几个问题：</p>
<ul>
<li>GameplayEffect latency reconciliation, 我也不知道该怎么翻译这个，按照描述时所说就是ability的colldown无法本地预测导致了拥有高延迟的本地玩家相较于低延迟的玩家拥有更低的开火率，这在GameplayEffect章节中会再提及。</li>
<li>不能预测GameplayEffect的移除。虽然可以预测性的添加具有相反效果的GE来完成看似删除的效果，但是这不是总是可行的，仍然是一个问题。</li>
<li>确实样例模板和文档。（跟GAS相关的文档就少到离谱，而且大多还是英文，而事实上这篇文章帮了我很多很多）</li>
</ul>
<p>但是最详尽的文档就是UE4的源码了…</p>
<h3 id="Setting-Up-a-Project-Using-GAS"><a href="#Setting-Up-a-Project-Using-GAS" class="headerlink" title="Setting Up a Project Using GAS"></a>Setting Up a Project Using GAS</h3><blockquote>
<ol>
<li>Enable GameplayAbilitySystem plugin in the Editor</li>
<li>Edit YourProjectName.Build.cs to add “GameplayAbilities”, “GameplayTags”, “GameplayTasks” to your PrivateDependencyModuleNames</li>
<li>Refresh/Regenerate your Visual Studio project files</li>
<li>Starting with 4.24, it is now mandatory to call UAbilitySystemGlobals::InitGlobalData() to use TargetData. The Sample Project does this in UEngineSubsystem::Initialize(). See InitGlobalData() for more information.</li>
</ol>
</blockquote>
<p>前几条就是常规操作了，但是最后一条，在使用了<strong>TargetData</strong>之后，不要忘记调用<code>UAbilitySystemGlobals::InitGlobalData()</code>，这个部分我还没有验证过。</p>
<h3 id="AbilitySystemComponent"><a href="#AbilitySystemComponent" class="headerlink" title="AbilitySystemComponent"></a>AbilitySystemComponent</h3><p><code>AbilitySystemComponent</code>简称ACS，是GAS的自内脏，嘛就是中心，控制着GAS中的所有的交互。如果想要让一个Actor拥有<strong>Attributes</strong>，或者能够使用<strong>GameplayAbilities</strong>，那么对于Actor来说都需要一个ACS。我们可以选择直接使用或者继承它自己定义新的Component。</p>
<p>ACS所依附(AttachTo)的Actor一般名义上就是这个ASC的<strong>OwnerActor</strong>。而ACS的实际上的物理使用者Actor则被称为<strong>AvatarActor</strong>。(这里文章所说的<em>PhysicalRepresentationActor</em>我不知道该如何翻译)一般情况下这两者都会是相同的Acotr(MOBA游戏中的简单的AI控制单位AI minion等等)。他们也有可能是不同的Actor，比如说MOBA游戏中玩家控制的Hero角色，OwnerActor是PlayerState，AvatarActor则是Hero的Character类来担任。</p>
<p>大多数情况下Actor都会自己持有ASC，除非是想要Respawn这个Actor而且想要持续的保持Actor中的属性状态，就像是MOBA游戏中的Hero的属性，这个时候我们第一个想到的就是将ASC放到PlayerState上。</p>
<blockquote>
<p>If your Actor will respawn and need persistence of Attributes or GameplayEffects between spawns (like a hero in a MOBA), then the ideal location for the ASC is on the PlayerState.</p>
</blockquote>
<p>需要注意的是：</p>
<ol>
<li>如果设置了ASC到PlayerState上了，要记着调整<code>NetUpdateFrequency</code>的值。默认的值很低，使用默认值的话，Client上可能会有很高的延迟感，相对于Attributes和GameplayTag的使用来说。<ul>
<li>记得开启<code>AdaptiveNetworkUpdateFrequency</code>选项。Fortnite使用了这个。</li>
</ul>
</li>
<li><p>想要使用ASC的时候一定要继承实现<code>IAbilitySystemInterface</code>,如果是上述的那种OwnerActor和AvatarActor不同的情况下（也就是PlayerState拥有真正的ASC实例，Character只是ASC的指针的时候）对于两个Actor来说，都需要继承该接口并对其进行实现。</p>
<ul>
<li><code>UAbilitySystemComponent* GetAbilitySystemComponent() const</code>进行实现</li>
<li>ASCs interact with each other internally to the system by looking for this interface function.ASC之间的交互貌似会用到这个接口，其他情况下不太清楚。</li>
</ul>
</li>
<li><p>ASC中有一个变量<code>FActiveGameplayEffectsContainer ActiveGameplayEffects</code>用来保存目前active状态的GameplayEffects</p>
</li>
<li>ASC中有一个变量<code>GameplayAbilitySpecContainer ActivatableAbilities</code>用来保存所有生成的GameplayAbilities。<ul>
<li>这里的<em>granted Gameplay Abilities</em>的翻译可能不是很准确。</li>
<li>如果需要遍历<code>ActivatableAbilities.Items这个List的时候，一定要在之前加上</code>ABILITYLIST_SCOPE_LOCK();`来防止在循环的时候内容被修改(removing a ability是被修改的原因)。</li>
<li>在scope中的时候<code>AbilityScopeLockCount</code>会加算，scope运行结束之后会减去。</li>
<li>不要尝试在<code>ABILITYLIST_SCOPE_LOCK();</code>中移除ability(the clear ability functions check AbilityScopeLockCount internally to prevent removing abilities if the list is locked)</li>
</ul>
</li>
</ol>
<h4 id="Replication-Mode"><a href="#Replication-Mode" class="headerlink" title="Replication Mode"></a>Replication Mode</h4><p>ASC为<code>GameplayEffects</code>,<code>GameplayTags</code>,<code>GameplayCues</code>提供了三种不同的复制模式(Replication Mode)，<code>Full</code>,<code>Mixed</code>,<code>Minimal</code>。<br><code>Attributes</code>的Replication是由<code>AttributeSet</code>负责的。</p>
<table>
<thead>
<tr>
<th>Replication Mode</th>
<th>When to Use</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Full</code></td>
<td>SinglePlayer</td>
<td>每一个<code>GameplayEffect</code>都会被复制(replicated)到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Mixed</code></td>
<td>Multiplayer,<br> player controlled Actors</td>
<td><code>GameplayEffect</code>只会被复制到自己的<strong>OwningClient</strong>上。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Minimal</code></td>
<td>Multiplayer,<br>AI controlled Actors</td>
<td><code>GameplayEffect</code>不会被复制到任何客户端的连接。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
</tbody>
</table>
<p>Note：这里需要注意的是，设置为<code>Mixed</code>模式的时候，ASC的<code>OwnerActor&#39;s</code> <code>Owner</code>需要是<code>Controller</code>。<code>PlayerState</code>的<code>Owner</code>默认就是<code>Controller</code>，而使用<code>Character</code>的情况下就不是，需要我们调用<code>SetOwner()</code>函数手动设置一个有效的<code>Controller</code>。</p>
<p>从UE4的4.24版本开始，<code>Pawn</code>的<code>PossessedBy()</code>函数会设置<code>Owner</code>的新<code>Controller</code>。</p>
<p>出于好奇，调查了一下<code>SetOwner()</code>函数，发现这个是<code>AActor</code>的函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the owner of this Actor, used primarily for network replication.</span></span><br><span class="line"><span class="comment">     * @param NewOwner The Actor who takes over ownership of this Actor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetOwner</span><span class="params">( AActor* NewOwner )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the owner of this Actor, used primarily for network replication. */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function">AActor* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似Actor的Owner都需要正确的设置才能被Replicated。</p>
<h4 id="Setup-and-Initialization"><a href="#Setup-and-Initialization" class="headerlink" title="Setup and Initialization"></a>Setup and Initialization</h4><p>ACS一般情况下都需要在<code>OwnerActor</code>的构造函数中创建，而且需要被标记为<strong>Replicated</strong>。这一步只能在C++中完成。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AGDPlayerState::AGDPlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create ability system component, and set it to be explicitly replicated</span></span><br><span class="line">    AbilitySystemComponent = CreateDefaultSubobject&lt;UGDAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystemComponent"</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;SetIsReplicated(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ASC需要初始化它<strong>Server/Client</strong>的<code>OwnerActor</code>和<code>AvatarActor</code>，这一步可以在<code>Pawn</code>的<code>Controller</code>被设置(possession)的时候执行。单人游戏的话就只需要担心Server端就行了。</p>
<p>据作者的习惯，当把ASC放在玩家控制的Pawn的时候，我们可以在Server的<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，Client端在<code>PlayerController&#39;s</code> <code>AcknowledgePossession()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> APACharacterBase::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASC MixedMode replication requires that the ASC Owner's Owner be the Controller.</span></span><br><span class="line">    SetOwner(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> APAPlayerControllerBase::AcknowledgePossession(APawn* P)</span><br><span class="line">&#123;</span><br><span class="line">    Super::AcknowledgePossession(P);</span><br><span class="line"></span><br><span class="line">    APACharacterBase* CharacterBase = Cast&lt;APACharacterBase&gt;(P);</span><br><span class="line">    <span class="keyword">if</span> (CharacterBase)</span><br><span class="line">    &#123;</span><br><span class="line">            CharacterBase-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(CharacterBase, CharacterBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们把ASC放到玩家控制的<code>PlayerState</code>上的时候，Server端还是一样放到<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，而Client端在<code>Pawn&#39;s</code> <code>OnRep_PlayerState()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC on the Server. Clients do this in OnRep_PlayerState()</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AI won't have PlayerControllers so we can init again here just to be sure. No harm in initing twice for heroes that have PlayerControllers.</span></span><br><span class="line">            PS-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::OnRep_PlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnRep_PlayerState();</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC for clients. Server does this in PossessedBy.</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Init ASC Actor Info for clients. Server will init its ASC when it possesses a new Actor.</span></span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果出现了<code>LogAbilitySystem: Warning: Can&#39;t activate LocalOnly or LocalPredicted ability %s when not local!</code>这样的警告消息，意味着ASC没有在Client端完成<code>OwnerActor</code>和<code>AvatarActor</code>的初始设定。</p>
<p><strong>Tips:</strong> <br><br>这里在ASC到底是放在PlayerState还是Character上的问题上，就我自身遇到的情况来看，</p>
<p>当ASC放在PlayerState上的时候，即ASC的OwnerActor是PlayerState，优点是可以省略一些Controller的设置操作。但是我遇到的是需要对ASC中的属性进行Replicated的时候，由于PlayerState本身默认的<code>NetUpdateFrequency</code>的值很低(听来的)，更新不频繁就会使得属性的Replication变得很迟缓，故而会有问题。</p>
<p>调整PlayerState的属性网络更新频率也是一种方法，但是跟Character的情况就多了一些操作。</p>
<h3 id="Gameplay-Tags"><a href="#Gameplay-Tags" class="headerlink" title="Gameplay Tags"></a>Gameplay Tags</h3><p><code>FGameplayTags</code>是一种层级式的命名方式，就像<code>Parent.Child.Grandchild...</code>这样，被登记在<code>GameplayTagManager</code>里面。据作者所说，<code>GameplayTags</code>非常的有用，有的时候会在程序的逻辑中使用一些<code>booleans</code>或者枚举，这些可以用<code>GameplayTags</code>来替代。</p>
<p>通常我们是向ASC中添加一个<code>Tag</code>，以便于和<strong>GAS</strong>的交互。<code>UAbilitySystemComponent</code>实现了<code>IGameplayTagAssetInterface</code>接口，这个接口提供了访问自己的<code>GameplayTags</code>的函数。</p>
<p>多个<code>GameplayTags</code>可以使用<code>FGameplayTagContainer</code>来存储，相比于常规的<code>TArray&lt;FGameplayTag&gt;</code>，前者更加有效率(efficiency magic)。Tags是标准的<code>FName</code>类型，在<code>FGameplayTagContainer</code>中存储可以非常效率的打包方便<strong>Replication</strong>。前提是开启了ProjectSetting中的<code>Fast Replication</code>功能。<code>Fast Replication</code>要求Server和Client拥有相同的<code>GameplayTags</code>的列表(list)，一般情况下这不是问题，所以应该开启这个功能。</p>
<p><code>GameplayTagontainer</code>也可以返回一个<code>TArray&lt;FGameplayTag&gt;</code>方便我们遍历。</p>
<p>存储在<code>FGameplayTagCountContainer</code>的<code>GameplayTags</code>有一个<code>TagMap</code>被用来存储<code>GameplayTag</code>的实例(Instance)的数量。一个<code>FGameplayTagCountContainer</code>也许会存在某个<code>GameplayTag</code>，但是它的<code>TagMapCount</code>的值是<code>0</code>，这也许会在调试的时候遇到这种情况，可能明明已经移除了这个GameplayTag(encounter)，但是ASC仍然持有这个<code>GameplayTag</code>。</p>
<p>使用<code>HasTag()</code>或者<code>HasMatchingTag()</code>之类相似的函数，会检查<code>TagMapCount</code>的值，当该<code>GameplayTag</code>不存在亦或者<code>TagMapCount</code>的值为0的时候返回false。</p>
<p>使用<strong>GameplayTag</strong>的时候，一定要在<code>DefaultGameplayTags.ini</code>中提前定义。（个人经验就是用了没有定义过的GameplayTags之后会发生不太好的事情）成为直接在配置文件中定义GameplayTag之外，还可以利用UE4Editor提供的接口界面，</p>
<p>此处应有GameplayTag的编辑界面图片。</p>
<blockquote>
<p>Searching for GameplayTag references will bring up the familiar Reference Viewer graph in the Editor showing all the assets that reference the GameplayTag. This will not however show any C++ classes that reference the GameplayTag.<br>这句话的意思没有完全理解，在尝试对<code>GameplayTag</code>的Reference进行搜索的时候，使用那个<strong>ReferenceViewer</strong>，会表示与之相关的资产(Assets)，但是不会显示任何与C++类相关联的资产。</p>
</blockquote>
<p>这句话让我联想到了如果一大堆素材与这个GameplayTag相关联的话，是不是都会被加载到内存里面，无论它是不是会用到。至于C++中使用这个GameplayTag的话是不是就相对安全一些？看来在制作的过程中，勤奋的确认ReferenceView的内容是必要的啊。</p>
<p>对GameplayTag进行重命名(Rename)会产生一个重定向(redirect)以便于其所关联的资产能够重定向到新的GameplayTag上。据作者所说，可能的话还是新建一个GameplayTag，然后手动调整资产连接到新的GameplayTag上，然后删掉旧的GameplayTag，最好还是避免创建重定向(redirect)资源。我也认为既然重命名是一个会创建资源的操作的话还是避免为好。</p>
<p>除了<code>Fast Replication</code>之外，<code>GameplayTag</code> editor还有一个可以更加深度优化<code>GameplayTag</code>的<code>Replicated</code>的选项。</p>
<p>由<code>GameplayEffect</code>添加的GameplayTag会Replicated。ASC还允许添加不会Replicated的<code>LooseGameplayTags</code>，它必须手动的进行管理。该项目就使用了<code>State.Dead</code>作为<code>LooseGameplayTag</code>，以便于当玩家的HP降到0的时候OwningClient能够立马做出反应。Respawning的时候再手动的将这个Tag的<code>TagMapCount</code>置为0。当使用<code>LooseGameplayTag</code>的时候，只能手动的去调整<code>TagMapCount</code>的值。</p>
<p>这里推荐<code>UAbilitySystemComponent::AddLooseGameplayTag()</code>和<code>UAbilitySystemComponent::RemoveLooseGameplayTag()</code>函数，它们应该会自动调整<code>TagMapCount</code>的值，使用这个函数应该不用真的去对TagMapCount的值进行操作。</p>
<p>在C++中获取一个GameplayTag的Reference的方式：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FGameplayTag::RequestGameplayTag(FName(<span class="string">"Your.GameplayTag.Name"</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>GameplayTagManager</code>还提供了一些GameplayTag的高级用法，比如获取一个GameplayTag的Parent和Children。添加<code>GameplayTagManager.h</code>头文件以便于使用其功能。<code>UGameplayTagManager::Get().FunctionName</code>这样调用，实际上GameplayTagManager就是用这种类似节点(relational node)的方式(parent,child,etc)来存储GameplayTag，方便用来进行类似字符串的合并对比操作。</p>
<p>GameplayTag和GameplayTagContainer有一个可选的<code>UPROPERTY()</code>属性修饰符(specifier)，<code>Meta = (Categories = &quot;GameplayCue&quot;)</code>，可以用来在Blueprint中筛选表示ParentNode是<code>GameplayCue</code>的标签。当你知道这些GameplayTag和GameplayTagContainer仅在<code>GameplayCue</code>中使用的时候这个修饰符会很有用。</p>
<p>除此之外还有一个<code>FGameplayCueTag</code>的结构体，它对GameplayTag做了些制约(猜测是只有Parent是GameplayCue的Tag)，它会自动的过滤在Blueprint中仅显示GameplayCue为父节点的标签。</p>
<p>同理，如果想在函数里面过滤GameplayTag，使用<code>UFUNCTION()</code>的修饰符<code>Meta = (GameplayTagFilter = &quot;GameplayCue&quot;)</code>。但是GameplayTagContainer就不行了，想要它也适用则需要对引擎做些修改。</p>
<blockquote>
<p>If you would like to edit your engine to allow this, look at how <code>SGameplayTagGraphPin::ParseDefaultValueData()</code> from <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagGraphPin.cpp</code> calls <code>FilterString = UGameplayTagsManager::Get().GetCategoriesMetaFromField(PinStructType);</code> and passes <code>FilterString</code> to <code>SGameplayTagWidget</code> in <code>SGameplayTagGraphPin::GetListContent().</code> The <code>GameplayTagContainer</code> version of these functions in <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagContainerGraphPin.cpp</code> do not check for the meta field properties and pass along the filter.</p>
</blockquote>
<p>这涉及具体操作了我看太懂，直接复制过来了。</p>
<h4 id="GameplayTag有变动的函数回调"><a href="#GameplayTag有变动的函数回调" class="headerlink" title="GameplayTag有变动的函数回调"></a>GameplayTag有变动的函数回调</h4><p>ASC提供了GameplayTag的<strong>Add/Remove</strong>操作的Delegate，这个Delegate需要一个<code>EGameplayTagEventType</code>类型的参数，只有当GameplayTag由于Add/Remove等操作使得<code>GameplayTag&#39;s</code> <code>TagMapCount</code>的值被修改的时候，这个代理会被执行(fire)。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;RegisterGameplayTagEvent(FGameplayTag::RequestGameplayTag(FName(<span class="string">"State.Debuff.Stun"</span>)), EGameplayTagEventType::NewOrRemove).AddUObject(<span class="keyword">this</span>, &amp;AGDPlayerState::StunTagChanged);</span><br></pre></td></tr></table></figure></p>
<p>回调函数有该GameplayTag和新的<code>TagCount</code>值作为参数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StunTagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><h4 id="Attribute-定义"><a href="#Attribute-定义" class="headerlink" title="Attribute 定义"></a>Attribute 定义</h4><p><code>Attributes</code>是由<code>FGameplayAttributeData</code>结构体定义的<strong>float values</strong>。他可以表示游戏中的任何数值类的能力，像HP，MP，玩家等级之类的。游戏设计中如果<code>Actor</code>有什么数值相关的属性能力，都可以考虑用<code>Attributes</code>来实现。<br><br><code>Attributes</code>的修改一般情况下都应该由<code>GameplayEffects</code>来执行，这样方便ASC预测这些修改(predict the changes)。<br></p>
<p>关于GAS的一些预测(prodict)功能，也是很重要的内容，会在以后进行验证。<br><span style="color:blue">此处应该有FGameplayAttributeData结构体的源码截图。</span></p>
<p><code>Attributes</code>是由<code>AttributeSet</code>来定义和保持的，同时也负责着<code>Attributes</code>的Replication。</p>
<p><span style="color:blue">此处应该有AttributeSet的源码截图</span></p>
<p><strong>Tips</strong> :<br><br>可以使用<code>Meta = (HideInDetailsVies)</code>属性修饰符来隐藏<code>Attributes</code>,使其不会出现在UE4Editor的列表中。</p>
<h4 id="BaseValue-vs-CurrentValue"><a href="#BaseValue-vs-CurrentValue" class="headerlink" title="BaseValue vs CurrentValue"></a>BaseValue vs CurrentValue</h4><p>一个<code>Attribute</code>是由两个值组成的，<code>BaseValue</code>和<code>CurrentValue</code>。</p>
<ul>
<li><code>BaseValue</code> : 代表着Attribute永久变更的值(the permanent value)，相对于<code>CurrentValue</code>而言。</li>
<li><code>CurrentValue</code> : 代表着Attribute的<code>BaseValue</code>加上来自<code>GameplayEffect</code>的临时变更的值。</li>
</ul>
<p>举个栗子就是玩家的移动速度是1m/s，那么此时BaseValue和CurrentValue的值都是1m/s。但是当我们给玩家一个加速效果(GameplayEffect)，玩家的移动速度变成了1.1m/s，此时BaseValue是1m/s，而CurrentValue的值是(1+0.1=)1.1m/s。当加速效果结束，BaseValue和CurrentValue的值都回到了1m/s。</p>
<p>这里需要注意的是BaseValue经常会被误认为是Attribute的最大值，而我最开始确实是这样误解的，其实不是。某个属性的最大值比如说HP等，同样也是Attribute的一种，也是需要BaseValue和CurrentValue。</p>
<p>对于Attribute的最大值最小值进行硬编码的问题，UE4提供了一种<code>DataTable</code>，使用<code>FAttributeMetaData</code>来设置。但是据源码的评论内容来看这个Struct仍然是WIP状态。只有期待后续的更新了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* DataTable that allows us to define meta data about attributes. Still a work in progress.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">FAttributeMetaData</span> :</span> <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FAttributeMetaData();</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> BaseValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MinValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MaxValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FString DerivedAttributeInfo;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">bool</span> bCanStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>目前我并没有使用这个方法，而是将最大值和最小值也视为常规的Attribute来使用。</p>
<p>通常对于来自GameplayEffect的处理，会有Clamp之类的处理，而这类的处理，对于Attribute中的这两个值来说会被放在不同的地方：</p>
<ul>
<li><code>CurrentValue</code>的Clamp处理通常会在<code>PreAttributeChange()</code>函数里进行</li>
<li><code>BaseValue</code>的Clamp处理通常会在<code>PostGameplayEffectExecute()</code>函数里进行</li>
</ul>
<p>通常情况下，<code>Instant`</code>GameplayEffects<code>这种类型的GE被视为对Attribute的永久变更，会直接改变</code>BaseValue<code>的值，而</code>Duration<code>Infinite`类型的`GameplayEffects`则是一种暂时的状态会改变`CurrentValue`的值。`Periodic</code>GameplayEffects<code>类型像</code>Instant<code>一样会改变</code>BaseValue`的值。</p>
<h4 id="Meta-Attributes"><a href="#Meta-Attributes" class="headerlink" title="Meta Attributes"></a>Meta Attributes</h4><p>有一些Attributes可以被用来当做是占位符(placeholders)或者临时的变量，目的是与其他的Attributes做一些交互(interact)，我们称作这样的变量为<code>MetaAttribute</code>。最常见的就是<strong>Damage</strong>伤害变量，我们将Damage变量作为占位符变量存储伤害数值，而不是将其封装在GameplayEffect中，使用GE<strong>直接</strong>改变我们的生命值。</p>
<p>这种方式可以方便的将伤害值传给<code>GameplayEffectExecutionCalculation</code>，方便其进行一些Buff和Debuff的计算。而且还可以更方便在<code>AttributeSet</code>中进行操作。需要注意的是MetaAttributes在GameplayEffect之间没有持久性(persistence)，也就是可以被任何一方修改，或者说是重写(override)。<strong>一般MetaAttributes不会Replicated</strong>。</p>
<p>MetaAttributes为分离逻辑和数值的设计模式提供了良好的灵活性，但也不是必须要这么使用，取决于项目要求。</p>
<h4 id="Responding-to-Attribute-Changes"><a href="#Responding-to-Attribute-Changes" class="headerlink" title="Responding to Attribute Changes"></a>Responding to Attribute Changes</h4><p>监听Attributes的值的变化可以用来更新UI或者其他的gameplay。使用<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>函数，该函数会返回一个代理(delegate)，我们可以将想要执行的函数比如说更新UI，绑定到这个代理上。</p>
<p>这个代理提供了一个<code>FOnAttributeChangeData</code>参数，里面包含了<code>NewValue</code>和<code>OldValue</code>，还有<code>FGameplayEffectModCallbackData</code>参数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(AttributeSetBase-&gt;GetHealthAttribute()).AddUObject(<span class="keyword">this</span>, $AGDPlayerState::HealthChanged);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p><code>FGameplayEffectModCallbackData</code>只能在Server端被设置。</p>
<p>目前关于这个struct的内容我还不太清楚。</p>
<p>在GASDocumentation的项目中，作者制作了一个<code>AsyncTask</code>，用来方便的定制Attribute的更新与UI的更新事件。由于制作很是巧妙，而且还有我不知道的用法在里面，就像复制粘贴过来。至于源文件的链接我也贴上。</p>
<ul>
<li><a href="https://github.com/tranek/GASDocumentation/blob/master/Source/GASDocumentation/Public/Characters/Abilities/AsyncTaskAttributeChanged.h" target="_blank" rel="noopener">GASDocumentation-AsyncTaskAttributeChanged.h</a><br><details><br><summary>点击展开代码</summary><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Copyright 2020 Dan Kestranek.</span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;Kismet/BlueprintAsyncActionBase.h&quot;</span><br><span class="line">#include &quot;AbilitySystemComponent.h&quot;</span><br><span class="line">#include &quot;AsyncTaskAttributeChanged.generated.h&quot;</span><br><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FOnAttributeChanged, FGameplayAttribute, Attribute, float, NewValue, float, OldValue);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Blueprint node to automatically register a listener for all attribute changes in an AbilitySystemComponent.</span><br><span class="line"> * Useful to use in UI.</span><br><span class="line"> */</span><br><span class="line">UCLASS(BlueprintType, meta=(ExposedAsyncProxy = AsyncTask))</span><br><span class="line">class GASDOCUMENTATION_API UAsyncTaskAttributeChanged : public UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">        GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">        UPROPERTY(BlueprintAssignable)</span><br><span class="line">        FOnAttributeChanged OnAttributeChanged;</span><br><span class="line"></span><br><span class="line">        // Listens for an attribute changing.</span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;))</span><br><span class="line">        static UAsyncTaskAttributeChanged* ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute);</span><br><span class="line"></span><br><span class="line">        // Listens for an attribute changing.</span><br><span class="line">        // Version that takes in an array of Attributes. Check the Attribute output for which Attribute changed.</span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;))</span><br><span class="line">        static UAsyncTaskAttributeChanged* ListenForAttributesChange(UAbilitySystemComponent* AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes);</span><br><span class="line"></span><br><span class="line">        // You must call this function manually when you want the AsyncTask to end.</span><br><span class="line">        // For UMG Widgets, you would call it in the Widget&apos;s Destruct event.</span><br><span class="line">        UFUNCTION(BlueprintCallable)</span><br><span class="line">        void EndTask();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">        UPROPERTY()</span><br><span class="line">        UAbilitySystemComponent* ASC;</span><br><span class="line"></span><br><span class="line">        FGameplayAttribute AttributeToListenFor;</span><br><span class="line">        TArray&lt;FGameplayAttribute&gt; AttributesToListenFor;</span><br><span class="line"></span><br><span class="line">        void AttributeChanged(const FOnAttributeChangeData&amp; Data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<ul>
<li><a href>GASDocumentation-AsyncTaskAttributeChanged.cpp</a><br><details><br><summary>点击展开代码</summary>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Copyright 2020 Dan Kestranek.</span><br><span class="line">#include &quot;Characters/Abilities/AsyncTaskAttributeChanged.h&quot;</span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributeToListenFor = Attribute;</span><br><span class="line"></span><br><span class="line">        if (!IsValid(AbilitySystemComponent) || !Attribute.IsValid())</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line"></span><br><span class="line">        return WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged * UAsyncTaskAttributeChanged::ListenForAttributesChange(UAbilitySystemComponent * AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributesToListenFor = Attributes;</span><br><span class="line"></span><br><span class="line">        if (!IsValid(AbilitySystemComponent) || Attributes.Num() &lt; 1)</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (FGameplayAttribute Attribute : Attributes)</span><br><span class="line">        &#123;</span><br><span class="line">                AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAsyncTaskAttributeChanged::EndTask()</span><br><span class="line">&#123;</span><br><span class="line">        if (IsValid(ASC))</span><br><span class="line">        &#123;</span><br><span class="line">                ASC-&gt;GetGameplayAttributeValueChangeDelegate(AttributeToListenFor).RemoveAll(this);</span><br><span class="line"></span><br><span class="line">                for (FGameplayAttribute Attribute : AttributesToListenFor)</span><br><span class="line">                &#123;</span><br><span class="line">                        ASC-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).RemoveAll(this);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetReadyToDestroy();</span><br><span class="line">        MarkPendingKill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAsyncTaskAttributeChanged::AttributeChanged(const FOnAttributeChangeData &amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">        OnAttributeChanged.Broadcast(Data.Attribute, Data.NewValue, Data.OldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<p>这段代码实现了两个函数<code>ListenForAttributeChange</code>和<code>ListenForAttributesChange</code>用来监视Attribute的值的变更，同时是基于<code>UBlueprintAsyncActionBase</code>扩展的类，也可以在BP中方便的使用这两个函数，主要是对于UI的操作来说，提供这样的函数会更加方便一些。</p>
<p><img src="ListenForAttributeChange.png" alt="AttributeChange"></p>
<h4 id="Derived-Attributes"><a href="#Derived-Attributes" class="headerlink" title="Derived Attributes"></a>Derived Attributes</h4><p>刚开始看的时候就觉得好高大上啊，派生属性好厉害，难不成是AttributeSet的派生类中的Attribute也能更新，但仔细想想这太厉害了也，而且不符合我学到的知识。</p>
<p>关于这个Attribute的派生的功能，其实是说比如当我们在<code>Infinite</code>类型的<code>GameplayEffect</code>中使用一个或更多个的<code>Attribute Based</code>和<code>MMC Modifiers</code>的时候，<code>Derived Attribute</code>会依据它所依赖的上述类型的变量的变化而更新自己的值。</p>
<blockquote>
<p>The <code>Derived Attribute</code> will update automatically when an <code>Attribute</code> that it depends on is updated.</p>
</blockquote>
<p>简单来理解就是当一个Attribute依赖于其他的Attribute的时候，这个Attribute就是一个<code>Derived Attribute</code>，而且其它的Attribute的值更新的时候，这个Attribute的值也会被更新。<br>文章中所举的例子就是：<code>TestAttrA = (TestAttrA + TestAttrB) * 2 * TestAttrC</code>这种计算中，<code>TestAttrA</code> <code>TestAttrB</code> <code>TestAttrC</code>中的任何一个值有更新，<code>TestAttrA</code>的值都会随之被更新。</p>
<p>至于这段内容还有没有额外的意思我不太确定，我只理解到了这一步。</p>
<blockquote>
<p>The final formula for all the <code>Modifiers</code> on a <code>Derived Attribute</code> is the same formula for <code>Modifier Aggregators</code>. If you need calculations to happen in a certain order, do it all inside of an <code>MMC</code>.</p>
</blockquote>
<p>关于<code>Modifier Aggregator</code>的内容我目前也不是很了解，大意应该就是，对于<code>Derived Attribtue</code>来说普通的<code>Modifier</code>计算公式顺序是和<code>Modifier Aggregator</code>是一样的，如果想要其按照某种顺序你想要的顺序来计算的话，就需要我们在<code>MMC</code>中完成这些事情。</p>
<blockquote>
<p><strong>Note:</strong> If playing with multiple clients in PIE, you need to disable <code>Run Under One Process</code> in the Editor <code>Preferences</code> otherwise the <code>Derived Attributes</code> will not update when their independent Attributes update on clients other than the first.</p>
</blockquote>
<p><strong>Note:</strong> 这段的意思我不是完全理解，大意应该就是在Editor的PIE模式下运行多个客户端的时候，记得把Editor的<code>Preference</code>中的<code>Run Under One Process</code>一项禁用掉，不然的话，除了第一个被运行的Client之外，其他Client上的<code>Dervied Attributes</code>尽管依赖的属性更新，其派生的Attribute的值也不会被更新。</p>
<h3 id="Attribute-Set"><a href="#Attribute-Set" class="headerlink" title="Attribute Set"></a>Attribute Set</h3><h4 id="Attribute-Set定义"><a href="#Attribute-Set定义" class="headerlink" title="Attribute Set定义"></a>Attribute Set定义</h4><p><code>Attributes</code>的变更是由 <code>AttributeSet</code>定义，维持和管理的。需要继承<code>UAttributeSet</code>类来实现。</p>
<p>在<code>OwnerActor</code>的构造函数中创建<code>AttributeSet</code>的话，会自动的登记到它的<code>ASC</code>上。这句话我很在意，也就是说在别处创建的话就需要手动登记<code>AttributeSet</code>到<code>ASC</code>上的意思？</p>
<p>这部分是只有在C++中才能实现的。</p>
<h4 id="如何设计AttributeSet"><a href="#如何设计AttributeSet" class="headerlink" title="如何设计AttributeSet"></a>如何设计AttributeSet</h4><p>一个<code>ASC</code>可以拥有一个或者多个<code>AttributeSet</code>。由于<code>AttributeSet</code>的内存开销极小，所以拥有多少个<code>Attribute</code>完全取决于开发者的意愿。</p>
<p>如何对<code>AttributeSet</code>进行分类管理也取决于开发者。</p>
<p><code>Attribute</code>在内部是以<code>AttributeSetClassName.AttributeName</code>这种方式来识别的。也就是说<code>Attribute</code>会拥有它们父类的名字作为自己名字的前缀。</p>
<p>我们可以拥有复数个<code>AttributeSet</code>，但是却不能让<code>ASC</code>拥有相同类的复数个<code>AttributeSet</code>。如果添加了同一个类的<code>AttributeSet</code>，它会不知道指的是哪一个。</p>
<p>↑上面这个我没有验证过。</p>
<p>这之后文章又举了几个例子来验证<code>AttributeSet</code>的实现和可行性。总结起来就是，使用<code>AttributeSet</code>的场景需要具体情况具体分析，不要过度迷信它的使用，有的时候有的场景，单纯的使用一个简单的<code>float</code>变量会更好的解决问题。</p>
<h5 id="运行时添加或移除AttributeSet"><a href="#运行时添加或移除AttributeSet" class="headerlink" title="运行时添加或移除AttributeSet"></a>运行时添加或移除AttributeSet</h5><p>添加：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ASC-&gt;SpawnedAttributes.AddUnique(AttributeSetPointer);</span><br><span class="line">ASC-&gt;ForceReplication();</span><br></pre></td></tr></table></figure></p>
<p>移除：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ASC-&gt;SpawnedAttributes.Remove(AttributeSetPointer);</span><br><span class="line">ASC-&gt;ForceReplication();</span><br></pre></td></tr></table></figure></p>
<p>由于移除操作是一个非常危险的操作，使用的时候需要斟酌。比如说Client移除之后，来自于Server的Replication操作会使游戏崩溃。</p>
<h5 id="使用float来替代AttributeSet"><a href="#使用float来替代AttributeSet" class="headerlink" title="使用float来替代AttributeSet"></a>使用float来替代AttributeSet</h5><p>这里我想记录的其实是<code>PreReplication</code>这个函数。</p>
<p>我们可以使用float来暂时代替<code>AttributeSet</code>，当然这只是一个我自己的想当然的说法，只是本应该用<code>AttributeSet</code>来表现的属性值，我们选择了用简单的<code>float</code>来实现。</p>
<p>这就导致了我们没有办法使用GE，也没办法预测（Prediction）。</p>
<p>所以就有了<code>PreReplication</code>函数的使用，我们需要对这个float做一些本地预测的处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AGSWeapon::RreReplication(IRepChangedPropertyTracker&amp; ChangedPropertyTracker)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PreReplication(ChangedPropertyTracker);</span><br><span class="line"></span><br><span class="line">    DOREPLIFETIME_ACTIVE_OVERRIDE(AGSWeapon, PrimaryClipAmmo, (IsValid(ASC)&amp;&amp;!ASC-&gt;HasMatchhingGameplayTag(WeaponIsFireTag)));</span><br><span class="line">    DOREPLIFETIME_ACTIVE_OVERRIDE(AGSWeapon, SecondaryClipAmmo, (IsValid(ASC)&amp;&amp;!ASC-&gt;HasMatchhingGameplayTag(WeaponIsFireTag)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的实现还是得去看这个项目的源码。</p>
<p>当我们把<code>AttributeSet</code>并不是放到ASC的<code>OwnerActor</code>上的时候，放在其他的<code>Actor</code>比如说<code>Weapon</code>的时候，在<code>Actor</code>的构造函数中对<code>AttributeSet</code>进行实例化操作可能会出现编译错误，我们只要把<code>AttributeSet</code>的实例化操作放到<code>BeginPlay()</code>中就好了。</p>
<p>↑上面的说法，当然我没有遇见过这个编译错误，毕竟我还没有验证过。</p>
<h4 id="Attributes定义"><a href="#Attributes定义" class="headerlink" title="Attributes定义"></a>Attributes定义</h4><p><code>Attribute</code>的定义只能在C++中进行，定义在<code>AttributeSet.h</code>头文件中。</p>
<p>推荐奖下面的宏添加到头文件中，这个宏会自动的帮我们生成<code>Attribute</code>的<code>Getter</code>和和<code>Setter</code>函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Uses macros from AttributeSet.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line">    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span><br></pre></td></tr></table></figure></p>
<p>然后定义一个可以<code>Replicated</code>的<code>attribute</code>:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY(BlueprintReadOnly, Category = <span class="string">"Health"</span>, ReplicatedUsing = OnRep_Health)</span><br><span class="line">FGameplayAttributeData Health;</span><br><span class="line">ATTRIBUTE_ACCESSORS(UGDAttributeSetBase, Health)</span><br></pre></td></tr></table></figure></p>
<p>然后不要忘了声明实现上面要用到的<code>OnRep</code>函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UFUNCTION()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="keyword">const</span> FGameplayAttributeData&amp; OldHealth)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在 .cpp 文件中对上面的复制函数实现的时候要添加一个<code>GAMEPLAYATTRIBUTE_REPNOTIFY</code>宏，GAS的<strong>prediction system</strong>需要使用到它。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDAttributeSetBase::OnRep_Health(<span class="keyword">const</span> FGameplayAttributeData&amp; OldHealth)</span><br><span class="line">&#123;</span><br><span class="line">    GAMEPLAYATTRIBUTE_REPNOTIFY(UGDAttributeSetBase, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后把复制的属性添加到<code>GetLifetimeReplicatedProps</code>中去。这些都是UE4中使用Actor的<em>Replication</em>的常规操作了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDAttributeSetBase::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">    DOREPLIFETIME_CONDITION_NOTIFY(UGDAttributeSetBase, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>REPTNOTIFY_Always</code> tells the OnRep function to trigger if the local value is already equal to the value being repped down from the Server (due to prediction). By default it won’t trigger the OnRep function if the local value is the same as the value being repped down from the Server.REPTNOTIFY_Always tells the OnRep function to trigger if the local value is already equal to the value being repped down from the Server (due to prediction). By default it won’t trigger the OnRep function if the local value is the same as the value being repped down from the Server.</p>
</blockquote>
<p><code>REPNOTIFY_Always</code>会触发<code>OnRep</code>事件，不论来自Server的值是否与我们本地的值相等。而默认的话相等的情况下是不会触发该事件的。</p>
<p>如果是使用<code>Meta Attribute</code>的话，<code>OnRep</code>和<code>GetLifetimeReplicatedProps</code>都可以跳过。</p>
<h4 id="Attribute的初始化"><a href="#Attribute的初始化" class="headerlink" title="Attribute的初始化"></a>Attribute的初始化</h4><p>观察<code>·Attributes</code>的源码会找到多种初始化属性的方法。Epic官方推荐的是使用<code>Instant GameplayEffect</code>来执行初始化。</p>
<p>或者使用了上面的<code>ATTRIBUTE_ACCESSORS</code>宏的话就可以使用定义好的Setter函数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// InitHealth(float InitialValue) is an automatically generated function for an Attribute 'Health' defined with the `ATTRIBUTE_ACCESSORS` macro</span></span><br><span class="line">AttributeSet-&gt;InitHealth(<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: Prior to 4.24, FAttributeSetInitterDiscreteLevels did not work with FGameplayAttributeData. It was created when Attributes were raw floats and will complain about FGameplayAttributeData not being Plain Old Data (POD). This is fixed in 4.24 <a href="https://issues.unrealengine.com/issue/UE-76557.Note" target="_blank" rel="noopener">https://issues.unrealengine.com/issue/UE-76557.Note</a>: Prior to 4.24, FAttributeSetInitterDiscreteLevels did not work with FGameplayAttributeData. It was created when Attributes were raw floats and will complain about FGameplayAttributeData not being Plain Old Data (POD). This is fixed in 4.24 <a href="https://issues.unrealengine.com/issue/UE-76557" target="_blank" rel="noopener">https://issues.unrealengine.com/issue/UE-76557</a>.</p>
</blockquote>
<p>由于这个是之前版本的已修复的问题我就直接贴原文了。</p>
<p><strong>Tips</strong></p><br>我在GASDocumentation中看到，关于AttributeSet的初始化的问题。作者选择了Server和Client两侧都执行了初始化的操作。<p></p>
<details><br>    <summary><mark><font color="darked">初始化Attribute操作，点击展开代码</font></mark> </summary><br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// GDCharacterBase.h</span><br><span class="line">// Initialize the Character&apos;s attributes. Must run on Server but we run it on Client too</span><br><span class="line">// so that we don&apos;t have to wait. The Server&apos;s replication to Client wont&apos;t matter since</span><br><span class="line">// the values should be the same.</span><br><span class="line">virtual void InitializeAttributes();</span><br><span class="line"></span><br><span class="line">// GDCharacterBase.cpp</span><br><span class="line">void AGDCharacterBase::InitializeAttributes()</span><br><span class="line">&#123;</span><br><span class="line">    if(!AbilitySystemComponent.IsValid()</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!DefaultAttributes)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Can run on Server and Client</span><br><span class="line">    FGameplayEffectContextHandle EffectContext = AbilitySystemComponent-&gt;MakeEffectContext();</span><br><span class="line">    EffectContext.AddSourceObject(this);</span><br><span class="line"></span><br><span class="line">    FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent-&gt;MakeOutgoingSpec(DefaultAttributes, GetCharacterLevel(), EffectContext);</span><br><span class="line">    if(NewHandle.IsValid())</span><br><span class="line">    &#123;</span><br><span class="line">        FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p><br></p>
<p>像上面这样在双方都进行了初始化，但是我自己实验了之后明显Client这边没有被成功的初始化，貌似GameplayEffect这边执行Apply的时候也会有一个Authority检查，就导致Client在上面的<code>ApplyGameplayEffectSpecToTarget</code>这一步返回的<code>ActiveGEHandle</code>是<code>-1</code>，也就是无效的Handle。(可能是跟ASC的ReplicationMode有关？我选的是MixMode)</p>
<p>看来真的想在Client端也进行初始化的话，还是用<code>Setter</code>,<code>Getter</code>函数比较靠谱。再就是直接使用Epic官方推荐的使用GE的方式。</p>
<h4 id="PreAttributeChange-函数"><a href="#PreAttributeChange-函数" class="headerlink" title="PreAttributeChange()函数"></a>PreAttributeChange()函数</h4><p><code>PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue)</code>这个函数会在<code>Attribute</code>的<code>CurrentValue</code>的值被改变之前调用，比如我们想要对新的<code>CurrentValue</code>的值进行<strong>Clamp</strong>处理的时候这个函数就是很好的地方。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GetMoveSpeedAttribute()是之前的宏自动定义的Getter函数</span></span><br><span class="line"><span class="keyword">if</span> (Attribute == GetMoveSpeedAttribute())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Cannot slow less than 150 units/s and cannot boost more than 1000 units/s</span></span><br><span class="line">    NewValue = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(NewValue, <span class="number">150</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是这个函数会在只要<code>Attributes</code>值有变动的时候就会被调用，不是仅限于<code>Attributes</code>的<code>Setter</code>函数被调用还是<code>GameplayEffect</code>被应用。</p>
<p><strong>Note</strong>：</p>
<ol>
<li>需要注意的是，在这个函数里发生的<strong>Clamp</strong>操作，在类似的<code>GameplayEffectExecutionCalculation</code>和<code>ModifierMagnitudeCalculation</code>之类的Modifier存在还需要再做一次Clamp处理。</li>
</ol>
<p>这里我也不是特别清楚，总之先把原文贴上：</p>
<blockquote>
<p> Any clamping that happens here does not permanently change the modifier on the ASC. It only changes the value returned from querying the modifier. This means anything that recalculates the CurrentValue from all of the modifiers like <code>GameplayEffectExecutionCalculations</code> and <code>ModifierMagnitudeCalculations</code> need to implement clamping again.</p>
</blockquote>
<ol start="2">
<li>正如上面说的只要<code>Atttributes</code>的值有变动这个函数就会被调用，Epic官方只推荐在这个函数中做一些对属性Clamp之类的处理，不要当做Attribute的OnChange的Callback来使用。UE4有好好提供正式的Callback函数：<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>，参考上面。</li>
</ol>
<h4 id="PostGameplayEffectExecute-函数"><a href="#PostGameplayEffectExecute-函数" class="headerlink" title="PostGameplayEffectExecute()函数"></a>PostGameplayEffectExecute()函数</h4><p><code>PostGameplayEffectExecute(const FGameplayEffectModCallbackData &amp; Data)</code>函数仅会在<code>Instant GameplayEffect</code>改变了<code>Attribute</code>的<code>BaseValue</code>值之后被调用。</p>
<p>这是一个操控由<code>GameplayEffect</code>修改的<code>Attribute</code>的值的好地方。</p>
<p>GASDocumentation项目在这个函数里做了许多事情，比如说最终对HP的削减，处理HitReaction的动画事件，显示漂浮的伤害数字等等。</p>
<p>对于那些值跟<code>Instant GameplayEffect</code>相关的属性来说，是Clamp处理的好地方。</p>
<p><strong>Note</strong>：</p>
<p><code>PostGameplayEffectExecute()</code>函数被调用的时候，Attribute的值的修改已经发生了，但是还没有被Replicated到其他的客户端上的，所以在这个函数的Clamp操作不会导致两次Client的ValueUpdate。<strong>客户端只会收到Clamp操作更新之后的值</strong>。</p>
<h4 id="OnAtttributeAggregatorCreate-函数"><a href="#OnAtttributeAggregatorCreate-函数" class="headerlink" title="OnAtttributeAggregatorCreate()函数"></a>OnAtttributeAggregatorCreate()函数</h4><p><code>OnAttributeAggregatorCreated(const FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</code>函数会在一个AttributeSet中为Attribute创建了一个<code>Aggregator</code>的时候被调用。</p>
<p>它允许我们自定义<code>FAggregatorEvaluateMetaData</code>的设置。<code>AggregatorEvaluateMetaData</code>被用来对Attribute的<code>CurrentValue</code>基于<strong>Modifier</strong>进行评价的东西。(英文的这里有些晦涩难懂)比如说默认的情况下我们会使用<code>MostNegativeMod_AllPosositiveMods</code>的模式，表示对于Attribute的<code>CurrentValue</code>的<strong>Modifier</strong>操作来说，积极意义的操作(Positive)允许该<strong>Modifier</strong>对<code>CurrentValue</code>的值进行修改，但是对于消极意义的操作(Negative)就会加以限制，只允许其中最消极的一个<strong>Modifier</strong>对<code>CurrentValue</code>进行修改。</p>
<p>文章中举的栗子就是在同一时间对于玩家速度的所有的增益效果都会被保留并反映到数值上，但是对于所有的减益效果在同一时间只会把最消极的效果应用到玩家速度上反映到数值上。需要注意的是，此时这些减益效果的Effect仍然是存在ASC上的，它们只是最终没有被聚合反映到最终的<code>CurrentValue</code>上而已。</p>
<p>由于这段晦涩难懂，我害怕自己理解错误，以防万一贴上原文</p>
<details><br>    <summary>点击展开英文原文</summary><br>    &gt; <code>OnAttributeAggregatorCreated(const FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</code> triggers when an Aggregator is created for an Attribute in this set. It allows custom setup of <code>FAggregatorEvaluateMetaData</code>. <code>AggregatorEvaluateMetaData</code> is used by the Aggregator in evaluating the <code>CurrentValue</code> of an Attribute based on all the <code>Modifiers</code> applied to it. By default, <code>AggregatorEvaluateMetaData</code> is only used by the Aggregator to determine which Modifiers qualify with the example of <code>MostNegativeMod_AllPositiveMods</code> which allows all positive Modifiers but restricts negative Modifiers to only the most negative one. This was used by Paragon to only allow the most negative move speed slow effect to apply to a player regardless of how many slow effects where on them at any one time while applying all positive move speed buffs. Modifiers that don’t qualify still exist on the ASC, they just aren’t aggregated into the final CurrentValue. They can potentially qualify later once conditions change, like in the case if the most negative Modifier expires, the next most negative Modifier (if one exists) then qualifies.<br><br></details><br><br><br><br>项目中的代码就是演示这种效果:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAttributeAggregatorCreated</span><span class="params">(<span class="keyword">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="keyword">const</span> override</span>;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGSAttributeSetBase::OnAttributeAggregatorCreated(<span class="keyword">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAttributeAggregatorCreated(Attribute, NewAggregator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NewAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Attribute == GetMoveSpeedAttribute())</span><br><span class="line">    &#123;</span><br><span class="line">        NewAggregator-&gt;EvaluationMetaData = &amp;FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; Your custom AggregatorEvaluateMetaData for qualifiers should be added to FAggregatorEvaluateMetaDataLibrary as static variables.<br><br>自定义的<code>AggregatorEvaluateMeteData</code>貌似还需要一些额外的操作。<br><br>### Gameplay Efffects<br>关于GE的内容实在是太多了，没有办法完全整理，集中精力去整理这些的话又要花费好多时间，而且最近也没有太多时间整理，其它的想要整理的东西就完全赶不上日程。<br><br>由于目前并没有需要使用这一部分的知识，我也是大致的了解，等到下次有机会的时候再好好进行整理和验证。<br><br>#### GameplayEffect定义<br><br><br><br>### Gameplay Abilities<br><br>#### Gameplay Ability定义<br><code>GameplayAbility</code>(GA)概括的形容就是game中<code>Actor</code>可以做什么。动作也好，技能也好都可被称为是一个GA。这一部分是C++和BP都可以实现的。<br><br>当然这些都是理想情况，一些的Action的实现也是需要随机应变的，不要迷信<code>GameplayAbility</code>的的制作，感觉可以简单实现的操作就交给GA，自己的自定义的Action有的时候也是必不可少的。关于GA我也是有一些了解了，有一些简单的内容直接就跳过了。<br><br>&gt; <code>GameplayAbilities</code> run on the owning client and/or the server depending on the <code>Net Execution Policy</code> but not <code>simulated</code> proxies.<br><br>上面这句话很重要，也就是说GA事件的触发只会在<strong>Owning Client</strong>和Server上运行，在<code>Simulated Proxy</code>上接受不到事件的触发的，这种情况下想要在<code>Simulated Proxy</code>上根据需求实现一些数据同步是不太现实的，解决方案有两种，也是最通常的方法，第一个是使用RPCs，这个不是特别推荐的。第二种方法就是使用<code>Property Replication</code>，这个是推荐的而且是UE4中使用的。(参照ASC的Pawn的SkeletalMesh的Animation的同步实现。)<br><br>GA的<code>Net Execution Policy</code>决定了GA是否可以本地预测(locally predicted)。除此之外还有默认的可选的功能：cost和cooldown GameplayEffect。<br><br>GA使用<code>AbilityTask</code>来实现一些异步操作，在之后的部分会详细介绍。<br><br>&gt;<strong>Simulated clients will not run GameplayAbilities.</strong> Instead, when the server runs the ability, anything that visually needs to play on the simulated proxies (like animation montages) will be replicated or RPC’d through <code>AbilityTasks</code> or <code>GameplayCues</code> for cosmetic things like sounds and particles.<br><br>由于GA的工作流程我已经大致了解为了节省时间我就对一些经常使用的函数不做过多介绍。<br><br><code>GameplayAbility</code>的简单流程：<br><img src="abilityflowchartsimple.png" alt="abilityflowchartsimple"><br><br><code>GameplayAbility</code>的稍微复杂的流程：<br><img src="abilityflowchartcomplex.png" alt="abilityflowchartcomplex"><br><br>##### Replication Policy<br>一句话，不要使用这个选项。<br><br>完全不需要修改，将来有可能会移除。<br><br>&gt; Don’t use this option. The name is misleading and you don’t need it. GameplayAbilitySpecs are replicated from the server to the owning client by default. As mentioned above, GameplayAbilities don’t run on simulated proxies. They use AbilityTasks and GameplayCues to replicate or RPC visual changes to the simulated proxies. Dave Ratti from Epic has stated his desire to <a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89" target="_blank" rel="noopener">remove this option in the future</a>.<br><br>##### Server Respects Remote Ability Cancellation<br>这个选项或多或少会造成一些麻烦。这个选项意思是当Client端的<code>GameplayAbility</code>执行结束(被取消或者顺利的执行完毕)的时候，是否会强制结束Server端的对应的正在执行的版本的运行。<br><br>通常情况下这个问题的来源是高延迟的玩家在进行游玩LocallyPredicted的<code>GameplayAbilities</code>的时候。但是<strong>一般情况下会禁用这个选项</strong>。<br><br>##### Replicate Input Directly<br>这个选项会把Client的Input输入的<strong>press</strong>和<strong>release</strong>事件Replicate到Server中去。<br><br>Epic不推荐使用这个选项，而是推荐使用另一种方法：如果我们把Input绑定到了ASC上，我们可以使用已经内置到<code>AbilityTask</code>中的input函数。<br><br>上面说的不是特别清楚，就是在使用了Ability的InputBind之后(把Ability的激活绑定到用户的输入上的方式)，使用AbilityTask中的有一个监听用户输入的Task，在这个项目的还是GASShooter项目的Fire部分有涉及到，我记不太清楚了，之后有时间应该会把那一部分的代码拿过来使用的。<br><br>&gt; Epic’s comment:<br>&gt;<br>&gt;<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; <span class="comment">/** Direct Input state replication. These will be called if</span></span><br><span class="line"><span class="comment">&gt; bReplicateInputDirectly is true on the ability and is generally not a good</span></span><br><span class="line"><span class="comment">&gt;  thing to use. (Instead, prefer to use Generic Replicated Events). */</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;  UAbilitySystemComponent::ServerSetInputPressed()，</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><br><br>#### 绑定输入到AbilitySystemComponent<br>ASC允许我们直接绑定用户输入到<code>GameplayAbilities</code>上，当我们绑定完毕之后检测到输入的ASC会自动帮我们激活被绑定对象的GA。被绑定的<strong>InputAction</strong>则是用到了内置的检测输入的<strong>AbilityTask</strong>。<br><br>被绑定的用户输入的动作，除了被用来激活GA，除此之外还提供了<code>Confirm</code> 和<code>Cancle</code>两种操作，这<strong>两种操作被AbilityTask用来对TargetActor进行一些操作</strong>。<br><br>为了能绑定输入到ASC上，我们首先需要制作一个枚举列表，用来把InputAction的名字转换为字节数据。枚举列表中变量的名字需要跟我们在ProjectSettings中的InputAction的变量名字保持一致。<br><br>枚举类型代码参考：<br><details><br>    <summary><mark><font color="darked">点击展开示例代码</font></mark></summary><br>    <figure class="highlight"><table><tr><td class="code"><pre><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EGDAbilityInputID</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0 None</span></span><br><span class="line">    None            UMETA(DisplayName = "None"),</span><br><span class="line">    <span class="comment">// 1 Confirm</span></span><br><span class="line">    Confirm         UMETA(DisplayName = "Confirm"),</span><br><span class="line">    <span class="comment">// 2 Cancel</span></span><br><span class="line">    Cancel          UMETA(DisplayName = "Cancel"),</span><br><span class="line">    <span class="comment">// 3 LMB</span></span><br><span class="line">    Ability1        UMETA(DisplayName = "Ability1"),</span><br><span class="line">    <span class="comment">// 4 RMB</span></span><br><span class="line">    Ability2        UMETA(DisplayName = "Ability2"),</span><br><span class="line">    <span class="comment">// 5 Q</span></span><br><span class="line">    Ability3        UMETA(DisplayName = "Ability3"),</span><br><span class="line">    <span class="comment">// 6 E</span></span><br><span class="line">    Ability4        UMETA(DisplayName = "Ability4"),</span><br><span class="line">    <span class="comment">// 7 R</span></span><br><span class="line">    Ability5        UMETA(DisplayName = "Ability5"),</span><br><span class="line">    <span class="comment">// 8 Sprint</span></span><br><span class="line">    Sprint          UMETA(DisplayName = "Sprint"),</span><br><span class="line">    <span class="comment">// 9 Jump</span></span><br><span class="line">    <span class="function">Jump            <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">"Jump"</span>)</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details><br><br><br><br>如果是将ASC放到了<strong>Character</strong>上，那么<code>SetupPlayerInputComponent</code>函数是一个很好的进行ASC的InputAction绑定的地方。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bind to AbilitySystemComponent</span></span><br><span class="line">AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(PlayerInputComponent, FGameplayAbilityInputBinds(FString(<span class="string">"ConfirmTarget"</span>), FString(<span class="string">"CancelTarget"</span>), FString(<span class="string">"EGDAbilityInputID"</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br></pre></td></tr></table></figure><br><br>如果ASC是被放到了<strong>PlayerState</strong>上，如果还是放到<code>SetupPlayerInputComponent</code>中的话就可能会发生一些问题，因为当这个函数被执行的时候，Client端的PlayerState可能还没有被复制Replicated。解决方案是除了<code>SetupPlayerInputComponent</code>这个函数之外，我们在<code>OnRep_PlayerState</code>函数中在做一次绑定，以保证绑定操作一定会被执行，当然需要我们额外添加一个布尔变量以保证我们不会二次绑定。<br><br><strong>Note:</strong><br><br>在项目中可以观察到上面的输入绑定枚举列表中的<code>Confirm</code> 和<code>Cancel</code>并没有与ProjectSettings中<code>ConfirmTarget</code>和<code>CancelTarget</code>的名字相匹配，原因是我们在<code>BindAbilityActivationToInputComponent</code>函数的参数中对其进行了匹配，当然也可以让它们互相匹配。<br><br>当然这种情况下的绑定输入，一次用户的输入只会激活其绑定的一个GA，能否绑定多个GA这个问题我没有找到解答，因此对于扩展性还是有限制的。当然，这个功能的目的就是对标MOBA类游戏的技能的Slot。我们可以尝试其它的方式获取更多的自由度，比如说在Ability添加一个变量来控制等等。<br><br>至于其他的方式，如果这种特定的场景不适合的话，还是不采用这种输入绑定的方式为好。<br><br>##### 绑定输入到ASC但是不激活GA<br>如何在使用了上面的绑定输入的方法，在使用的过程中会有接收到用户输入之后但是不想激活GA的情况。我们可以在我们的GA中添加一个控制是否自动激活的变量<code>bActivateOnInput</code>，然后override<code>UAbilitySystemComponent::AbilityLocalInputPressed()</code>函数：<br><details><br>    <summary><mark><font color="darked">点击展开代码详细</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGSAbilitySystemComponent::AbilityLocalInputPressed(int32 InputID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Consume the input if this InputID is overloaded with GenericConfirm/Cancel and the GenericConfim/Cancel callback is bound</span></span><br><span class="line">    <span class="keyword">if</span> (IsGenericConfirmInputBound(InputID))</span><br><span class="line">    &#123;</span><br><span class="line">        LocalInputConfirm();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsGenericCancelInputBound(InputID))</span><br><span class="line">    &#123;</span><br><span class="line">        LocalInputCancel();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    ABILITYLIST_SCOPE_LOCK();</span><br><span class="line">    <span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : ActivatableAbilities.Items)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Spec.InputID == InputID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Spec.Ability)</span><br><span class="line">            &#123;</span><br><span class="line">                Spec.InputPressed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (Spec.IsActive())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; IsOwnerActorAuthoritative() == <span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ServerSetInputPressed(Spec.Handle);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    AbilitySpecInputPressed(Spec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.</span></span><br><span class="line">                    InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.GetActivationPredictionKey());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UGSGameplayAbility* GA = Cast&lt;UGSGameplayAbility&gt;(Spec.Ability);</span><br><span class="line">                    <span class="keyword">if</span> (GA &amp;&amp; GA-&gt;bActivateOnInput)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Ability is not active, so try to activate it</span></span><br><span class="line">                        TryActivateAbility(Spec.Handle);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<h4 id="Granting-Abilitie"><a href="#Granting-Abilitie" class="headerlink" title="Granting Abilitie"></a>Granting Abilitie</h4><p>生成GA其实就是把GA的实例Instance放入到GAS的<code>ActivatableAbilities</code>列表中，在这个列表中的GA实例都是可以被激活的，在遇到需要的<strong>GameplayTags</strong> 或者满足其它条件之后就会被激活。</p>
<p>我们应当只在Server进行<strong>GameplayAbilities Granting</strong>，它们(确切来说是<code>GaameplayAbilitySpec</code>)会被自动的复制到它们的<strong>OwningClient</strong>中去。其他的<code>SimulatedProxy</code>不会收到对应的复制，所以说GA不会在<code>SimulatedProxy</code>上执行。</p>
<p>生成Abilities的示例代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> AGDCharacterBase::AddCharacterAbilities()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Grant abilities, but only on the server  </span></span><br><span class="line">    <span class="keyword">if</span> (Role != ROLE_Authority || !AbilitySystemComponent.IsValid() || AbilitySystemComponent-&gt;CharacterAbilitiesGiven)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TSubclassOf&lt;UGDGameplayAbility&gt;&amp; StartupAbility : CharacterAbilities)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;GiveAbility(</span><br><span class="line">            FGameplayAbilitySpec(StartupAbility, GetAbilityLevel(StartupAbility.GetDefaultObject()-&gt;AbilityID), <span class="keyword">static_cast</span>&lt;int32&gt;(StartupAbility.GetDefaultObject()-&gt;AbilityInputID), <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbilitySystemComponent-&gt;CharacterAbilitiesGiven = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就生成了可以被激活的GAs，这里面的关键的类和变量：<code>GameplayAbilitySpec</code>, <code>UGameplayAbility</code>, <code>SourceObject</code>。</p>
<h4 id="Activating-Abilities-激活"><a href="#Activating-Abilities-激活" class="headerlink" title="Activating Abilities 激活"></a>Activating Abilities 激活</h4><p>如果上面那样对ASC的输入进行了绑定，那么InputAction就会帮我们激活GA。除此之外我们还有其它四种方式来<strong>Activate Abilities</strong>，可以挑选适合自己的方式。</p>
<ul>
<li>通过<code>GameplayTag</code></li>
<li>通过<code>GameplayAbility</code>class类</li>
<li>通过<code>FGameplayAbilitySpec</code> Handle</li>
<li>通过<code>Event</code>事件来激活，这种方式还允许传递其它的自定义参数(payload)</li>
</ul>
<p><details><br>    <summary><mark><font color="darked">点击展开示例代码</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"Abilities"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilitiesByTag</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"Abilities"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilityByClass</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TriggerAbilityFromGameplayEvent</span><span class="params">(FGameplayAbilitySpecHandle AbilityToTrigger, FGameplayAbilityActorInfo* ActorInfo, FGameplayTag Tag, <span class="keyword">const</span> FGameplayEventData* Payload, UAbilitySystemComponent&amp; Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br></pre></td></tr></table></figure></details></p>
<p><br><br></p>
<p>这里需要注意的是使用Event来激活Abilities的时候，需要我们设置好<code>GameplayAbility</code>的<code>Trigger</code>。指定一个<code>GameplayTag</code>，切换成<code>GameplayEvent</code>项目，想要调用事件的时候使用<code>UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload)</code>，从参数中可以观察到，使用这种方式激活Ability允许我们传递一个<strong>Payload Data</strong>。</p>
<p>这里应该有GA的Trigger情报的照片。</p>
<p>从图片中应该可以简单的观察到，<code>GameplayTag</code>的<strong>Add/Remove</strong>操作可以用来触发GA的激活。</p>
<p><strong>Note:</strong></p>
<p>当我们在Blueprint中使用<code>GameplayAbility</code>的时候，当我们想使用Event的方式对这个BPGameplayAbility进行Activate的时候，我们需要用<code>ActivateAbilityFromEvent</code>节点来替代默认的标准的<code>ActivateAbility</code>节点，而且还需要保证与<code>ActivateAbility</code>同时存在。如果同时存在的话，会总是调用<code>ActivateAbilityFromEvent</code>节点。</p>
<p>不要忘了在GA的逻辑执行完之后调用<code>EndAbility()</code>。除非是把这个Ability作为被动技能。但是即使如此在生命周期结束前调用一下还是稳妥一些。</p>
<p>对于<strong>Locally Predicted</strong>的<code>GameplayAbility</code>来说，大概的执行流程：</p>
<p>Activation sequence for locally predicted GameplayAbilities:</p>
<ol>
<li>Owning client calls TryActivateAbility()</li>
<li>Calls InternalTryActivateAbility()</li>
<li>Calls CanActivateAbility() and returns whether GameplayTag requirements are met, if the ASC can afford the cost, if the GameplayAbility is not on cooldown, and if no other instances are currently active</li>
<li>Calls CallServerTryActivateAbility() and passes it the Prediction Key that it generates</li>
<li>Calls CallActivateAbility()</li>
<li>Calls PreActivate() Epic refers to this as “boilerplate init stuff”</li>
<li>Calls ActivateAbility() finally activating the ability</li>
</ol>
<p>Server receives CallServerTryActivateAbility()</p>
<ol>
<li>Calls ServerTryActivateAbility()</li>
<li>Calls InternalServerTryActivateAbility()</li>
<li>Calls InternalTryActivateAbility()</li>
<li>Calls CanActivateAbility() and returns whether GameplayTag requirements are met, if the ASC can afford the cost, if the GameplayAbility is not on cooldown, and if no other instances are currently active</li>
<li>Calls ClientActivateAbilitySucceed() if successful telling it to update its ActivationInfo that its activation was confirmed by the server and broadcasting the OnConfirmDelegate delegate. This is not the same as input confirmation.</li>
<li>Calls CallActivateAbility()</li>
<li>Calls PreActivate() Epic refers to this as “boilerplate init stuff”</li>
<li>Calls ActivateAbility() finally activating the ability</li>
</ol>
<p>如果Server端的GA激活失败，会调用<code>ClientActivateAbilityFailed</code>，立马中断Client的GA的执行，并且回滚任何预测的变更。</p>
<h5 id="Passive-Abilities被动"><a href="#Passive-Abilities被动" class="headerlink" title="Passive Abilities被动"></a>Passive Abilities被动</h5><p>对于如何使用GA来实现被动的效果，我们可以在<code>UGameplayAbility::OnAvatarSet()</code>函数中实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec &amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAvatarSet(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ActivateAbilityOnGranted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;TryActivateAbility(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种<strong>PassiveAbilities</strong>的<code>NetExecutionPolicy</code>通常是<strong>Server Only</strong>的。</p>
<p>Epic的评论形容<code>OnAvatarSet()</code>这个函数就类似于<code>BeginPlay()</code>。</p>
<h4 id="Canceling-Abilities取消"><a href="#Canceling-Abilities取消" class="headerlink" title="Canceling Abilities取消"></a>Canceling Abilities取消</h4><p>取消GA的执行我们可以调用<code>CancelAbility()</code>函数，这个函数会调用<code>EndAbility()</code>函数并把它的<code>WasCancelled</code>参数设置为True。</p>
<p>关于取消GA的执行，大概提供的函数(这些函数在哪个类中需要调查)：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Cancels the specified ability CDO. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbility</span><span class="params">(UGameplayAbility* Ability)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels the ability indicated by passed in spec handle. If handle is not found among reactivated abilities nothing happens. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilityHandle</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; AbilityHandle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancel all abilities with the specified tags. Will not cancel the Ignore instance */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilities</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer* WithTags=<span class="literal">nullptr</span>, <span class="keyword">const</span> FGameplayTagContainer* WithoutTags=<span class="literal">nullptr</span>, UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities regardless of tags. Will not cancel the ignore instance */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAllAbilities</span><span class="params">(UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities and kills any remaining instanced abilities */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DestroyActiveState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>Note：</strong></p>
<blockquote>
<p>I have found that CancelAllAbilities doesn’t seem to work right if you have a Non-Instanced GameplayAbilities. It seems to hit the Non-Instanced GameplayAbility and give up. CancelAbilities can handle Non-Instanced GameplayAbilities better and that is what the Sample Project uses (Jump is a non-instanced GameplayAbility). Your mileage may vary.</p>
</blockquote>
<p>关于上面的内容由于我对<strong>Non-Instanced GameplayAbility</strong>并没有涉猎，就先粘原文了。</p>
<h4 id="获取Active-Ability"><a href="#获取Active-Ability" class="headerlink" title="获取Active Ability"></a>获取Active Ability</h4><p>关于如何在运行时获取已被激活的GA，首先我们可能会需要先获取到所有的ASC上的GAs。</p>
<p>使用<code>UAbilitySystemComponent::GetActivatableAbilities()</code>函数会返回一个<code>TArray&lt;FGameplayAbilitySpec&gt;</code>类型的列表，就是我们想要的所有的GA。</p>
<p>除此之外还有一种方法就是利用<code>GameplayTagContainer</code>，也就是<code>GameplayTags</code>来筛选我们想要的GA。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UAbilitySystemComponent::GetActivatableGameplayAbilitySpecsByAllMatchingTags(<span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; struct FGameplayAbilitySpec* &gt;&amp; MatchingGameplayAbilities, <span class="keyword">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<p>想要知道具体怎么使用的话直接找源码会比较快。</p>
<p>在取到所有的GA之后，通过<code>IsActive()</code>函数来查看该GA是否已被激活。这里要注意的是<code>IsActive</code>中的并不是一个布尔值而是int值。</p>
<h4 id="Instancing-Policy"><a href="#Instancing-Policy" class="headerlink" title="Instancing Policy"></a>Instancing Policy</h4><p>GA的这个选项决定了GA被激活时的实例化操作有什么区别。<br><img src="InstancingPolicy.png" alt="InstancingPolicy"></p>
<h4 id="Net-Execution-Policy"><a href="#Net-Execution-Policy" class="headerlink" title="Net Execution Policy"></a>Net Execution Policy</h4><p>这个项目决定了GA由谁执行和执行顺序。<br><img src="NetExecutionPolicy.png" alt="NetExecutionPolicy"></p>
<h4 id="Ability-Tags"><a href="#Ability-Tags" class="headerlink" title="Ability Tags"></a>Ability Tags</h4><p>GA的内部也有内置的<code>GameplayTagContainer</code>，嘛，GA也可以对<code>GameplayTags</code>进行操作和存储就大致猜到了。虽然跟ASC一样有内置的<code>GameplayTagContainer</code>但是这里的<code>GameplayTags</code>都不会被<strong>Replicated</strong>。<br><img src="AbilityTags1.png" alt="AbilityTag01"><br><img src="AbilityTags2.png" alt="AbilityTag02"></p>
<h4 id="Gameplay-Ability-Spec"><a href="#Gameplay-Ability-Spec" class="headerlink" title="Gameplay Ability Spec"></a>Gameplay Ability Spec</h4><p>当GA被生成的时候，<code>GameplayAbilitySpec</code>便会被实例化，用来收集GA之外的情报，与其说是生成GA，本质上就是生成这个<code>GameplayAbilitySpec</code>。关于这个结构体的情报</p>
<p>这里应该有<code>GameplayAbilitySpec</code>的源码截图。</p>
<p>当一个GA在Server被生成(grant)，这个<code>GameplayAbilitySpec</code>会被生成，Server会将<code>GameplayAbilitySpec</code>复制到Replicate到<strong>OwningClient</strong>上。</p>
<p>根据<code>GameplayAbility</code>的<code>InstancingPolicy</code>，<code>GameplayAbilitySpec</code>会为其生成相应的实例或者不生成实例(Non-Instanced GA)。。</p>
<h4 id="向Ability中传递数据"><a href="#向Ability中传递数据" class="headerlink" title="向Ability中传递数据"></a>向Ability中传递数据</h4><p>Ability的使用流程一般为<code>Activate-&gt;Generate Data-&gt;Apply-&gt;End</code>，有的时候Ability的内部逻辑实现需要外部的数据，这个时候如何向Ability中传递数据就是一个问题。</p>
<p>而除了上面我们提到过的使用Event方式激活Ability可以传递<strong>Payload</strong>之外，还有其他的方法。</p>
<p><img src="PassDataToAbility.PNG" alt="PassingDatatoAbilities"></p>
<p>用的时候再理解我就不翻译了。</p>
<h4 id="Ability-Cost-and-Cooldown"><a href="#Ability-Cost-and-Cooldown" class="headerlink" title="Ability Cost and Cooldown"></a>Ability Cost and Cooldown</h4><p><code>Instant GameplayEffect</code> (<code>Cost GE</code>)和<code>Duration GameplayEffect</code>(<code>Cooldown GE</code>)，是已经内置到GA中的两种GE。顾名思义。</p>
<blockquote>
<p>Before a <code>GameplayAbility</code> calls <code>UGameplayAbility::Activate()</code>, it calls <code>UGameplayAbility::CanActivateAbility()</code>. This function checks if the owning ASC can afford the cost (<code>UGameplayAbility::CheckCost()</code>) and ensures that the <code>GameplayAbility</code> is not on cooldown (<code>UGameplayAbility::CheckCooldown()</code>).</p>
<p>After a <code>GameplayAbility</code> calls <code>Activate()</code>, it can optionally commit the cost and cooldown at any time using <code>UGameplayAbility::CommitAbility()</code> which calls <code>UGameplayAbility::CommitCost()</code> and <code>UGameplayAbility::CommitCooldown()</code>.</p>
</blockquote>
<p>关于具体实现参考GE章节。</p>
<h4 id="Ability-Sets"><a href="#Ability-Sets" class="headerlink" title="Ability Sets"></a>Ability Sets</h4><p><code>GameplayAbilitySets</code>是一个很方便的<code>UDataAsset</code>类去放置GA。</p>
<p>我没有见过这个类啊……有兴趣的话可以搜一下，不是必须要使用的类。</p>
<h4 id="Ability-Batching"><a href="#Ability-Batching" class="headerlink" title="Ability Batching"></a>Ability Batching</h4><p>一个普通的GA的生命周期在<code>Server-Client</code>之间都会产生<strong>2-3个RPCs</strong>的调用。</p>
<ol>
<li><code>CallServerTryActivateAbility()</code></li>
<li><code>ServerSetReplicatedTargetData()</code> (Optional)</li>
<li><code>ServerEndAbility()</code></li>
</ol>
<p>根据情况有的时候我们可以将这些RPCs打包至两个甚至一个RPCs中去。这就是GAS中的<code>Ability Batching</code>技术。</p>
<p>在GASShooter项目中这个技术有用到。由于我并没有用到，即使是现在想要完全把文章内容理解应该也只是表面功夫。等到真正需要使用的时候再整理，或者有时间去验证的时候再进行整理。</p>
<h4 id="Net-Security-Policy"><a href="#Net-Security-Policy" class="headerlink" title="Net Security Policy"></a>Net Security Policy</h4><p>GA的的这个选项，决定了一个Ability可以在哪个Network上执行，它可以限制一些CGA在Client上执行。<br><img src="NetSecurityPolicy.PNG" alt="NetSecurityPolicy"></p>
<h3 id="Ability-Task"><a href="#Ability-Task" class="headerlink" title="Ability Task"></a>Ability Task</h3><h4 id="Ability-Task定义"><a href="#Ability-Task定义" class="headerlink" title="Ability Task定义"></a>Ability Task定义</h4><h3 id="Gameplay-Cues"><a href="#Gameplay-Cues" class="headerlink" title="Gameplay Cues"></a>Gameplay Cues</h3><h4 id="Gameplay-Cues定义"><a href="#Gameplay-Cues定义" class="headerlink" title="Gameplay Cues定义"></a>Gameplay Cues定义</h4><h3 id="AbilitySystemGlobals"><a href="#AbilitySystemGlobals" class="headerlink" title="AbilitySystemGlobals"></a>AbilitySystemGlobals</h3><p><code>AbilitySystemGlobals</code>类保持着GAS的所有的全局信息。大多数的变量的值可以直接在<code>DefaultGame.ini</code>中进行修改。一般情况下不需要用到这个类，但是需要意识到它的存在。当需要对<code>GameplayCueManager</code>或者<code>GameplayEffectContext</code>之类的类进行继承自定义的时候，就需要这个类来做一些设定了(具体什么设定我还不清楚)。</p>
<blockquote>
<p>To subclass AbilitySystemGlobals, set the class name in the DefaultGame.ini:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt; [/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">&gt; AbilitySystemGlobalsClassName=<span class="string">"/Script/ParagonAssets.PAAbilitySystemGlobals"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="InitGlobalData"><a href="#InitGlobalData" class="headerlink" title="InitGlobalData()"></a>InitGlobalData()</h4><h3 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h3><h3 id="Targeting"><a href="#Targeting" class="headerlink" title="Targeting"></a>Targeting</h3><h4 id="Target-Data"><a href="#Target-Data" class="headerlink" title="Target Data"></a>Target Data</h4><h3 id="GAS小结"><a href="#GAS小结" class="headerlink" title="GAS小结"></a>GAS小结</h3><p>这一部分内容实在是太多，我也不想找借口，主要是时间有限，如果一直保持整理这篇文章会耗费大量时间而妨碍了其它新的东西，时常接受新的知识并进行总结也是非常重要的。</p>
<p>除了整理好的这部分内容之外还有许多我没办法一一整理，但是如果未来有机会再深入了解和使用GAS的话再这个基础上进一步的进行整理吧。</p>
<p>总之我对GAS整体上有了大概的了解，也不是之前的满头雾水，也算是一种安慰吧。</p>
<h2 id="GameplayAbilitySystem中重要的类，结构体"><a href="#GameplayAbilitySystem中重要的类，结构体" class="headerlink" title="GameplayAbilitySystem中重要的类，结构体"></a>GameplayAbilitySystem中重要的类，结构体</h2><h3 id="GameplayAbilitySpec"><a href="#GameplayAbilitySpec" class="headerlink" title="GameplayAbilitySpec"></a>GameplayAbilitySpec</h3><p>暂时先放到这里之后整理</p>
<p>我遇到了一个问题就是FGameplayAbilitySpec的SourceObject并不会replicated的问题，所以别想着在GA中尝试使用通用的SourceObject了，在Server和Client之间。</p>
<h3 id="GameplayEffect"><a href="#GameplayEffect" class="headerlink" title="GameplayEffect"></a>GameplayEffect</h3><h4 id="FGameplayEffectContext"><a href="#FGameplayEffectContext" class="headerlink" title="FGameplayEffectContext"></a>FGameplayEffectContext</h4><h4 id="FGameplayEffectContextHandle"><a href="#FGameplayEffectContextHandle" class="headerlink" title="FGameplayEffectContextHandle"></a>FGameplayEffectContextHandle</h4><h3 id="InputBind"><a href="#InputBind" class="headerlink" title="InputBind"></a>InputBind</h3><p>使用GAS的功能可以直接绑定Ability的激活到输入里，我暂时先把这个写下来之后整合到上面的内容。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line">    <span class="comment">// Called from both SetupPlayerInputComponent and OnRep_PlayerState because of a potential race condition where the PlayerController might</span></span><br><span class="line">    <span class="comment">// call ClientRestart which calls SetupPlayerInputComponent before the PlayerState is repped to the client so the PlayerState would be null in SetupPlayerInputComponent.</span></span><br><span class="line">    <span class="comment">// Conversely, the PlayerState might be repped before the PlayerController calls ClientRestart so the Actor's InputComponent would be null in OnRep_PlayerState.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BindASCInput</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::BindASCInput()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ASCInputBound &amp;&amp; AbilitySystemComponent.IsValid() &amp;&amp; IsValid(InputComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(InputComponent, FGameplayAbilityInputBinds(FString(<span class="string">"ConfirmTarget"</span>),</span><br><span class="line">        FString(<span class="string">"CancelTarget"</span>), FString(<span class="string">"EGDAbilityInputID"</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br><span class="line"></span><br><span class="line">        ASCInputBound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些小的知识点"><a href="#一些小的知识点" class="headerlink" title="一些小的知识点"></a>一些小的知识点</h2><p>这里插播几个小知识点，在C++中添加了BlueprintCallable的函数的时候，直接编译之后保持Editor的开启状态可能会不出现，在Blueprint的编辑界面还是找不到这个函数，此时需要重启UE4的Editor。</p>
<p>还有一个就是在Blueprint中调用Parent节点的内容时，需要右键该节点找到<strong>add call to parent function</strong>。</p>
<h3 id="OnAvatarSet"><a href="#OnAvatarSet" class="headerlink" title="OnAvatarSet"></a>OnAvatarSet</h3><p>GameplayAbility.h<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UCLASS(Blueprintable)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">UGameplayAbility</span> :</span> <span class="keyword">public</span> UObject, <span class="keyword">public</span> IGameplayTaskOwnerInterface</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Called when the avatar actor is set/changes */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Projects may want to initiate passives or do other "BeginPlay" type of logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是GameplayAbility自身所有的一个函数，在想要使用的时候需要对其重写。就像是对Actor的BeginPlay函数一样，对GameplayAbility来说就是OnAvatarSet函数。</p>
<p>按照这篇文章的做法就是将被动属性的GameplayAbility的激活放在了一开始，就是这个函数里面。</p>
<p>GASDocumentation/GDGameplayAbility<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GASDOCUMENTATION_API</span> <span class="title">UGDGameplayAbility</span> :</span> <span class="keyword">public</span> UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// If an ability is marked as ‘'ActivateAbilityOnGranted', activate them immediately when given here</span></span><br><span class="line">    <span class="comment">// Epic's comment: Projects may want to initiate passives or do other "BeginPlay" type of logic here.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span> override</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GASDocumentation/GDGameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAvatarSet(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ActivateAbilityOnGranted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;TryActivateAbility(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>bAllowRemoteActivation</code>标志位被设置为false，这样设置的理由我目前还没有完全搞清楚。</p>
<p>以上就是<code>OnAvatarSet</code>函数的使用理由和方法了。</p>
<h3 id="WaitDelay"><a href="#WaitDelay" class="headerlink" title="WaitDelay"></a>WaitDelay</h3><p>这次我遇到的是一个<strong>WaitDelay</strong>的BlueprintNode，这里需要注意的是要与另外一个BPNode<strong>TaskWaitDelay</strong>区分开来。</p>
<p><img src="WaitDelay.png" alt="WaitDelay"><br><img src="TaskWaitDelay.png" alt="TaskWaitDelay"></p>
<p>区别是一个是面向GameplayTask的一个是面向AbilityTask的。目前只对WaitDelay即AbilityTask的内容进行理解。</p>
<h1 id="从零开始搭建一个GAS工程"><a href="#从零开始搭建一个GAS工程" class="headerlink" title="从零开始搭建一个GAS工程"></a>从零开始搭建一个GAS工程</h1><p>这部分更新于我开始阅读并理解上面的<a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a>的三个月后，没错，我用了超过3个月的时间进行<strong>GameplayAbilitySystem</strong>的学习。甚至还只是局限于读懂而已。</p>
<p>这之间涉及了太多的UE4的框架部分的知识，我先在我构建这样一个工程的同时，同时记录下我遇见的疑难知识点，算是自我的提升和加深记忆了。</p>
<p>当然主要的还是对上面的那篇文章的实践和翻译。</p>
<h2 id="创建一个空白的项目，准备导入GAS"><a href="#创建一个空白的项目，准备导入GAS" class="headerlink" title="创建一个空白的项目，准备导入GAS"></a>创建一个空白的项目，准备导入GAS</h2><p>就如标题所说，我们创建一个空白的项目，但是在导入GAS之前我们要把框架搭好。关于UE4的MultiPlay框架在别的文章有涉及。</p>
<p>要决定好一些我之后可能要修改的配置，尽可能的创造一些基类，为扩展做一些铺垫。倒也不是尽可能的，看情况吧。</p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>首先我们要决定我们的<strong>GameMode</strong>，这里要对游戏一开始的内容做一些初始的处理，包含一些登录操作什么的，之后再展开。</p>
<p>在继承了<code>AGameModeBase</code>得到了自己的GameMode之后，新建一个blueprint继承这个GameMode，主要是为了方便在Editor上切换GamMode相关的设定。</p>
<p>在Editor主界面找到<strong>Blueprint -&gt; WorldOverride</strong> 指定我们准备好的BP_GameMode，就可以了。</p>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>至于顺序，看心情吧没有非要这样的顺序。下一个是开始我们的Pawn的制作，世界做好了得让人物动起来，也就是我们需要一个或者一些Character。</p>
<blockquote>
<p>Characters are Pawns that have a mesh, collision, and built-in movement logic.</p>
</blockquote>
<p>选自<code>ACharacter</code>类的注释，直接使用APawn也可以，是勇士了。</p>
<p>ACharacter有一个内置的SkeletalMeshComponent，还有一些关于移动的逻辑。</p>
<p>说到关于移动的逻辑那就只有<strong>CharacterMovementComponent</strong>了，但是我在<code>Character.cpp</code>中看到了<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ACharacter::ACharacter(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    CharacterMovement = CreateDefaultSubobject&lt;UCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName);</span><br><span class="line">    <span class="keyword">if</span> (CharacterMovement)</span><br><span class="line">    &#123;</span><br><span class="line">        CharacterMovement-&gt;UpdatedComponent = CapsuleComponent;</span><br><span class="line">        CrouchedEyeHeight = CharacterMovement-&gt;CrouchedHalfHeight * <span class="number">0.80f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么看都是只要继承了Character这个类的话都会有一个<code>UCharacterMovementComponent</code>的，但实际上在GASDocumentation中，又再一次生成了这个移动组件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GDCharacterBase.cpp</span></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AGDCharacterBase::AGDCharacterBase(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) :</span><br><span class="line">    Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UGDCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    GetCapsuleComponent()-&gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Overlap);</span><br><span class="line"></span><br><span class="line">    bAlwaysRelevant = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看一下好帅啊这个组件生成方法，但是这个是有其特殊用意的。</p>
<p>这个<strong>SetDefaultSubjectClass</strong>是用来做什么的呢？这个问题竟然回到了我之前一直疑惑的问题上。</p>
<h4 id="Constructor-with-or-without-FObjectInitializer"><a href="#Constructor-with-or-without-FObjectInitializer" class="headerlink" title="Constructor with or without FObjectInitializer"></a>Constructor with or without FObjectInitializer</h4><p>关于UE4中C++的构造函数的问题，我们有三种方式来实现UE4中的构造函数</p>
<ul>
<li>不声明构造函数</li>
<li>声明一个无参的默认构造函数</li>
<li>声明一个<code>FObjectInitializer</code>参数的构造函数</li>
</ul>
<p>写法网上一搜都有，说不定我哪篇文章也写过。</p>
<p>第一种是UE4的<code>GENERATED_BODY()</code>宏会生成构造函数，即使不特意的声明也没有问题。貌似生成的Constructor会存在与<code>XXX.generated.h</code>文件中。</p>
<p>第二种则是我经常用的方式，毕竟还多几行代码，看起来好看，也是最常规最常见的。</p>
<p>第三种，要在什么情况下使用呢？</p>
<blockquote>
<p>as long you dont have to replace any base component (such as replacing the MovementComponent class) that basic constructor works just fine if you don’t use the GENERATED_CLASS_BODY() macro. (using GENERATED_BODY() instead).</p>
</blockquote>
<p>来自问题<a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/97550-constructor-with-or-without-fobjectinitializer" target="_blank" rel="noopener">Constructor with or without FObjectInitializer</a></p>
<p>大意就是说在没有<strong>替换组件例如MovementComponent</strong>的时候，第二种构造函数没有问题。</p>
<p>所以就引出了这一小节的主角</p>
<h4 id="ObjectInitializer控制组件生成"><a href="#ObjectInitializer控制组件生成" class="headerlink" title="ObjectInitializer控制组件生成"></a>ObjectInitializer控制组件生成</h4><p>也就是这篇<a href="https://historia.co.jp/archives/6587/" target="_blank" rel="noopener">UE4 ObjectInitializerでコンポーネント生成を制御する</a></p>
<p>关于宏生成构造函数的解说在上面的文章很详细，我也是：啊啊，好像是那样。</p>
<p>那么什么情况下我们非要使用带有<strong>ObjectInitializer</strong>的构造函数不可呢？</p>
<p>与其相关的最常见到的就是<code>CreateDefaultSubobject</code>这个函数了。在Constructor中生成Component。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">USceneComponent* SceneComponent = ObjectInitializer.CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>想用这招的话，看起来好像非这种构造函数不可了，但实际上：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">USceneComponent* SceneComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这种写法也是对的，因为UObject为其提供了同名的包装方法(wrap function)。</p>
<p>所以只有这个<strong>CreateDefaultSubobject</strong>也不是一定要用第三种构造函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateEditorOnlyDefaultSubobject</td>
<td>エディタのみで有効なコンポーネントを作成する</td>
</tr>
<tr>
<td>CreateOptionalDefaultSubobject</td>
<td>作られなくても良い（動作には必ずしも必要無い）コンポーネントを作成する※ これは後述する関数と組み合わせて利用します</td>
</tr>
<tr>
<td>CreateAbstractDefaultSubobject</td>
<td>Abstract 属性のクラスは CreateDefaultSubobject を使うと作成できないようになっているので、必要な場合は明示的にこの関数を利用する</td>
</tr>
</tbody>
</table>
<p>上面的函数的使用对于ObjectInitializer的需要都不是必须的，但是除了这些之外的，就要了。</p>
<blockquote>
<p>これらのみを利用する場合は ObjectInitializer を利用する必要性はありません。</p>
<p>逆に言えば、<strong>これら以外の ObjectInitializer が提供するAPIを利用したい時は引数に与える必要性がある</strong> ということです。</p>
<p>UObject でラップされていない、ObjectInitializer が提供する関数は以下のものがあります。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SetDefaultSubobjectClass</td>
<td>親クラスがコンポーネントを作成する時、そのコンポーネントのクラスを名前指定で上書きする <br>※ 親クラスが作成するコンポーネントから派生したコンポーネントのみが指定できます</td>
</tr>
<tr>
<td>DoNotCreateDefaultSubobject</td>
<td>CreateOptionalDefaultSubobject でコンポーネントを作成する時、名前指定でコンポーネントの作成を無効化できる</td>
</tr>
</tbody>
</table>
<p>其中尤为重要的就是<strong>SetDefaultSubobjectClass</strong>,最常用的例子就是<code>UCharacterMovementComponent</code>是ACharacter默认提供的功能，如果我们想为其提供自定义的MovementComponent，那就使用这个函数，覆盖ACharacter提供的默认的移动组件。</p>
<p>至于怎么用，就像上面那么用。</p>
<blockquote>
<p>ちなみに SetDefaultSubobjectClass 及び DoNotCreateDefaultSubobject の戻り値は FObjectInitializer のコピーなので、メソッドチェーンで記述することが可能です。</p>
</blockquote>
<p>呃，这个意思不太懂。</p>
<h4 id="Camera组件"><a href="#Camera组件" class="headerlink" title="Camera组件"></a>Camera组件</h4><p>接下来是要为我们的Character添加摄像机，一个是<strong>CameraComponent</strong>，另一个是<strong>SpringArmComponent</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AGDHeroCharacter::AGDHeroCharacter(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(FName(<span class="string">"CameraBoom"</span>));</span><br><span class="line">    CameraBoom-&gt;SetupAttachment(RootComponent);</span><br><span class="line">    CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">    CameraBoom-&gt;SetRelativeLocation(FVector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">68.492264</span>));</span><br><span class="line"></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(FName(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom);</span><br><span class="line">    FollowCamera-&gt;FieldOfView = <span class="number">80.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现就像上面那样，别问我为什么要那么实现，我也不知道。</p>
<h5 id="SpringArmComponent"><a href="#SpringArmComponent" class="headerlink" title="SpringArmComponent"></a>SpringArmComponent</h5><p>相机臂组件，是我之前一直忽略的组件，但是最近一点点觉得可能这个组件很重要。因为大多数的3D游戏对镜头的操纵极为重要，流畅华丽的镜头切换是会让人心情舒畅的。</p>
<p>但是我不知道那些游戏里镜头的移动是否是依赖于这个组件…</p>
<p>默认的情况下CameraBoom（上面的SpringArmComponent）是有碰撞判定的，即相机和Character之间有物体的话会缩短相机臂的距离，如果不想要这个功能的话</p>
<p>接上面的代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// これだけでカメラの当たり判定が無効になる</span></span><br><span class="line">  CameraBoom-&gt;bDoCollisionTest = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似可以实现一些物体加速的相机追踪延迟的效果，但是要是想实现更丰富的镜头切换应该需要更多的自定义。</p>
<p>暂时先挖个坑。</p>
<h4 id="SetupPlayerInputComponent"><a href="#SetupPlayerInputComponent" class="headerlink" title="SetupPlayerInputComponent"></a>SetupPlayerInputComponent</h4><p>用来设置键位的组件，需要override这个函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">    <span class="comment">// Called to bind functionality to input</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">    Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveForward"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveRight"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUp"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUp);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUpRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUpRate);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"Turn"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::Turn);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"TurnRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::TurnRate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind player input to the AbilitySystemComponent. Also called in OnRep_PlayerState because of a potential race condition.</span></span><br><span class="line">    BindASCInput();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUp(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUpRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value * BaseLookUpRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::Turn(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::TurnRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value * BaseTurnRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveForward(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetForwardVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveRight(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetRightVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我就粘贴上大概的实现，反正要找的话都能找到。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>ActionRPG</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp-Attribute的理解与使用</title>
    <url>/csharp-attribute/</url>
    <content><![CDATA[<p>这次要学习的是CSharp中的属性(Attribute)，经常听见，也在Unity中使用过，却不知其为何物。<strong>属性</strong>是能够为类或者成员添加额外的信息的东西。</p>
<a id="more"></a>
<p>首先是入门文章的链接：</p>
<ul>
<li><a href="https://ufcpp.net/study/csharp/sp_attribute.html" target="_blank" rel="noopener">属性</a></li>
</ul>
<p>总结加上自己的实现，也可以说是汉化？这篇文章的最后更新是2011年，比较老了，还是要自己检验一下，而且还加深记忆。</p>
<h1 id="属性-attribute-是什么"><a href="#属性-attribute-是什么" class="headerlink" title="属性(attribute)是什么"></a>属性(attribute)是什么</h1><p><strong>属性</strong>是用来为类或者成员添加额外信息的一种东西。像是类中的修饰符<code>public</code>,<code>private</code>都可以视为一种属性。</p>
<p>对于C++来说，像这种为类或成员添加额外信息的情况，需要我们对C++这门语言进行扩展，重新定义编译器。但是CSharp就不需要这么麻烦。也就是说，通过使用库中提供的属性，又或者是自己添加的属性，对编译器发出指令，可以留下使用者想要留下的信息。</p>
<blockquote>
<p>C++ などの既存の言語では、このような追加情報を定義する場合、 言語仕様自体を拡張し、新たにコンパイラを作り直す必要がありました。 それに対し、C# では自分で属性を定義し、クラスやメンバーに付加することが出来ます。 すなわち、ライブラリで提供されている属性や自作した属性を用いることで、 コンパイラに対する指示を行ったり、クラスの利用者に対する情報を残すことが出来ます。</p>
</blockquote>
<p>使用属性的场合：</p>
<ul>
<li>条件分支编译，向编译器发出指令的时候使用（Conditional和Obsolete等）</li>
<li>作者的信息以<em>meta data</em>的形式插入到程序当中（AssemblyTitle等）</li>
<li>利用<strong>反射</strong>，程序运行时取出想要的属性情报</li>
</ul>
<p>Point：</p>
<ul>
<li>CSharp的话，可以自由的为类或者成员添加自定义的属性。</li>
<li>一部分的属性，可以作为对编译器或者VisualStudio发出指令的方式使用。<ul>
<li>[Obsolete] class OldClass {} … 古いバージョンとの互換性のためだけに残してるけど、このクラスはもう使わないで。</li>
<li>[EditorBrowsable] T Property; … Visual Studio の IntelliSense（などの、開発ツールの補完機能）で表示するかどうかを設定します。</li>
</ul>
</li>
</ul>
<p>上面的两个例子我不太理解，遇见再说吧。</p>
<h2 id="属性的使用"><a href="#属性的使用" class="headerlink" title="属性的使用"></a>属性的使用</h2><p>使用<code>[]</code>来为类或成员添加属性<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">属性名(属性パラメータ)</span>]</span><br><span class="line">メンバーの定義</span><br></pre></td></tr></table></figure></p>
<p>属性名的最后要以<code>Attribute</code>结尾，就像既存的<code>ObsoleteAttribute</code>,<code>ConditionalAttribute</code>那样。但是在CSharp中使用的情况，省略掉也没有关系，<code>Obsolete</code>,<code>Conditional</code>这样也是可以在CSharp中使用的。</p>
<p><span style:color="red">暂时先整理到这里，其它的地方积压的有些多了。之后再回来整理。</span></p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的CSharp</title>
    <url>/csharp-in-unity/</url>
    <content><![CDATA[<p>跟CSharp打交道也很久了，但是有很多的东西我都从来未接触过，甚至是一些比较基础的用法我都不知道。这篇文章虽然带有Unity，但主要还是为了记录CSharp的使用，嘛，毕竟我主要的CSharp的使用场景就是Unity。</p>
<a id="more"></a>
<p>在另外的一篇文章，<strong>Unity知识点记录</strong>中也有一些零星的CSharp使用的记载，但是Unity相关的内容比较多。</p>
<h3 id="C-的一些基础用法"><a href="#C-的一些基础用法" class="headerlink" title="C#的一些基础用法"></a>C#的一些基础用法</h3><h4 id="函数传参时new一个参数"><a href="#函数传参时new一个参数" class="headerlink" title="函数传参时new一个参数"></a>函数传参时new一个参数</h4><p>函数传参的时候，这个参数未必是上面已经预备好的，而是想要一个新的参数或者类，</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sample code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Data</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    flaot b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data data = <span class="keyword">new</span> Data();</span><br><span class="line">    SampleFunction(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种最常见的用法。但是当我们<code>Data</code>的类并未提前预备好，我们就必须new一个。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SampleFunction(<span class="keyword">new</span> Data());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么这里问题又来了，我们想new一个Data类之后顺便还想把变量值加入，这个时候想到的就是为Data类添加一个构造函数。</p>
<p>但是实际上我读大佬的代码的时候，就不需要：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SampleFunction(<span class="keyword">new</span> Data()&#123; a = sample_a, b = sample_b&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就不需要额外创建一个构造函数了，说实话，这应该是非常基础的用法，但是我完全没有印象，就连写的途中，变量赋值之间用的是逗号而不是分号而纠结了一会儿，还以为是VS中的自动补齐工具出问题了。</p>
<p>记住，应该会经常使用的，很方便的写法。感觉有时间需要了解一下这个写法的机制。</p>
<p><span style="color:red">重温了这篇文章发现自己最近刚好用到这个地方，但是很巧我就没有这么用，还是傻傻的创建了构造函数，我真是最近散漫惯了。</span></p>
<h4 id="获取一个枚举类型里的所有类型"><a href="#获取一个枚举类型里的所有类型" class="headerlink" title="获取一个枚举类型里的所有类型"></a>获取一个枚举类型里的所有类型</h4><p>需求就是像标题所说，至于为什么要这么做，就应该会有很多理由，比如用枚举设定事件类型的时候想要知道这些类型有那些或者有多少。</p>
<p>就用<code>Enum.GetNames(Type)</code>这个函数来获取。</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.enum.getnames?view=netframework-4.8" target="_blank" rel="noopener">Enum.GetNames(Type) 方法</a></li>
</ul>
<p>但其实这里还有更重要的地方，那就是CSharp中的<strong>属性</strong>，在别的文章中更详细的展开了，这里想只贴上实现的代码，以供日后参考。</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>csharp</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-DOTS学习记录</title>
    <url>/unity-dots/</url>
    <content><![CDATA[<p>DOTS(Data Oriented Technology Stack)，Unity推出的一个新的Unity内核，个人的理解就是一种个以往的Unity完全不同的方式去制作内容。其代价就是不是那么好理解，但是带来了更高的性能（我也不知道）。</p>
<a id="more"></a>
<ul>
<li><a href="https://unity.com/dots" target="_blank" rel="noopener">Performance by default</a></li>
</ul>
<p>什是DOTS，先看官网，然后看Forums</p>
<ul>
<li><a href="https://forum.unity.com/forums/data-oriented-technology-stack.147/" target="_blank" rel="noopener">Data Oriented Technology Stack</a></li>
</ul>
<h1 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h1><ul>
<li><a href="https://blogs.unity3d.com/cn/2019/02/26/on-dots-c-c/" target="_blank" rel="noopener">On DOTS: C++ &amp; C#</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>DOTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-ECS从入门到关门</title>
    <url>/unity-entity-component-system/</url>
    <content><![CDATA[<p>ECS(Entity Component System)是<strong>Unity Data Oriented Tech Stack</strong>的一部分，是其默认的高性能编码方式。</p>
<a id="more"></a>
<p>也就是我经常看到的那个DOTS的一部分啦，其他部分的话暂时先不管（有点管不过来），这东西完全是一个新的概念，或者说试图用以前的Unity的GameObject，MonoBehavior的概念去理解的话，就会掉坑里，完全不知所云。拿面向对象的思想去套貌似也会吃点亏，当然我还没到这个地步只是听说的。</p>
<h1 id="Entity-Component-System"><a href="#Entity-Component-System" class="headerlink" title="Entity Component System"></a>Entity Component System</h1><ul>
<li><a href="https://docs.unity3d.com/Packages/com.unity.entities@0.5/manual/index.html" target="_blank" rel="noopener">Entity Component System</a><blockquote>
<p>The Entity Component System (ECS) is the core of the Unity Data-Oriented Tech Stack. As the name indicates, ECS has three principal parts:</p>
<ul>
<li>Entities — the entities, or things, that populate your game or program.</li>
<li>Components — the data associated with your entities, but organized by the data itself rather than by entity. (This difference in organization is one of the key differences between an object-oriented and a data-oriented design.)</li>
<li>Systems — the logic that transforms the component data from its current state to its next state— for example, a system might update the positions of all moving entities by their velocity times the time interval since the previous frame.</li>
</ul>
</blockquote>
</li>
</ul>
<p>如何理解这个概念？看上面的英文。如果想要细致的理解，我觉得上面那个链接的内容都要看。</p>
<h1 id="EntityComponentSystem-Samples"><a href="#EntityComponentSystem-Samples" class="headerlink" title="EntityComponentSystem Samples"></a>EntityComponentSystem Samples</h1><ul>
<li><a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples" target="_blank" rel="noopener">EntityComponentSystemSamples</a></li>
</ul>
<p>官方的GitHub例子，可以用来观摩学习。</p>
<h1 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h1><p>关于ECS的博文有一些很重要，或者说我是读了这些博文才逐渐能理解ECS的。</p>
<ul>
<li><a href="https://gametorrahod.com/world-system-groups-update-order-and-the-player-loop/" target="_blank" rel="noopener">World, system groups, update order, and the player loop</a></li>
</ul>
<p>这里讲到了我在UniRx文章中提到的PlayerLoop的内容，有时间整理一下。</p>
<ul>
<li><a href="https://blogs.unity3d.com/2019/03/08/on-dots-entity-component-system/" target="_blank" rel="noopener">On DOTS: Entity Component System</a></li>
</ul>
<p>Unity Blog中的一篇文章，我觉得Unity的官方博客里面有好多非常好的文章，时常关注一下没有坏处（我得看啊）。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏中的渲染</title>
    <url>/rendering-in-the-development-of-the-game/</url>
    <content><![CDATA[<p>游戏中的渲染是一个很大的概念，以至于我都不知道该怎么分类。于是便将其制作成了一个分类。因为在游戏的制作过程中关于渲染的知识无处不在，我在优化游戏的部分也记录了很多关于渲染流程的部分，但还是不够。</p>
<a id="more"></a>
<p>关于渲染，我所理解的是：</p>
<ul>
<li>了解渲染流程</li>
<li>和渲染相关的技术</li>
<li>优化渲染</li>
</ul>
<p>我知道上面的肯定不是准确的，暂时先记着。</p>
<h2 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h2><p>我在最适化的文章中有提到一些渲染流程的知识，但是那只是非常宽泛的概念具体做了哪些事情不去实现一遍渲染流程我应该是不会了解的。更加具体的内容我也只能一点点更新了。好了废话就说到这里了，之后关于渲染的相关内容就整理到这篇文章里。</p>
<h3 id="渲染网格"><a href="#渲染网格" class="headerlink" title="渲染网格"></a>渲染网格</h3><p>创建这篇文章的初衷就是为了这篇文章：</p>
<ul>
<li><a href="https://software.intel.com/zh-cn/articles/model-for-real-time-beyond-counting-polygons" target="_blank" rel="noopener">实时模型 — 超越多边形计算</a></li>
</ul>
<p>这里面有提到GPU处理多边形数据的内容</p>
<ul>
<li>多边形数据存储</li>
<li>绘制多边形<ul>
<li>这里有些在意的是<strong>动画处理</strong>的时候顶点着色器的动作是什么样的</li>
</ul>
</li>
<li>顶点缓存</li>
<li>顶点参数<ul>
<li>这里的内容不是特别明确，主要是使用的场合有什么区别<blockquote>
<p>为了准确照亮表面，通常每个顶点都存储一条法线，即从表面向外指出的一个矢量。让所有多边形共享一个由同一条法线定义的顶点，可以使形状看起来非常平滑。这便是所谓的平滑着色。如果每个三角形都有自己的法线，那么多边形之间的边缘将凹凸不平，而表面光滑平坦，这就是它为什么被称作平面着色。</p>
</blockquote>
</li>
</ul>
</li>
<li>评估形状<ul>
<li>感觉之前在哪篇文章中有读到过，GPU并不是单个的像素一个一个处理，而是一块一块的像素进行处理，也就是说这个一块里面未必会全是我们想要绘制的，优化网格的形状，尽可能避免长而细的网格会有效降低GPU绘制资源的浪费。<blockquote>
<p>GPU 的速度很快，主要因为它能并行执行许多操作。GPU 营销材料通常强调它们拥有的管道数量，这决定了 GPU 所能同时执行的操作量。GPU 绘制多边形时，它会分配许多管道来填充一方块像素。通常是维度大约为 8 × 8 像素的一个四方形。GPU 持续执行直至填满所有像素。显然，三角形不是四方形，因此四方形中的部分像素位于三角形内部，部分像素位于三角形外部。硬件将分配给四方形中的所有像素，甚至是哪些落在多边形外部的像素。计算完四方形中的所有顶点后，硬件就会舍弃三角形外部的像素。</p>
</blockquote>
</li>
</ul>
</li>
<li>过度绘制<ul>
<li>场景中不可避免的出现一些重复绘制，比如说有遮挡的部分的片元在大多数无意识的情况下被绘制两次甚至更多次，在这片元的位置遮挡物与被遮挡物没有意识的情况下都会被绘制一遍。<blockquote>
<p>一些引擎采用高级算法以避免绘制最终图像中所没有的对象，但非常困难。相比 GPU 进行绘制，CPU 通常需要更长的时间来确定不需要绘制的内容。<br>一些情况下我们想要删除被遮挡的部分的网格（比如说两个静态模型重合的部分），但是这个时候有需要我们的判断，因为<strong>减少多边形换取部分过度绘制和添加多边形避免过度绘制，在时间的维度上总是此消彼长的关系。</strong><br>在这类场景中，您需要执行判断调用。有时候值得通过减少多边形来换取部分过度绘制。有时候值得添加多边形以避免过度绘制。<br>出现各种情况也只能具体问题具体分析。</p>
</blockquote>
</li>
</ul>
</li>
<li>使用绘制调用（DrawCall）<ul>
<li>这里我发现了一个我之前从未注意到的问题：<em>CPU每帧能发出多少DrawCall命令？GPU每帧能处理多少多边形？</em>在固定帧数的情况下，那么每一帧的时间是固定的，如果在这一帧固定时间里，GPU能够胜任CPU的绘制调用，那么为网格增加多边形数量就是免费的。反之同理。<blockquote>
<p>GPU 的速度非常快，CPU 很难跟上它们。由于 GPU 基本上只执行一项操作，因此它们更容易加快执行速度。显卡，顾名思义，就是计算多个像素，因此能够构建并行计算许多像素的硬件。但 GPU 仅调用 CPU 让其绘制的内容。如果 CPU 不能快速反馈 GPU，GPU 就会闲置。每次 CPU 让 GPU 绘制某一内容就称为绘制调用。<strong>基本绘制调用包括绘制一个网格，包含一个着色器和一组纹理</strong>。<br>绘制调用的构成及其成本可能因引擎和架构的不同而有很大差异。有些引擎能够以单次绘制调用的形式批处理许多网格，但所有网格都需要有相同的着色器或满足其他限制条件。Vulkan<em>、DirectX</em> 12 等新 KPI 经过专门设计，可通过优化程序与显卡驱动程序之间的通信来解决这一问题，从而增加每帧发出的绘制调用数量。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Rendering</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>rendering</tag>
      </tags>
  </entry>
  <entry>
    <title>看起来很厉害的文章</title>
    <url>/some-articles/</url>
    <content><![CDATA[<p>公司大佬分享的一篇文章，看起来很厉害，实际上肯定也很厉害，但我应该是看不懂的，关掉又很可惜，先记下来，万一哪天能看懂了呢。</p>
<a id="more"></a>
<h1 id="更新履历"><a href="#更新履历" class="headerlink" title="更新履历"></a>更新履历</h1><ul>
<li>2020/01/25 添加<a href="https://arstechnica.com/gaming/2019/10/explaining-how-fighting-games-use-delay-based-and-rollback-netcode/" target="_blank" rel="noopener">Explaining how fighting games use delay-based and rollback netcode</a>文章</li>
</ul>
<p>感觉可以整理成一个文章链接的合集，那些我想看但是看不懂的那种</p>
<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul>
<li><a href="https://arstechnica.com/gaming/2019/10/explaining-how-fighting-games-use-delay-based-and-rollback-netcode/" target="_blank" rel="noopener">Explaining how fighting games use delay-based and rollback netcode</a></li>
</ul>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-DeferredDecal的使用和理解</title>
    <url>/ue4-how-to-use-deferred-decal/</url>
    <content><![CDATA[<p>这次说一下UE4中的Decal的特效，我是没有遇到要我自己写Decal相关特效的任务的，只是觉得知道为好。</p>
<a id="more"></a>
<p>这个是Deferred Decal是UE4中的功能，我最先是在尝试优化程序的过程中了解到这个概念的，优化的部分在另一篇<a href>UE4-Performance提升–Forced by DBuffer</a>的部分总有提到。</p>
<h1 id="Deferred-Decal"><a href="#Deferred-Decal" class="headerlink" title="Deferred Decal"></a>Deferred Decal</h1><ul>
<li><a href="http://monsho.blog63.fc2.com/blog-entry-139.html" target="_blank" rel="noopener">UE4 Deferred Decal</a></li>
</ul>
<h2 id="更新履历"><a href="#更新履历" class="headerlink" title="更新履历"></a>更新履历</h2><ul>
<li>2020/01/23 最近实在是重心想要放在Unity上，UE4的内容手头又没有电脑能够验证，所以文章的更新暂时先搁置一下，就是鸽一下。</li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Rendering</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN使用中的问题记录</title>
    <url>/how-to-use-vpn/</url>
    <content><![CDATA[<p>最近回国有点需要便购买了VPN的服务，这篇文章目的是为了记录我使用VPN的过程中遇到的一些问题，应该以后也会频繁用到做个备忘，以应付一些相似的问题。</p>
<a id="more"></a>
<h2 id="VPN选择"><a href="#VPN选择" class="headerlink" title="VPN选择"></a>VPN选择</h2><p><strong>千针网络</strong></p>
<p>感觉是灰色地带就不介绍太多，只是做个备忘。</p>
<h2 id="Git设定"><a href="#Git设定" class="headerlink" title="Git设定"></a>Git设定</h2><p>在设置好了VPN之后，准备打开GitHub遇见了打不开登录界面的问题，这就很难受了，本来主要的目的就是为了使用GitHub。</p>
<h3 id="GitHub网页登录"><a href="#GitHub网页登录" class="headerlink" title="GitHub网页登录"></a>GitHub网页登录</h3><p>打不开GitHub，明明已经设置好了，谷歌也好youtube也好都能打开，GitHub就是打不开。后来才解决。</p>
<p>需要打开VPN代理的<strong>全局模式(Global Mode)</strong>，这样就可以了。</p>
<p>但是这个模式估计是所有的网站都要跑流量的但是我不确定，注意一下为好。</p>
<h3 id="GitHub命令行远程连接"><a href="#GitHub命令行远程连接" class="headerlink" title="GitHub命令行远程连接"></a>GitHub命令行远程连接</h3><p>还有就是使用VPN的话命令行那里也是不能直接和GitHub通信的，不能push不能pull，需要为Git设置代理。</p>
<p><strong>设置全局代理</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:1087</span><br></pre></td></tr></table></figure></p>
<p><strong>查看全局代理</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy</span><br></pre></td></tr></table></figure></p>
<p><strong>取消全局代理</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br></pre></td></tr></table></figure></p>
<p>代理地址和端口依设定而异，反正就是那个意思。</p>
<p>估计到我回日本的时候需要执行取消全局代理的操作。</p>
<p>还有<strong>本地</strong>和<strong>全局</strong>的区分，但是也就是把<code>--global</code>换成<code>--local</code>的区别。</p>
<h2 id="其它遇到的问题"><a href="#其它遇到的问题" class="headerlink" title="其它遇到的问题"></a>其它遇到的问题</h2><h3 id="vim-markdown"><a href="#vim-markdown" class="headerlink" title="vim-markdown"></a>vim-markdown</h3><p>我之前有设置过MarkdownPreview类似的预览插件，在用Vim打开一个MD扩展文件的时候就会自动打开浏览器页面预览，但是当我使用VPN的时候，预览页面就加载不出来了，貌似是端口被占用？我想查一下但是忘了之前使用什么设置的这个插件，也不知道怎么修改预览的端口号，反正关了VPN就好用了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title>VR-脚步声检测功能实现</title>
    <url>/vr-footstep-detection/</url>
    <content><![CDATA[<p>也算是业务相关吧，业务要求要只用HMD(Head Mounted Display, 这里就是VR头戴设备)检测脚步声，这里我根据公司前辈的工作内容进行了一些改良，主要是利用VR设备移动的时候的前后上下的加速度和速度来判定脚步。准确率正常情况下有90%以上吧。</p>
<a id="more"></a>
<p>对源码进行改良，我主要的灵感来源是这篇文章</p>
<ul>
<li><a href="https://techbrood.com/zh/news/css3/css3%E5%8A%A8%E7%94%BB%EF%BC%9A%E4%BA%BA%E8%A1%8C%E8%B5%B0%E5%8A%A8%E4%BD%9C%E5%9B%BE%E8%A7%A3_2.html" target="_blank" rel="noopener">CSS3人行走动作图解和动画实现</a></li>
</ul>
<p>根据这种分解的例子找到判定的条件。</p>
<p><del>代码实现的话有时间贴上，并说明。</del></p>
<h1 id="检测实现"><a href="#检测实现" class="headerlink" title="检测实现"></a>检测实现</h1><p>算是我在公司制作的骚东西吧，就成品的结果来看还是可以的，但是总觉得有那么一丝丝不足。</p>
<ul>
<li>首先是当玩家快速移动的时候,检测精度就大幅度下降，有多大幅度呢？就是接近0，但是这个快速移动吧，就是跑的飞快的那种，倒也还好。</li>
<li>在里面还加入了左右检测的功能，在头朝前移动左右的判定倒也准确，就是扭头状态下移动的时候多少会有些不准确。</li>
<li>再就是检测的延迟感，虽说体感上不明显，但是意识到的我自己总觉得检测的时机有些”粘稠感”。</li>
</ul>
<p>下面先贴上代码实现。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HMDMoveFootsteps</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> ILogger logger = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> precisionIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> YMoveThreshold = <span class="number">-0.00075</span>f;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> ZXMoveThreshold = <span class="number">0.00425</span>f;</span><br><span class="line">        <span class="keyword">int</span> SENum = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> lastSEIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> RecordNum = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> AveRecordNum = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> onceEnter = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> onceEnterCounter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> prevFlag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> playOrder = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Detect footstep one time, and reset before next time</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> oneStep = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> stepCD = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> stepEnter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For FootCheckBeta</span></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">bool</span> Mute = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> sampleDataCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> accelerateThreshold</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> highAccelerateThreshold / (precisionIndex + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> speedYThreshold</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> highSpeedYThreshold / (precisionIndex + <span class="number">1</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> speedXZThreshold</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> highSpeedXZThreshold / (precisionIndex + <span class="number">1</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> highAccelerateThreshold = <span class="number">0.2</span>f;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> highSpeedYThreshold = <span class="number">0.02</span>f;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">float</span> highSpeedXZThreshold = <span class="number">0.01</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesDataY;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesDataZ;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesDataX;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesDeltaTime;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesYSpeed;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesZSpeed;</span><br><span class="line">        <span class="keyword">private</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt; preFramesXSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> EventFootstepTrigger _LeftEventFootstepTrigger;</span><br><span class="line">        <span class="keyword">private</span> EventFootstepTrigger LeftEventFootstepTrigger</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _LeftEventFootstepTrigger ?? (_LeftEventFootstepTrigger = AvatarManager.OwnerAvatar.LeftEventFootstepTrigger);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> EventFootstepTrigger _RightEventFootstepTrigger;</span><br><span class="line">        <span class="keyword">private</span> EventFootstepTrigger RightEventFootstepTrigger</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> _RightEventFootstepTrigger ?? (_RightEventFootstepTrigger = AvatarManager.OwnerAvatar.RightEventFootstepTrigger);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use this for initialization</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            preFramesDataY = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesDataZ = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesDataX = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesDeltaTime = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesYSpeed = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesZSpeed = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            preFramesXSpeed = <span class="keyword">new</span> Unity.Collections.NativeArray&lt;<span class="keyword">float</span>&gt;(sampleDataCount, Unity.Collections.Allocator.Persistent);</span><br><span class="line">            <span class="comment">// Initialization?</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            preFramesDataY.Dispose();</span><br><span class="line">            preFramesDataZ.Dispose();</span><br><span class="line">            preFramesDataX.Dispose();</span><br><span class="line">            preFramesDeltaTime.Dispose();</span><br><span class="line">            preFramesYSpeed.Dispose();</span><br><span class="line">            preFramesZSpeed.Dispose();</span><br><span class="line">            preFramesXSpeed.Dispose();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update is called once per frame</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Mute) <span class="keyword">return</span>;</span><br><span class="line">            FootCheckVerBeta();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">FootCheckVerBeta</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = sampleDataCount - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                preFramesDataY[i] = preFramesDataY[i - <span class="number">1</span>];</span><br><span class="line">                preFramesDataZ[i] = preFramesDataZ[i - <span class="number">1</span>];</span><br><span class="line">                preFramesDataX[i] = preFramesDataX[i - <span class="number">1</span>];</span><br><span class="line">                preFramesDeltaTime[i] = preFramesDeltaTime[i - <span class="number">1</span>];</span><br><span class="line">                preFramesYSpeed[i] = preFramesYSpeed[i - <span class="number">1</span>];</span><br><span class="line">                preFramesZSpeed[i] = preFramesZSpeed[i - <span class="number">1</span>];</span><br><span class="line">                preFramesXSpeed[i] = preFramesXSpeed[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> pos = StageController.PlayerCamera.transform.position;</span><br><span class="line">            preFramesDataY[<span class="number">0</span>] = pos.y;</span><br><span class="line">            preFramesDataZ[<span class="number">0</span>] = pos.z;</span><br><span class="line">            preFramesDataX[<span class="number">0</span>] = pos.x;</span><br><span class="line">            preFramesDeltaTime[<span class="number">0</span>] = Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> sumY = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">float</span> sumZ = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">float</span> sumX = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">float</span> sumTime = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; sampleDataCount <span class="number">-2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sumY += (preFramesDataY[j] - preFramesDataY[j + <span class="number">1</span>]);</span><br><span class="line">                sumZ += (preFramesDataZ[j] - preFramesDataZ[j + <span class="number">1</span>]);</span><br><span class="line">                sumX += (preFramesDataX[j] - preFramesDataX[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; sampleDataCount<span class="number">-1</span>; m++)</span><br><span class="line">            &#123;</span><br><span class="line">                sumTime += preFramesDeltaTime[m];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Y axis movement speed</span></span><br><span class="line">            preFramesYSpeed[<span class="number">0</span>] = sumY / sumTime;</span><br><span class="line"></span><br><span class="line">            preFramesZSpeed[<span class="number">0</span>] = sumZ / sumTime;</span><br><span class="line">            preFramesXSpeed[<span class="number">0</span>] = sumX / sumTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> sumSpeed = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; sampleDataCount<span class="number">-2</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                sumSpeed += (preFramesYSpeed[k] - preFramesYSpeed[k + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> acceleration = sumSpeed / sumTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> preFramesSum = <span class="number">0</span>f;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; sampleDataCount <span class="number">-1</span>; n++)</span><br><span class="line">            &#123;</span><br><span class="line">                preFramesSum += preFramesYSpeed[n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// float averageSpeed = preFramesSum / sampleDataCount;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> speedXZ = preFramesZSpeed[<span class="number">0</span>] * preFramesZSpeed[<span class="number">0</span>] + preFramesXSpeed[<span class="number">0</span>] * preFramesXSpeed[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!stepCD &amp;&amp; acceleration &gt; accelerateThreshold &amp;&amp; System.Math.Abs(preFramesYSpeed[<span class="number">0</span>]) &gt; speedYThreshold &amp;&amp; speedXZ &gt;= speedXZThreshold)</span><br><span class="line">            &#123;</span><br><span class="line">                oneStep = <span class="literal">true</span>;</span><br><span class="line">                stepCD = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (oneStep)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// logger.Log($"DebugUI: Acceleration is &#123;acceleration&#125;");</span></span><br><span class="line">                <span class="comment">// logger.Log($"DebugUI: YSpeed is &#123;preFramesYSpeed[0]&#125;");</span></span><br><span class="line">                oneStep = <span class="literal">false</span>;</span><br><span class="line">                stepEnter = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> moveDir = StageController.PlayerCamera.transform.forward;</span><br><span class="line">                <span class="keyword">var</span> shakeDir = <span class="keyword">new</span> Vector3(preFramesXSpeed[<span class="number">0</span>], <span class="number">0</span>f, preFramesZSpeed[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">var</span> dirResult = Vector3.Cross(moveDir, shakeDir);</span><br><span class="line">                <span class="comment">// logger.Log($"DebugUI: direction : &#123;dirResult.y&#125;");</span></span><br><span class="line">                <span class="keyword">if</span>(dirResult.y &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    logger.Log(<span class="string">"DebugUI: FootStep----Right!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    logger.Log(<span class="string">"DebugUI: FootStep----Left!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stepCD)</span><br><span class="line">            &#123;</span><br><span class="line">                stepEnter--;</span><br><span class="line">                <span class="keyword">if</span>(stepEnter &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stepCD = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if(System.Math.Abs(preFramesSpeed[0]) &gt; speedThreshold)</span></span><br><span class="line"><span class="comment">                logger.Log($"DebugUI: YSpeed is &#123;preFramesSpeed[0]&#125;");</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            if(System.Math.Abs(averageSpeed)&gt; 0.02f)</span></span><br><span class="line"><span class="comment">            logger.Log($"DebugUI: &#123;averageSpeed&#125;");</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Debug</span></span><br><span class="line">            <span class="comment">// float speedXZ = preFramesZSpeed[0] * preFramesZSpeed[0] + preFramesXSpeed[0] * preFramesXSpeed[0];</span></span><br><span class="line">            <span class="comment">// logger.Log($"DebugUI: speed_XZ = &#123;speedXZ&#125;");</span></span><br><span class="line">            <span class="comment">// logger.Log($"DebugUI: player forward ( &#123;StageController.PlayerCamera.transform.forward&#125;)");</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面就是检测的全部实现了。</p>
<p>实现中对检测的精度设置了三个档位，于是我想让这三个档位能实现更好的切换，就对Inspector进行了扩展。</p>
<h1 id="检测脚本的Editor扩展"><a href="#检测脚本的Editor扩展" class="headerlink" title="检测脚本的Editor扩展"></a>检测脚本的Editor扩展</h1><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CustomEditor(typeof(HMDMoveFootsteps))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HMDFootStepsInspector</span> : <span class="title">Editor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> SerializedProperty precisionIndex;</span><br><span class="line">    <span class="keyword">protected</span> SerializedProperty mute;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mute = serializedObject.FindProperty(<span class="string">"Mute"</span>);</span><br><span class="line">        precisionIndex = serializedObject.FindProperty(<span class="string">"precisionIndex"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        serializedObject.Update();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(mute, <span class="keyword">new</span> GUIContent(<span class="string">"Mute"</span>));</span><br><span class="line">        <span class="keyword">var</span> index = GUILayout.Toolbar(precisionIndex.intValue, <span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"High Precision"</span>, <span class="string">"Middle Precision"</span>, <span class="string">"Low Precision"</span> &#125;);</span><br><span class="line">        precisionIndex.intValue = index;</span><br><span class="line"></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>达成的效果就像下面这样：</p>
<p><img src="HMDFootStep_Inspector.png" alt="Inspector视图，2019.3.5f1版本"></p>
<p>编辑器扩展的内容本来不想放在这个部分，因为有专门放在扩展的文章，但是分开又觉得不好。另外就是扩展的部分的内容并没有配截图，那个时候还没有为这个博客添加图片。<br>想想那一部分应该都配上展示图片为好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这个脚步检测的结果我还是比较满意的，但是在实际的体验中总是有些不尽人意，所以肯定还有改进的空间。另外这篇文章内容暂时还是不公开为好，毕竟我直接从项目里面Copy的代码。感觉该删的都删掉了但是还是感觉不舒服。</p>
]]></content>
      <categories>
        <category>VR</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
        <tag>非公开文章</tag>
      </tags>
  </entry>
  <entry>
    <title>Assembly-CSharp中的程序集</title>
    <url>/assembly-csharp/</url>
    <content><![CDATA[<p>在接触Unity的过程中，一直不清楚<code>Assembly</code>这个单词到底是什么意思，中文翻译是程序集，但是具体是个什么东西一直没有一个准确的概念。这次准备搞懂它并且对<strong>反射</strong>这个概念进行一次透彻的了解。</p>
<a id="more"></a>
<h1 id="Assembly-程序集"><a href="#Assembly-程序集" class="headerlink" title="Assembly-程序集"></a>Assembly-程序集</h1><ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/standard/assembly/" target="_blank" rel="noopener">.NET 中的程序集</a>官方文档说明<blockquote>
<p>程序集构成了 .NET 应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。 程序集是为协同工作而生成的类型和资源的集合，这些类型和资源构成了一个逻辑功能单元。 程序集采用可执行文件 (.exe) 或动态链接库文件 (.dll) 的形式，是 .NET 应用程序的构建基块 。 它们向公共语言运行时提供了注意类型实现代码所需的信息。</p>
</blockquote>
</li>
</ul>
<p>就像一个应用程序一样，在Windows中这个应用程序会有<code>exe</code>文件和若干<code>dll</code>文件。还有一些其他的我不知道的文件，这些都是程序集的一部分。这就是一个程序集，准确与否我也不确定。反正上面的我理解就是这个意思。</p>
<p>关于Assembly的一些要点的话在上面的链接中可以确认，有时间再整理一下吧。</p>
<h1 id="Reflection-C-中的反射机制"><a href="#Reflection-C-中的反射机制" class="headerlink" title="Reflection-C#中的反射机制"></a>Reflection-C#中的反射机制</h1><ul>
<li><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/reflection" target="_blank" rel="noopener">反射 (C#)</a><br>官网的说明跟没有说明一样，还是得参考其他的文章的使用。因为具体要怎么使用，为什么要使用反射对我来说还是一个疑问，使用反射有什么好处呢？</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/41282759" target="_blank" rel="noopener">C#反射机制</a></p>
</li>
</ul>
<blockquote>
<p>反射是.NET中的重要机制,通过反射,可以在运行时获得程序或程序集中每一个类型(包括类、结构、委托、接口和枚举等)的成员和成员的信息。有了反射,即可对每一个类型了如指掌。另外我还可以直接创建对象,即使这个对象的类型在编译时还不知道。</p>
</blockquote>
<p>运行时能够获取程序或程序集中的的成员情报。利用这些情报可以做很多的事情。</p>
<p>话是这么说我还不太清楚直接使用DLL中的情报有什么不同。就我的经验是不知道DLL中的开发的接口的时候也是无从下手，是不是使用反射就可以某种意义上了解DLL的实现和开放的接口或者函数，利于处理。当然EXE也是一样。</p>
<h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection?view=netframework-4.8" target="_blank" rel="noopener">System.Reflection 命名空间</a></p>
<blockquote>
<p>System.Reflection 命名空间包含通过检查托管代码中程序集、模块、成员、参数和其他实体的元数据来检索其相关信息的类型。 这些类型还可用于操作加载类型的实例，例如挂钩事件或调用方法。 若要动态创建类型，请使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.emit?view=netframework-4.8" target="_blank" rel="noopener">System.Reflection.Emit</a> 命名空间。</p>
</blockquote>
<h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h3><h4 id="System-Type类"><a href="#System-Type类" class="headerlink" title="System.Type类"></a>System.Type类</h4><p>通过这个类可以访问任何给定数据类型的信息。</p>
<p><strong>获取给定类型的Type引用有3种常用方式</strong></p>
<ul>
<li><p>使用C# <code>typeof</code>运算符</p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(<span class="keyword">string</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用对象<code>GetType()</code>方法</p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> s = <span class="string">"grayworm"</span>;</span><br><span class="line">Type t = s.GetType();</span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以调用Type类的静态方法<code>GetType()</code></p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type t = Type.GetType(<span class="string">"System.String"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>官方文档说明：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.type?view=netframework-4.8" target="_blank" rel="noopener">Type 类</a></p>
<h4 id="System-Reflection-Assembly类"><a href="#System-Reflection-Assembly类" class="headerlink" title="System.Reflection.Assembly类"></a>System.Reflection.Assembly类</h4><p>它可以用于访问给定程序集的信息，或者把这个程序集加载到程序中。</p>
<p>官方文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.reflection.assembly?view=netframework-4.8" target="_blank" rel="noopener">Assembly类</a></p>
<p>在官方文档中似乎例举了一些使用方法，暂时我并没有什么需要使用这个反射机制。但是貌似Unity中也会使用这个特性。下次当我决定使用一些DLL等的外部链接库的时候再好好研究并实现这些个特性。</p>
<p>不是往后推，后面对于自己的项目肯定会加入一个Log收集的动态链接库，那个时候一定要把两种链接方式都总结一下。</p>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-使物体旋转的功能脚本</title>
    <url>/unity-make-object-rotating/</url>
    <content><![CDATA[<p>记一个使物体旋转的功能脚本，感觉这个功能时不时的会遇到，每次写的时候都挺绕的，不如记下来。</p>
<a id="more"></a>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>功能实现：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System;</span><br><span class="line"></span><br><span class="line">namespace Clown.Utility</span><br><span class="line">&#123;</span><br><span class="line">    [Serializable, AddComponentMenu(&quot;Clown/Utility/Make Object Rotating&quot;)]</span><br><span class="line">    public class MakeObjectRotating : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool clockWise = false;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool rotateAxisY = true;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool rotateAxisX = false;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool rotateAxisZ = false;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float rotateSpeed = 0.0f;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool hasEnterTime = false;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float enterTime = 4.0f;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private bool hasExitTime = false;</span><br><span class="line">        [SerializeField]</span><br><span class="line">        private float exitTime = 2.0f;</span><br><span class="line"></span><br><span class="line">        bool isRotating = false;</span><br><span class="line">        float speed = 0.0f;</span><br><span class="line"></span><br><span class="line">        bool rotatingSwitch = false;</span><br><span class="line"></span><br><span class="line">        public void OnEnable()</span><br><span class="line">        &#123;</span><br><span class="line">            rotatingSwitch = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void Update()</span><br><span class="line">        &#123;</span><br><span class="line">            var angles = transform.rotation.eulerAngles;</span><br><span class="line">            var anglesY = angles.y;</span><br><span class="line">            var anglesX = angles.x;</span><br><span class="line">            var anglesZ = angles.z;</span><br><span class="line"></span><br><span class="line">            if (isRotating)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!rotatingSwitch)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (hasExitTime)</span><br><span class="line">                    &#123;</span><br><span class="line">                        speed -= (rotateSpeed / exitTime * Time.deltaTime);</span><br><span class="line">                        if (speed &lt; 0.0f)</span><br><span class="line">                        &#123;</span><br><span class="line">                            speed = 0.0f;</span><br><span class="line">                            isRotating = false;</span><br><span class="line"></span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        anglesY -= rotateAxisY ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                        anglesX -= rotateAxisX ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                        anglesZ -= rotateAxisZ ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        isRotating = false;</span><br><span class="line">                        speed = 0.0f;</span><br><span class="line"></span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    anglesY -= rotateAxisY ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesX -= rotateAxisX ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesZ -= rotateAxisZ ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(!rotatingSwitch)</span><br><span class="line">                &#123;</span><br><span class="line">                    enabled = false;</span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (hasEnterTime)</span><br><span class="line">                &#123;</span><br><span class="line">                    speed += (rotateSpeed / enterTime * Time.deltaTime);</span><br><span class="line">                    if (speed &gt; rotateSpeed)</span><br><span class="line">                    &#123;</span><br><span class="line">                        speed = rotateSpeed;</span><br><span class="line">                        isRotating = true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    anglesY -= rotateAxisY ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesX -= rotateAxisX ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesZ -= rotateAxisZ ? (speed * Time.deltaTime) : 0f;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    isRotating = true;</span><br><span class="line">                    anglesY -= rotateAxisY ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesX -= rotateAxisX ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                    anglesZ -= rotateAxisZ ? (rotateSpeed * Time.deltaTime) : 0f;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            angles.y = anglesY;</span><br><span class="line">            angles.x = anglesX;</span><br><span class="line">            angles.z = anglesZ;</span><br><span class="line">            transform.rotation = Quaternion.Euler(angles);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void SetValueToRotate(bool val)</span><br><span class="line">        &#123;</span><br><span class="line">            rotatingSwitch = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用的话，就在合适的时间调用<code>SetValueToRotate</code>或者<code>OnEnable</code>函数就好了，当然使用条件不一样注意一下，我就不写了。</p>
<p>这里我想着应该可以再优化一下代码结构的，但是想想值不值得还是两说，暂时也没有什么非常棒的想法。</p>
<p>这里还有就是我本来想把全部都写在项目文件里的，之前我只是实现了Y轴的旋转，因为项目面基本上不会出现其他轴的旋转了我就没有把全部实现都提交，也许会减轻一些处理吧，心理上的。</p>
<p>这里再贴一下<strong>Editor扩展的实现：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor;</span><br><span class="line">using Project.Utility;</span><br><span class="line"></span><br><span class="line">[CustomEditor(typeof(MakeObjectRotating))]</span><br><span class="line">public class MakeObjectRotationInspector : Editor</span><br><span class="line">&#123;</span><br><span class="line">    protected SerializedProperty clockWise;</span><br><span class="line">    protected SerializedProperty rotateAxisY;</span><br><span class="line">    protected SerializedProperty rotateAxisX;</span><br><span class="line">    protected SerializedProperty rotateAxisZ;</span><br><span class="line">    protected SerializedProperty rotateSpeed;</span><br><span class="line">    protected SerializedProperty hasEnterTime;</span><br><span class="line">    protected SerializedProperty enterTime;</span><br><span class="line">    protected SerializedProperty hasExitTime;</span><br><span class="line">    protected SerializedProperty exitTime;</span><br><span class="line"></span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        clockWise = serializedObject.FindProperty(&quot;clockWise&quot;);</span><br><span class="line">        rotateAxisY = serializedObject.FindProperty(&quot;rotateAxisY&quot;);</span><br><span class="line">        rotateAxisX = serializedObject.FindProperty(&quot;rotateAxisX&quot;);</span><br><span class="line">        rotateAxisZ = serializedObject.FindProperty(&quot;rotateAxisZ&quot;);</span><br><span class="line">        rotateSpeed = serializedObject.FindProperty(&quot;rotateSpeed&quot;);</span><br><span class="line">        hasEnterTime = serializedObject.FindProperty(&quot;hasEnterTime&quot;);</span><br><span class="line">        enterTime = serializedObject.FindProperty(&quot;enterTime&quot;);</span><br><span class="line">        hasExitTime = serializedObject.FindProperty(&quot;hasExitTime&quot;);</span><br><span class="line">        exitTime = serializedObject.FindProperty(&quot;exitTime&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void OnInspectorGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        // base.OnInspectorGUI();</span><br><span class="line"></span><br><span class="line">        serializedObject.Update();</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(clockWise);</span><br><span class="line">        EditorGUILayout.PropertyField(rotateAxisY);</span><br><span class="line">        EditorGUILayout.PropertyField(rotateAxisX);</span><br><span class="line">        EditorGUILayout.PropertyField(rotateAxisZ);</span><br><span class="line">        EditorGUILayout.PropertyField(rotateSpeed);</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.PropertyField(hasEnterTime);</span><br><span class="line">        if (hasEnterTime.boolValue)</span><br><span class="line">        &#123;</span><br><span class="line">            EditorGUI.indentLevel++;</span><br><span class="line">            EditorGUILayout.PropertyField(enterTime);</span><br><span class="line">            EditorGUI.indentLevel--;</span><br><span class="line">        &#125;</span><br><span class="line">        EditorGUILayout.PropertyField(hasExitTime);</span><br><span class="line">        if (hasExitTime.boolValue)</span><br><span class="line">        &#123;</span><br><span class="line">            EditorGUI.indentLevel++;</span><br><span class="line">            EditorGUILayout.PropertyField(exitTime);</span><br><span class="line">            EditorGUI.indentLevel--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        serializedObject.ApplyModifiedProperties();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Timeline的使用</title>
    <url>/unity-timeline/</url>
    <content><![CDATA[<p>最近见到了好多Timeline的使用实例，但是对于Timeline的系统的学习和了解却没有。是时候仔细整理一下了。</p>
<a id="more"></a>
<h2 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h2><h2 id="Timeline中-「Marker」と「Signal、Signal-Receiver」"><a href="#Timeline中-「Marker」と「Signal、Signal-Receiver」" class="headerlink" title="Timeline中 「Marker」と「Signal、Signal Receiver」"></a>Timeline中 「Marker」と「Signal、Signal Receiver」</h2><p>参考<a href="http://tsubakit1.hateblo.jp/entry/2018/12/10/233146" target="_blank" rel="noopener">【Unity】Timelineからメソッドを呼ぶ新機能 「Marker」と「Signal、Signal Receiver」</a>这篇文章学习。</p>
<p><strong>这个功能在2019.1.a11之后的版本能够稳定使用。</strong></p>
<p><strong>由于并不是正式版本中的功能，今后可能会有变化。</strong></p>
<ul>
<li><a href="https://blogs.unity3d.com/jp/2019/05/21/how-to-use-timeline-signals/" target="_blank" rel="noopener">Timeline Signal の使用方法</a></li>
</ul>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>这一部分难以归类，主要是想要记录一下在Timeline中播放AnimationClip的问题的。</p>
<p>使用Timeline来播放动画十分方便，但是不足以应对所有情况。比如说两个动画之间的切换就是十分生硬的切换。这里有两种情况。</p>
<ol>
<li>同一个Timeline里面的AnimationClip切换: 这是最为普通解决方案也最是简单，那就是在Timeline中放置AnimationClip的时候，把<strong>前一个Clip的最后面的部分和后一个Clip的前面的部分叠加放置</strong>。没想到吧，在Timeline里面动画的片段是可以叠加放置的。就类似于旧Animation系统里面的<code>CrossFade</code>一样。</li>
<li>Timeline外的AnimationClip和Timeline内的AnimationClip动画状态的切换：这个我不知道更好的解决方案，自己的解决方案是<strong>在AnimatorController中做好动画之间的切换部分，然后在Timeline中加入Signal调用Animator的Tirgger进行Animation的切换</strong>。</li>
</ol>
<p>再详细一点的说就是，将原本处在Timeline中的AnimationClip移到这个对象的AnimatorController中进行处理了。这里需要提及的是，AnimatorController的处理是挺耗时间 的，严重到旁边的大佬跟我说最好少使用的那种地步，实际上我也不清楚，既然人家说了就少用吧。但是想想那Timeline的使用，播放动画的时候也是需要这个对象有Animator组件的，也就是说也是用这个组件进行播放的。然后我看了一下，当不指定某一个AnimatorController(我们制作的AnimatorController)的时候，有一个叫<strong>RuntimeAnimatorController</strong>的东西顶替了指定的位置，Timeline有这个就可以播放AnimationClip而不需要我们指定AnimatorController，当然硬要指定也不是不可以。</p>
<p>但是最终我还是用了自己的AnimatorController……因为不知道更好的办法了。在完成可以让动画之间的切换如丝般顺滑之前要注意的是：</p>
<ol>
<li>AnimatorController :HasExitTime  一定要取消，然后调整Setting中的参数，过渡的时间等等。</li>
<li>AnimatorController: Parameters 参数的设置主要是为了方便脚本在运行时切换，这里随机应变就好。</li>
<li>Timeline： Signal的制作。这就是这篇最开始的内容了，为什么要做这个就是因为方便调整时间或者方便其他比如设计师修改，毕竟你把人家的AnimationClip都移走了。</li>
<li>Scripts :最关键的脚本，要注意的是一是为Signal提供函数，二是设置AnimatiorController的状态。</li>
</ol>
<p>暂时就想到这么多。</p>
<p>另外在对导入的模型的动画进行编辑的时候，发现了一下小的知识。</p>
<ul>
<li><p>Unity中对导入的模型<strong>Edit</strong>的时候，可以对导入的AnimationClip进行自定义，以其中一段的Clip为基础进行截取的操作，这样就可以方便的增加自己想要的片段。</p>
<ul>
<li>比如说想要在一段长的片段中截取Idle Clip，可以在<strong>Clips</strong>中添加新的片段，然后选定时间，调整<strong>Loop Time</strong>，方便循环播放，然后别忘了<strong>Loop Pose</strong>，这个可以让你截取的部分无缝循环播放。(这是Unity说的)</li>
</ul>
</li>
<li><p>暂时没有在Unity中发现有能导入模型的动画而不导入模型的功能。这点不同于UE4的导入。</p>
</li>
</ul>
<p>还有就是我在Inspector里面看到了下面的错误：</p>
<blockquote>
<p>The clip range is outside of the range of the source take.</p>
</blockquote>
<p>虽然一眼就知道这个的原因是为什么，设置clip的Start和End的时候是从<code>-300</code>开始的，什么？还能从负数开始？这个我肯定不知道，但是事实就是这个项目里，这个clip，里面的Start，里面写着-300。</p>
<p>前几天遇见一个BUG，就是当<strong>把Signal放到Timeline的第0帧的时候，这个Signal不会被执行，第二帧也不行</strong>。据说是之Timeline的BUG。</p>
<p>参考文章:</p>
<ul>
<li><a href="http://www.pointcloud.jp/blog_n29/" target="_blank" rel="noopener">《Unity備忘録》3DCGで設定したアニメーションをUnityで制御する方法</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-踩坑指南</title>
    <url>/ue4-fucking-moment/</url>
    <content><![CDATA[<p>在UE4中踩了不少的坑，这篇主要是用来介绍自己在使用过程中由于粗心或者知识浅薄而掉进去的大坑。<br><a id="more"></a></p>
<h1 id="关于蓝图"><a href="#关于蓝图" class="headerlink" title="关于蓝图"></a>关于蓝图</h1><p>蓝图这个东西我看不顺眼好久了，方便那是非常方便，但是也不能只看脚下的路不是么，等到时间长了，写的多了，那变量维护起来就是爽到飞起了，前期轻松后期地狱。</p>
<h2 id="GetDisplayName"><a href="#GetDisplayName" class="headerlink" title="GetDisplayName"></a>GetDisplayName</h2><blockquote>
<ul>
<li>ブループリント周りで注意:</li>
</ul>
<p>「Get Display Name」ノードは本番で使わないでください。エディタからのゲーム呼び出しとエディタなしのリリースモード等で挙動が異なります。</p>
</blockquote>
<p>自己作死用了这个节点，而且还用这个取出来的数据作为判断条件，这不是找死么。</p>
<p>蓝图的话请使用<strong>GetObjectName</strong>节点。C++的话<strong>GetName()</strong>函数。</p>
<h2 id="Can-not-see-the-detail-panel"><a href="#Can-not-see-the-detail-panel" class="headerlink" title="Can not see the detail panel"></a>Can not see the detail panel</h2><p>在蓝图的使用中会出现看不到Component的Detail面板的问题，解决方案是重新做一遍继承操作，好像蓝图继承C++父类的时候会发生这种问题。</p>
<blockquote>
<p>There’s a known bug that happens when you do this:</p>
<p>Create C++ class,</p>
<p>Create Blueprint based on it.</p>
<p>Add component in C++.</p>
<p>BUG: Component doesn’t have details in Blueprints!</p>
<p>Solution:</p>
<p>un-parent, and then re-parent the BP to the C++ class.</p>
<p>fixed!</p>
</blockquote>
<p>解决来源： <a href="https://answers.unrealengine.com/questions/869223/cantt-see-details-in-blueprint.html" target="_blank" rel="noopener">Cant’t see details in Blueprint</a></p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-异步处理</title>
    <url>/unity-async/</url>
    <content><![CDATA[<p>主要为了理解async/await关键字的意义。</p>
<a id="more"></a>
<ul>
<li><a href="https://ufcpp.wordpress.com/2012/11/12/asyncawaitと同時実行制御/" target="_blank" rel="noopener">async/awaitと同時実行制御</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Serialization理解</title>
    <url>/unity-serialization/</url>
    <content><![CDATA[<p>这个概念对于Unity来说非常重要。了解这个概念应该会对开发的效率有很大的提升。</p>
<a id="more"></a>
<p>在最开始应该理解一下什么是序列化。</p>
<h2 id="Serialization-序列化"><a href="#Serialization-序列化" class="headerlink" title="Serialization 序列化"></a>Serialization 序列化</h2><blockquote>
<p>序列化又称串行化，是.NET运行时环境用来支持用户定义类型的流化的机制。其目的是以某种存储形式使自定义对象持久化，或者将这种对象从一个地方传输到另一个地方。</p>
</blockquote>
<p>Unity中非常多非常多的场景中使用了序列化，参考一下这篇文章<a href="https://blogs.unity3d.com/2014/06/24/serialization-in-unity/" target="_blank" rel="noopener">Serialization in Unity</a>，深入理解一下Unity中的序列化。</p>
<p>下面我就对这篇文章的内容进行整理，主要是做笔记。</p>
<h3 id="Serialization-in-Unity"><a href="#Serialization-in-Unity" class="headerlink" title="Serialization in Unity"></a>Serialization in Unity</h3><p>先是比较重要的内容摘抄一下。</p>
<ul>
<li><strong>Storing data stroed in your scripts.</strong><ul>
<li>保存你脚本中保存的数据。是大多数人最熟知的功能。</li>
</ul>
</li>
<li><strong>Inspector window.</strong><ul>
<li>Inspector窗口不是经过C#的API来了解内部的数据结构或者属性，它要求对象序列化数据然后显示序列化之后的数据内容。</li>
</ul>
</li>
<li><strong>Prefab.</strong><ul>
<li>prefab是一个或多个对象和组件的被序列化的数据流(serialized data stream)。一个prefab实例(instance)实际上是一组应该被应用到这个被序列化数据实例的修改内容(A prefab instance is a list of modifications that should be made on the serialized data for this instance.)。Prefab这个概念实际上只存在于Editor阶段，当Unity开始Build工程的时候就会把这些修改应用到这些被序列化的数据流上，并且当这些修改被实例化，被实例化的数据对象并不会知道它们曾经是Editor编辑器中的Prefab。</li>
</ul>
</li>
<li><p><strong>Instantiation.</strong></p>
<ul>
<li><p>当你调用<code>Instantiate()</code>函数，对prefab，scene中的gameobject，或者是其它的能被序列化的数据(everything that derives from UnityEngine.Object can be serialized)的操作结果，我们将会序列化对象，然后创建一个新的对象，然后反序列化对象数据到新的对象数据中。</p>
<blockquote>
<p>(We then run the same serialization code again in a different variant, where we use it to report which other UnityEngine.Object’s are being referenced. We then check for all referenced UnityEngine.Object’s if they are part of the data being Instantiated(). If the reference is pointing to something “external” (like a texture) we keep that reference as it is, if it is pointing to something “internal” (like a child gameobject), we patch the reference to the corresponding copy).</p>
</blockquote>
<p>  这里我直接贴了英文原文，感觉翻译不出人家的意思。要注意的是：</p>
<ul>
<li>Variant: 在unity编辑器中偶尔会看见这个名字，在我prefab中嵌套另一个prefab的时候印象最深。按照上面的说法，这个是用来通知被引用的UnityEngine.Object’s，然后同样对这些对象执行上述的序列化代码。</li>
<li>如果引用的内容是外部数据(“external”)将会保留原有的引用。</li>
<li>如果引用的内容是内部数据(“internal”)将会将引用替换为原有数据的副本。</li>
<li>在这里，在这篇文章的评论部分有提及，作者举了一个例子来说明这个过程：<blockquote>
<p>The scenario you mean is when you call Instantiate() on something. Let’s take this example. There are three objects.</p>
<p>O1: GameObject components=O2, O3<br>O2: RigidBody<br>O3: BoxCollider</p>
<p>when you invoke Instatiate(gameObject1), we duplicate all three objects.</p>
<p>O4: GameObject components=O2, O3<br>O5: RigidBody<br>O6: BoxCollider</p>
<p>Notice how the cloned object O4, actually points to O2 and O3 in its component list. this is obviously not what you intended. In the second phase of Instantiate, we fix this up, by running the serializer in a special mode on O1,O2&amp;O3. we ask it “please report your object references”, and then we check if any of the objects referenced were included in the list of objects that were cloned. For each reference that referenced an object that was cloned (both entries in the componentlist in our case), we update that reference to the cloned version instead of the original. after the fix it looks like this:</p>
<p>O4: GameObject components=O5, O6<br>O5: RigidBody<br>O6: BoxCollider</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Saving.</strong></p>
<ul>
<li>如果设置了”force text serialization”，并且用文本编辑器打开<code>.unity</code>的scene文件，<strong>we run the serializer with a ymal backend.</strong></li>
</ul>
</li>
<li><strong>Loading.</strong><ul>
<li>向后兼容加载（backwards compatible loading）也是基于系列化机制(serialization)的系统。In-Editor的yaml loading利用了序列化机制，运行时加载scenes和assets也利用了这个。Assetbundles也利用了序列化系统(serialization system)。</li>
</ul>
</li>
<li><strong>Hot reloading of editor code.</strong><ul>
<li>当你改变了editor脚本数据，我们会序列化所有的editor窗口（它们都继承自UnityEngine.Object!），然后我们销毁所有的窗口，unload掉所有的旧的C#代码，加载新的C#代码，重新创建窗口，并在最后反序列化数据流中的数据到新的窗口。</li>
</ul>
</li>
<li><strong>Resource.GarabageCollectSharedAssets().</strong><ul>
<li>Unity中使用的GC(native garabage collector)，不同于C#所使用的GC。我们使用这个系统，当加载一个scene，之前的scene未引用的内容就会被unload掉。这种GC会在某种模式下运行序列器(serializer)，在这个模式下我们用它来让对象通知所有的引用到外部的UnityEngine.Objects。这就是为什么我们在scene1中使用的textures会在scene2中被unload掉。<blockquote>
<p>This is our native garbage collector and is different to the C# garbage collector. It is the thing that we run after you load a scene to figure out which things from the previous scene are no longer referenced, so we can unload them. The native garbage collector runs the serializer in a mode where we use it to have objects report all references to external UnityEngine.Objects. This is what makes textures that were used by scene1, get unloaded when you load scene2.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>The serialization system is written in C++, we use it for all our internal object types (Textures, AnimationClip, Camera, etc). Serialization happens at the UnityEngine.Object level, each UnityEngine.Object is always serialized as a whole. They can contain references to other UnityEngine.Objects and those references get serialized properly.</p>
</blockquote>
<p>由于一些执行效率的需要，serializer的行为不完全是如你所愿，比如说MonoBehaviour component的序列化是由你写的脚本所支持的，所以了解serializer的运行细节能够让你更好的使用它。</p>
<p><strong>为了能让我们写的脚本中的序列化区域(a fieldof my script)能够被序列化需要什么条件？</strong></p>
<ul>
<li>Be public,or have [SerializeField] attribute</li>
<li>Not be static</li>
<li>Not be const</li>
<li>Not be readonly</li>
<li>The fieldtype needs to be a type that we can serialize.</li>
</ul>
<p><strong>什么样的类型(fieldtype)能被序列化呢？</strong></p>
<ul>
<li>Custom non abstrace classes with [Serializable] attribute.</li>
<li>Custom structs with [Serializable] attribute. (new inUnity4.5)</li>
<li>References to objects that derive from UnityEngine.Object</li>
<li>Primitive data dypes(int,float,double,bool,string,etc)</li>
<li>Array of a fieldtype we can serialize</li>
<li>List<t> of a fieldtype we can serialize</t></li>
</ul>
<p>那么什么情况是，serializer的动作会是与我们的期望有所不同呢？<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Animal[] animals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>当我们试着在数组<code>animals</code>加入三个相同的<code>Animal object</code>对象引用的时候，即三个引用都指向相同的对象。在已序列化的数据流中你会发现三个对象，当你进行反序列化会发现那里有三个不同的对象。</em></p>
<p>当你需要需要序列化一个比较复杂的引用的对象列表，这个时候就不能依靠Unity的serializer。你需要做些操作为了能让这些数据正常序列化。</p>
<p>但是需要注意的是，这个情况只适应于自定义类(custonm classes)，因为他们是被内联的序列化（serialized “inline”）,因为他们的数据成为了既存的MonoBehaviour中的完整的序列化数据的一部分。当你的变量区域有一个UnityEngine.Object的派生类引用，那么数据并不是内联序列化，那么其实际的引用数据会被成功的序列化。</p>
<blockquote>
<p>Note that this is only true for custom classes, as they are serialized “inline” because their data becomes part of the complete serializationdata for the MonoBehaviour they are used in. When you have fields that have a reference to something that is a UnityEngine.Object derived class, like a “public Camera myCamera”, the data from that camera are not serialized inline, and an actual reference to the camera UnityEngine.Object is serialized.</p>
</blockquote>
<p>(我担心自己的理解有偏差还是把英文原文贴了出来。)</p>
<p><strong>No support for null for custom classes</strong></p>
<blockquote>
<p>The serializer does not support null. If it serializes an object and a field is null, we just instantiate a new object of that type and serialize that. Obviously this could lead to infinite cycles, so we have a relatively magical depth limit of 7 levels. At that point we just stop serializing fields that have types of custom classes/structs and lists and arrays. [1]</p>
</blockquote>
<p>Serializer不支持null类型的序列化，如果执行这样的操作了就会导致死循环，unity在这种死循环中加入了最大的生成层次。在Unity4.5之后的版本加入了警告的信息。</p>
<p><strong>No support for polymorphism</strong></p>
<p>不支持多态。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Animal[] animals;</span><br></pre></td></tr></table></figure></p>
<p>在里面加入一个<code>dog</code>,<code>cat</code>,<code>giraffe</code>三个派生实例，在序列化之后我们得到的是三个<code>Animal</code>类型的实例。</p>
<p>这会发生在自定义类(“custom classes”)的内联序列化(get serialized inline)过程中。当对象实例是UnityEngine.Object’s派生的实例多态的特性还是有效的。</p>
<blockquote>
<p>You’d make a ScriptableObject derived class or another MonoBehaviour derived class, and reference that. The downside of doing this, is that you need to store that monobehaviour or scriptable object somewhere and cannot serialize it inline nicely.</p>
</blockquote>
<p><em>你可以利用ScriptableObject派生类或者另一个MonoBehavior派生类，并引用这个生成的实例。这种方式的缺点是，你必须在某个地方存储monobehaviour或者scriptable对象，而不能很好的内联序列化(serailized inline)。</em></p>
<p>产生这样的限制的原因是，序列化系统的一个核心功能之一的实现，了解一个对象的数据结构依靠的是类的类型，而不是运行时被存储在这个类区域的数据类型。</p>
<blockquote>
<p>The reason for these limitations is that one of the core foundations of the serialization system is that the layout of the datastream for an object is known ahead of time, and depends on the types of the fields of the class, instead of what happens to be stored inside the fields.</p>
</blockquote>
<p><strong>那么如何序列化一些Uinty不支持的数据类型？</strong></p>
<p>大多情况下可以使用<strong>serialization callbacks</strong>。它们会在serializer开始读取你的自定义数据区域之前通知你，并在serializer结束之后写入数据。（应该就是上面说的序列化之前存储monobehaviour或者scriptable对象，并在序列化完成之后将数据写入。）</p>
<blockquote>
<p>In many cases the best approach is to use serialization callbacks. They allow you to be notified before the serializer reads data from your fields and after it is done writing to them. You can use this to have a different representation of your hard-to-serialize data at runtime than when you actually serialize. You’d use these to transform your data into something Unity understands right before Unity wants to serialize it, you also use it to transform the serialized form back into the form you’d like to have your data in at runtime, right after Unity has written the data to your fields.</p>
</blockquote>
<p>让我们创建一个树状的数据的结构(tree datastructure)，如果你直接让Unity去序列化这样的数据，”no support for null”的限制会让你的数据流变得非常大，导致一些程序效率的问题。</p>
<blockquote>
<p>Let’s say you want to have a tree datastructure. If you let Unity directly serialize the data structure, the “no support for null” limitation would cause your datastream to become very big, leading to performance degradations in many systems:</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VerySlowBehaviourDoNotDoThis</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> interestingValue = <span class="string">"value"</span>;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//The field below is what makes the serialization data become huge because</span></span><br><span class="line">       <span class="comment">//it introduces a 'class cycle'.</span></span><br><span class="line">       <span class="keyword">public</span> List&amp;lt;Node&amp;gt; children = <span class="keyword">new</span> List&amp;lt;Node&amp;gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//this gets serialized</span></span><br><span class="line">    <span class="keyword">public</span> Node root = <span class="keyword">new</span> Node();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Display (root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span>(<span class="params">Node node</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GUILayout.Label (<span class="string">"Value: "</span>);</span><br><span class="line">        node.interestingValue = GUILayout.TextField(node.interestingValue, GUILayout.Width(<span class="number">200</span>));</span><br><span class="line"> </span><br><span class="line">        GUILayout.BeginHorizontal ();</span><br><span class="line">        GUILayout.Space (<span class="number">20</span>);</span><br><span class="line">        GUILayout.BeginVertical ();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> node.children)</span><br><span class="line">            Display (child);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button (<span class="string">"Add child"</span>))</span><br><span class="line">            node.children.Add (<span class="keyword">new</span> Node ());</span><br><span class="line"> </span><br><span class="line">        GUILayout.EndVertical ();</span><br><span class="line">        GUILayout.EndHorizontal ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Instead, you tell Unity not to serialize the tree directly, and you make a seperate field to store the tree in a serialized format, suited for Unity’s serializer:</p>
</blockquote>
<p>为serializer添加自定义数据的序列化操作</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line">public class BehaviourWithTree : MonoBehaviour, ISerializationCallbackReceiver</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//node class that is used at runtime</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> interestingValue = <span class="string">"value"</span>;</span><br><span class="line">        <span class="keyword">public</span> List&amp;lt;Node&amp;gt; children = <span class="keyword">new</span> List&amp;lt;Node&amp;gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//node class that we will use for serialization</span></span><br><span class="line">    [<span class="meta">Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> SerializableNode</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> interestingValue;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> childCount;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> indexOfFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//the root of what we use at runtime. not serialized.</span></span><br><span class="line">    Node root = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//the field we give unity to serialize.</span></span><br><span class="line">    <span class="keyword">public</span> List&amp;lt;SerializableNode&amp;gt; serializedNodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnBeforeSerialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//unity is about to read the serializedNodes field's contents. lets make sure</span></span><br><span class="line">        <span class="comment">//we write out the correct data into that field "just in time".</span></span><br><span class="line">        serializedNodes.Clear();</span><br><span class="line">        AddNodeToSerializedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddNodeToSerializedNodes</span>(<span class="params">Node n</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> serializedNode = <span class="keyword">new</span> SerializableNode () &#123;</span><br><span class="line">            interestingValue = n.interestingValue,</span><br><span class="line">            childCount = n.children.Count,</span><br><span class="line">            indexOfFirstChild = serializedNodes.Count+<span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        serializedNodes.Add (serializedNode);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> n.children)</span><br><span class="line">            AddNodeToSerializedNodes (child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnAfterDeserialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//Unity has just written new data into the serializedNodes field.</span></span><br><span class="line">        <span class="comment">//let's populate our actual runtime data with those new values.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (serializedNodes.Count &amp;gt; <span class="number">0</span>)</span><br><span class="line">            root = ReadNodeFromSerializedNodes (<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = <span class="keyword">new</span> Node ();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node <span class="title">ReadNodeFromSerializedNodes</span>(<span class="params"><span class="keyword">int</span> index</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> serializedNode = serializedNodes [index];</span><br><span class="line">        <span class="keyword">var</span> children = <span class="keyword">new</span> List&amp;lt;Node&amp;gt; ();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i!= serializedNode.childCount; i++)</span><br><span class="line">            children.Add(ReadNodeFromSerializedNodes(serializedNode.indexOfFirstChild + i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node() &#123;</span><br><span class="line">            interestingValue = serializedNode.interestingValue,</span><br><span class="line">            children = children</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Display (root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span>(<span class="params">Node node</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GUILayout.Label (<span class="string">"Value: "</span>);</span><br><span class="line">        node.interestingValue = GUILayout.TextField(node.interestingValue, GUILayout.Width(<span class="number">200</span>));</span><br><span class="line"></span><br><span class="line">        GUILayout.BeginHorizontal ();</span><br><span class="line">        GUILayout.Space (<span class="number">20</span>);</span><br><span class="line">        GUILayout.BeginVertical ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> node.children)</span><br><span class="line">            Display (child);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (GUILayout.Button (<span class="string">"Add child"</span>))</span><br><span class="line">            node.children.Add (<span class="keyword">new</span> Node ());</span><br><span class="line"></span><br><span class="line">        GUILayout.EndVertical ();</span><br><span class="line">        GUILayout.EndHorizontal ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Beware that the serializer, including these callbacks coming from the serializer, usually do not run on the main thread, so you are very limited in what you can do in terms of invoking Unity API. (Serialization happening as part of loading a scene happens on a loading thread. Serialization happening as part of you invoking Instantiate() from script happens on the main thread). You can however do the necessary data transformations do get your data from a non-unity-serializer-friendly format to a unity-serializer-friendly-format.</p>
</blockquote>
<p>需要注意的是，这些回调通常并不会运行在主线程中，所以当调用UnityAPI的时候就需要注意加一些限制。（当是scene加载过程中的序列化是loading thread中发生的，你调用<code>Instantiate()</code>函数过程中的序列化是在主线程中发生的。）</p>
<p>通过上面的手段就可以实现一些Unity不支持的数据类型的序列化。</p>
<p>这个时候我就会问<strong>List&lt;Node&gt;</strong>是个什么，查了一下，就是<code>&lt;</code>,<code>&gt;</code>的表示。<a href="http://www.shurey.com/js/labo/character.html" target="_blank" rel="noopener">HTML特殊文字コード表</a>。</p>
<p>额…</p>
<p>看了一下时间，是2014年的文章，现在已经2020年了…不过自定义序列化数据之前的东西还是没变的感觉，仍是非常有用，对我来说。</p>
<ul>
<li><a href="http://light11.hatenadiary.com/entry/2018/03/15/225709" target="_blank" rel="noopener">【Unity】【エディタ拡張】SerializedObjectの勘所をまとめてみる</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-第三方库介绍和使用</title>
    <url>/unity-plugins/</url>
    <content><![CDATA[<p>这篇主要是介绍一些Unity的插件使用，Unity的插件库感觉很方便，而且确实很丰富。</p>
<a id="more"></a>
<h2 id="Dynamic-Bone"><a href="#Dynamic-Bone" class="headerlink" title="Dynamic Bone"></a>Dynamic Bone</h2><p>使用的话搜一下应该就能找到，我只是稍微使用这个库来模拟了下垂的线。移动的时候会像飘着那样移动。</p>
<h2 id="Alembic-Stream-Player-component"><a href="#Alembic-Stream-Player-component" class="headerlink" title="Alembic Stream Player component"></a>Alembic Stream Player component</h2><p>这是一个很神奇的组件，我还不太确定这个到底是组件还是插件。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-DoTween-曲线的魅力</title>
    <url>/Unity-DoTween-%E6%9B%B2%E7%BA%BF%E7%9A%84%E9%AD%85%E5%8A%9B/</url>
    <content><![CDATA[<p>因为在使用DoTween的时候，有许多我不知道的用法，关于曲线的使用和一些很重要的名词。这篇文章主要用来记录这些曲线的操作和使用。</p>
<a id="more"></a>
<p>首先是曲线的基础：</p>
<ul>
<li><a href="https://postd.cc/bezier-curves/" target="_blank" rel="noopener">一から学ぶベジェ曲線</a></li>
</ul>
<p>虽然是随便搜也能搜到，暂且记下来吧。</p>
<h2 id="ease"><a href="#ease" class="headerlink" title="ease"></a>ease</h2><ul>
<li><a href="https://easings.net/" target="_blank" rel="noopener">Easing functions specify the rate of change of a parameter over time</a></li>
</ul>
<p>相当实用的网站，大佬教我搜<strong>ease</strong>的时候搜到的。</p>
<h2 id="DoTween"><a href="#DoTween" class="headerlink" title="DoTween"></a>DoTween</h2><p>其实应该把这个放到<strong>Unity-插件</strong>的内容里的，感觉和曲线息息相关的插件，就放到了这里。</p>
<ul>
<li><a href="http://dotween.demigiant.com/documentation.php" target="_blank" rel="noopener">DOCUMENTATION</a></li>
</ul>
<h3 id="DoPath-DoLocalPath"><a href="#DoPath-DoLocalPath" class="headerlink" title="DoPath/DoLocalPath"></a>DoPath/DoLocalPath</h3><p>这个是我所需要的，我使用的地方。</p>
<p>关于这个插件有很多的使用，有免费版和Pro版。我看到有人整理的我就先上个链接<br>-<a href="https://gist.github.com/anzfactory/da73149ba91626ba796d598578b163cc" target="_blank" rel="noopener">HowTo_DOTween.md</a></p>
<p>我自己的话充其量用了上面的路径功能，换了换set ease的条件。还有一些<strong>RX</strong>的使用，<code>Onstart()</code>,<code>OnComplete()</code>。</p>
<h3 id="DoTween停止操作"><a href="#DoTween停止操作" class="headerlink" title="DoTween停止操作"></a>DoTween停止操作</h3><p>unity的Scene之间移动的时候需要停止DoTween的动作，当然tween的本体在切换Scene的时候不会被destory的。于是就出现了一个奇怪的现象。</p>
<p><strong>Tween的object把setActive(false)执行之后仍然继续活动</strong></p>
<p>这就奇了怪了，我的猜测是在Unity中跟gameobject相关的操作都是在主线程中运行，但是Tween的操作是子线程，但是反过来一想又不太对，Tween操作transform的移动不应该是主线程中吗，反正不太清楚，出现了这个问题，我的解决方案是：</p>
<p>先执行<code>Complete()</code>，再<code>setActive(false)</code>。</p>
<p>这里有一个疑问，我在使用Complete之前有尝试过Kill这个方法，但是，反正就是未能解决我遇到的问题，保险起见我是在执行Kill之前又添加了Complete的操作，虽然感觉不太好，但还是那么做了…</p>
<p>参考文章：<a href="https://qiita.com/kagigi/items/bdf4d42835add07b0077#complete-or-kill%E3%81%99%E3%82%8B%E3%81%BE%E3%81%A7%E6%AE%8B%E3%82%8A%E7%B6%9A%E3%81%91%E3%82%8B%E5%95%8F%E9%A1%8C" target="_blank" rel="noopener">DOTweenをふわっとまとめてみた</a></p>
<h2 id="Unity-DoTween-Shortcut"><a href="#Unity-DoTween-Shortcut" class="headerlink" title="Unity DoTween Shortcut"></a>Unity DoTween Shortcut</h2><blockquote>
<p>DOTween includes shortcuts for some known Unity objects, like Transform, Rigidbody and Material. You can start a tween directly from a reference to these objects (which will also automatically set the object itself as the tween target), like:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; transform.DOMove(new Vector3(2,3,4), 1);</span><br><span class="line">&gt; rigidbody.DOMove(new Vector3(2,3,4), 1);</span><br><span class="line">&gt; material.DOColor(Color.green, 1);</span><br><span class="line"></span><br><span class="line">Dotween提供的这种快捷的方式很好理解，但是这种方式的实现就很厉害，值得学习。比如说这个transform的DOMove方法的shortcut实现：</span><br><span class="line">```csharp</span><br><span class="line">public static TweenerCore&lt;Vector3, Vector3, VectorOptions&gt; DoMove(this Transform target, Vector3 endValue, float duration, bool snapping = false);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>C#该学的东西还是有很多很多啊，学无止境啊。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Plugins</tag>
        <tag>DoTween</tag>
        <tag>Curve</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-枚举的使用</title>
    <url>/ue4-enum/</url>
    <content><![CDATA[<p>介绍关于枚举的使用。</p>
<a id="more"></a>
<ul>
<li><a href="http://papersloth.hatenablog.com/entry/2017/07/07/005225" target="_blank" rel="noopener">UE4 C++とUnreal C++の列挙型の扱い</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-Editor扩展</title>
    <url>/ue4-editor-extension/</url>
    <content><![CDATA[<p>今天这篇文章要写UE4的编辑器扩展内容的，我还没学会，有时间的话一定要整理一下。</p>
<a id="more"></a>
<p>在用了Unity的各种技巧之后，再回到UE4的时候不禁觉得要是UE4也有这些方便的扩展功能就好了。Unity中的自定义Inspector扩展就很方便，还有DebugMenu等等。</p>
<ul>
<li><p><a href="https://wiki.unrealengine.com/Customizing_detail_panels" target="_blank" rel="noopener">Customizing detail panels</a></p>
</li>
<li><p><a href="http://unrealengine.hatenablog.com/entry/2016/10/05/215937" target="_blank" rel="noopener">UE4 Blutilityによるお手軽なエディター拡張</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Editor扩展</title>
    <url>/unity-editor-extension/</url>
    <content><![CDATA[<p>编辑器扩展是很重要的一个部分，多使用可以提高开发效率。当然也是需要学习的。(未整理)</p>
<a id="more"></a>
<p>由于是Editor的扩展功能在实际的项目中要注意不要把Editor的功能打包在项目的功能里面。</p>
<h2 id="Unity-Editor扩展"><a href="#Unity-Editor扩展" class="headerlink" title="Unity Editor扩展"></a>Unity Editor扩展</h2><p>Unity编辑器扩展好多内容啊，只能记下我遇见的了。有时间要找找一些感觉用的上的。</p>
<p>参考公司大佬的写法，我做了一个当我准备关掉Editor的时候会弹出来一个MessageBox的功能。没啥实际的功能，就是为了提醒。</p>
<h3 id="实现需求"><a href="#实现需求" class="headerlink" title="实现需求"></a>实现需求</h3><p><a href="https://docs.unity3d.com/ScriptReference/EditorApplication-wantsToQuit.html" target="_blank" rel="noopener">EditorApplication.wantsToQuit</a>就是实现这个功能的主角。</p>
<p>实现这个功能的代码:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorReminder</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">InitializeOnLoadMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ValidateReminder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        EditorApplication.wantsToQuit += EditorWantToQuitReminder;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">EditorWantToQuitReminder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span>.TryParse(EditorUserSettings.GetConfigValue(<span class="string">"EnableReminder"</span>), <span class="keyword">out</span> <span class="keyword">var</span> enable);</span><br><span class="line">        <span class="keyword">if</span>(!enable)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> EditorUtility.DisplayDialog(<span class="string">"Reminder"</span>, <span class="string">"Have you released all your locks on GitHub?"</span>, <span class="string">"Yes, quit!"</span>, <span class="string">"No, wait a second."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>几行就能实现这个功能，真的好简单啊（站着说话不腰疼）。</p>
<h3 id="InitializeOnLoad"><a href="#InitializeOnLoad" class="headerlink" title="InitializeOnLoad"></a>InitializeOnLoad</h3><blockquote>
<p><strong><a href="https://docs.unity3d.com/Manual/RunningEditorCodeOnLaunch.html" target="_blank" rel="noopener">Running Editor Script Code on Launch</a></strong></p>
<p>Sometimes, it is useful to be able to run some editor script code in a project as soon as Unity launches without requiring action from the user. You can do this by applying the InitializeOnLoad attribute to a class which has a static constructor. A static constructor is a function with the same name as the class, declared static and without a return type or parameters (see <a href="http://docs.go-mono.com/index.aspx?link=ecmaspec%3a17.11" target="_blank" rel="noopener">here</a> for more information):-</p>
</blockquote>
<p>官方文档上说对于有一个静态构造函数的类前可以加上<strong>InitializeOnLoad</strong>这个attribute，但是上面的那个例子我并没有显式的去声明一个静态的构造函数。而且执行下来也没什么问题，难道说有一个静态构造函数会好一些吗。</p>
<blockquote>
<p>A static constructor is always guaranteed to be called before any static function or instance of the class is used, but the InitializeOnLoad attribute ensures that it is called as the editor launches.</p>
</blockquote>
<p>就是这样使用的。</p>
<h3 id="InitializeOnLoadMethod"><a href="#InitializeOnLoadMethod" class="headerlink" title="InitializeOnLoadMethod"></a>InitializeOnLoadMethod</h3><p><a href="https://docs.unity3d.com/ScriptReference/InitializeOnLoadMethodAttribute.html" target="_blank" rel="noopener">InitializeOnLoadMethodAttribute</a></p>
<blockquote>
<p>Allow an editor class method to be initialized when Unity loads without action from the user.</p>
</blockquote>
<p>项目被加载到Unity中的时候带有这个属性的静态函数就会被自动调用。</p>
<h3 id="RuntimeInitializeOnLoadMethod"><a href="#RuntimeInitializeOnLoadMethod" class="headerlink" title="RuntimeInitializeOnLoadMethod"></a>RuntimeInitializeOnLoadMethod</h3><ul>
<li><a href="https://docs.unity3d.com/ScriptReference/RuntimeInitializeOnLoadMethodAttribute.html" target="_blank" rel="noopener">RuntimeInitializeOnLoadMethodAttribute</a></li>
</ul>
<p>添加了这个属性的函数会在游戏开始运行的时候被自动调用而不需要人为调用。</p>
<blockquote>
<p>Allow a runtime class method to be initialized when a game is loaded at runtime without action from the user.</p>
</blockquote>
<p><code>[RuntimeInitializeOnLoadMethod]</code>的默认行为会在<code>Awake</code>之后被调用，还有一种说法是在<code>OnEnable</code>之后调用。</p>
<blockquote>
<p>The execution order of methods marked [RuntimeInitializeOnLoadMethod] is not guaranteed.<br>这句话应该是说都有<code>[RuntimeInitializeOnLoadMethod]</code>的函数调用顺序无法被保证。</p>
</blockquote>
<h4 id="RuntimeInitializeLoadType"><a href="#RuntimeInitializeLoadType" class="headerlink" title="RuntimeInitializeLoadType"></a>RuntimeInitializeLoadType</h4><ul>
<li><a href="https://docs.unity3d.com/ScriptReference/RuntimeInitializeLoadType.html" target="_blank" rel="noopener">RuntimeInitializeLoadType</a></li>
</ul>
<p>指定参数的话就可以指定不同时间段调用。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InitTest</span>  : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnBeforeSceneLoadRuntimeMethod</span> (<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"Before scene loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"Awake"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"OnEnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnAfterSceneLoadRuntimeMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"After scene loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">RuntimeInitializeOnLoadMethod</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnRuntimeMethodLoad</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"RuntimeMethodLoad: After scene loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"Start"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行顺序为:<code>BeforeSceneLoad</code>-&gt;<code>Awake</code>-&gt;<code>OnEnable</code>-&gt;<code>AfterSceneLoad</code>-&gt;<code>no paramater</code>-&gt;<code>Start</code></p>
<h3 id="EditorApplication"><a href="#EditorApplication" class="headerlink" title="EditorApplication"></a>EditorApplication</h3><p><a href="https://docs.unity3d.com/ScriptReference/EditorApplication.html" target="_blank" rel="noopener">EditorApplication</a></p>
<h4 id="wantsToQuit"><a href="#wantsToQuit" class="headerlink" title="wantsToQuit"></a>wantsToQuit</h4><p>就是我用的那个啦，连用法都是抄的官方文档的。</p>
<blockquote>
<p>Unity raises this event when the editor application wants to quit.</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure class initializer is called whenever scripts recompile</span></span><br><span class="line">[<span class="meta">InitializeOnLoad</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorWantsToQuitExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">WantsToQuit</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.Log(<span class="string">"Editor prevented from quitting."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">EditorWantsToQuitExample</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        EditorApplication.wantsToQuit += WantsToQuit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要在Editor退出前做点什么？那么用这个吧。</p>
<h4 id="quitting"><a href="#quitting" class="headerlink" title="quitting"></a>quitting</h4><p>想要在Editor退出的时候做点什么那么用这个。</p>
<h3 id="EditorUtility"><a href="#EditorUtility" class="headerlink" title="EditorUtility"></a>EditorUtility</h3><p><strong><a href="https://docs.unity3d.com/ScriptReference/EditorUtility.html" target="_blank" rel="noopener">EditorUtility</a></strong></p>
<p>一些通用的函数库，看名字就知道应该会很多</p>
<h4 id="EditorUtility-DisplayDialog"><a href="#EditorUtility-DisplayDialog" class="headerlink" title="EditorUtility.DisplayDialog"></a>EditorUtility.DisplayDialog</h4><p><strong><a href="https://docs.unity3d.com/ScriptReference/EditorUtility.DisplayDialog.html" target="_blank" rel="noopener">EditorUtility.DisplayDialog</a></strong></p>
<p>弹出一个窗口？</p>
<h4 id="EditorUtility-DisplayDialogComplex"><a href="#EditorUtility-DisplayDialogComplex" class="headerlink" title="EditorUtility.DisplayDialogComplex"></a>EditorUtility.DisplayDialogComplex</h4><p>弹出一个更复杂的窗口？（貌似是支持三个按钮）</p>
<h3 id="MenuItem"><a href="#MenuItem" class="headerlink" title="MenuItem"></a>MenuItem</h3><p><strong><a href="https://docs.unity3d.com/ScriptReference/MenuItem.html" target="_blank" rel="noopener">MenuItem</a></strong></p>
<p>这个属性可以让在Editor上的菜单栏添加项目，可以用来做什么呢？那可太多了，比如说需要方便切换的项目设定，亦或者想要方便调用一个函数（啊这个好像可以直接在想要调用的GameObject上右键调用，使用另外一个Attribute）。总而言之，就是方便。</p>
<p>需要注意的是<strong>只有静态函数才能使用这个MenuItem属性</strong>。</p>
<p>这个光看官方文档不靠谱，讲的太少了，看我总结的？我总结的也没什么好看的，看这个</p>
<ul>
<li><a href="http://kan-kikuchi.hatenablog.com/entry/MenuItem" target="_blank" rel="noopener">メニューを追加するための属性「MenuItem」は意外と多機能【Unity】【エディタ拡張】【属性】</a></li>
</ul>
<p>还能设定快捷键，厉害了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MenuItem(menuRoot + <span class="meta-string">"EnableReminder"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnableReminder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> path = menuRoot + <span class="string">"EnableReminder"</span>;</span><br><span class="line">    <span class="keyword">var</span> enable = Menu.GetChecked(path);</span><br><span class="line"></span><br><span class="line">    Menu.SetChecked(path, !enable);</span><br><span class="line">    EditorUserSettings.SetConfigValue(<span class="string">"EnableReminder"</span>, (!enable).ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用的话就是这么用的。我靠<strong>EditorUserSettings</strong>又是什么？</p>
<hr>
<ul>
<li>2020/01/16更新</li>
</ul>
<h4 id="MenuItem参数说明"><a href="#MenuItem参数说明" class="headerlink" title="MenuItem参数说明"></a>MenuItem参数说明</h4><p>在菜单栏里添加自定义项的话当然需要对其参数有所了解，直接进入源码查看即可，这里我顺便贴一下注释:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Summary:</span></span><br><span class="line"><span class="comment">//     Creates a menu item and invokes the static function following it, when the menu</span></span><br><span class="line"><span class="comment">//     item is selected.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//   itemName:</span></span><br><span class="line"><span class="comment">//     The itemName is the menu item represented like a pathname. For example the menu</span></span><br><span class="line"><span class="comment">//     item could be "GameObject/Do Something".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   isValidateFunction:</span></span><br><span class="line"><span class="comment">//     If isValidateFunction is true, this is a validation function and will be called</span></span><br><span class="line"><span class="comment">//     before invoking the menu function with the same itemName.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   priority:</span></span><br><span class="line"><span class="comment">//     The order by which the menu items are displayed.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span>(<span class="params"><span class="keyword">string</span> itemName, <span class="keyword">bool</span> isValidateFunction, <span class="keyword">int</span> priority</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>这里关于<code>isValidateFunxtion</code>的说明就是增加一个验证函数，比如说我只想在游戏运行的时候执行某个操作，在Editor未运行的时候调用这个函数没有意义那就加上一个验证函数。</p>
<hr>
<ul>
<li>2020/02/10 更新内容</li>
</ul>
<p>过了好久终于有机会亲自尝试一下这个功能，同时对一些疑问进行了验证。</p>
<p>1.首先是这个MenuItem的<code>isValidateFunction</code>为True的情况下的执行情况：</p>
<p>按照源码中的注释所说，标注了这个属性的函数(以下称为<em>验证函数</em>)会在具有相同<code>itemName</code>的函数之前执行，在我实际添加了执行log的结果来看，这个函数确实会在前面执行，但是执行的时机却很迷惑。</p>
<p>单纯的情况下，在执行无<code>isValidateFunction</code>同名<code>itemName</code>函数之前，这个验证函数被执行了两次。哪怕是点开MenuItem执行其他的功能函数，甚至什么都不执行点击其他位置关掉点开MenuItem弹出来的菜单，这个验证函数都会被执行一次。</p>
<p>看来这个验证函数还跟Unity的Editor的运行有关，比如说关掉MenuItem的窗口会刷新一下状态，执行一遍所有的验证函数（我猜的）什么的。</p>
<p>2.验证函数的返回值的影响</p>
<p>细心的我发现，与被调用的函数不同，验证函数会有一个布尔类型的返回值，对于这个返回值我测试得到的结果是：</p>
<p>当返回值是true的时候，就是平常一样正常的调用。</p>
<p>返回值是false的时候，被调用的函数(具有相同的<code>itemName</code>)的MenuItem就变灰色了，不能点击调用。</p>
<hr>
<p>关于<code>priority</code>的含义就是可以自定义菜单选项的顺序，这里要注意的是想要在弹出来的菜单中看到分割线的话，优先级的数值是10起跳的。摘一段官网的文字:</p>
<blockquote>
<p>Note: The understanding of ten or greater is considered to create a divider in the menu. However, as per the example above, the difference between script function need to have the priority separated by 11 or more. This is why the example before has a value of 100 and one of 111. Changing 111 to 110 does not have a divider.</p>
</blockquote>
<h3 id="ScriptTemplates"><a href="#ScriptTemplates" class="headerlink" title="ScriptTemplates"></a>ScriptTemplates</h3><p>简单创建一个想要的脚本模板。Unity提供了两种方式。</p>
<p>一种是直接在Unity原有的ScriptTemplates的地方添加类似的新的模板。</p>
<p>另一种是在工程里添加新的模板。</p>
<p>当然是推荐第二种啦。但是第一种也应该知道，毕竟要看人家是怎么做的啊。贴一下Unity引擎内置的脚本模板的位置:</p>
<p>Windows:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Unity\Editor\Data\Resources\ScriptTemplates\</span><br></pre></td></tr></table></figure></p>
<p>Mac:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/Applications/Unity/Unity.app/Contents/Resources/ScriptTemplates/</span><br></pre></td></tr></table></figure></p>
<p>主要是第二种使用方法，需要做的是以下的事情：</p>
<ul>
<li>创建Assets/ScriptTemplates/文件路径，模板文件放置在里面</li>
<li>模板文件命名规则：{priority}-{メニュー名}-{ファイル名}.{拡張子}.txt</li>
<li>重启Editor </li>
</ul>
<p>不需要MenuItem，只要起对了名字，放对了位置，那么重启一下就能用。厉害了。</p>
<p>知道了之后也不是很难嘛，然后我看到了一篇关于<strong>ScriptableObject</strong>式的脚本模板文章：</p>
<ul>
<li><a href="https://qiita.com/keidroid/items/40db91531c32a13c257f" target="_blank" rel="noopener">ScriptTemplatesでScriptableObjectのための環境構築</a></li>
</ul>
<p>虽然我暂时并没有找到任何非要使用ScriptableObject的理由，是我还不了解这个概念，什么情况下该使用这个东西不知道。</p>
<h3 id="EditorUserSettings"><a href="#EditorUserSettings" class="headerlink" title="EditorUserSettings"></a>EditorUserSettings</h3><ul>
<li><a href="http://kan-kikuchi.hatenablog.com/entry/EditorUserSettings" target="_blank" rel="noopener">プロジェクト内でデータを保存【Unity】【エディタ拡張】</a></li>
</ul>
<p>挺神奇的一个功能，用来保存本地设定相当理想的功能，但是貌似只有Get和Set两个方法写入的内容没法删除，别瞎写好么，我第一印象。</p>
<p>##先记下，后整理</p>
<ul>
<li><a href="http://baba-s.hatenablog.com/entry/2017/12/04/090000#Unity-%E3%82%A8%E3%83%87%E3%82%A3%E3%82%BF%E3%82%92%E7%B5%82%E4%BA%86%E3%81%97%E3%81%9F%E6%99%82" target="_blank" rel="noopener">【Unity】エディタ拡張で使用できるコールバックを40個まとめて紹介</a></li>
</ul>
<h2 id="Editor扩展实例"><a href="#Editor扩展实例" class="headerlink" title="Editor扩展实例"></a>Editor扩展实例</h2><h3 id="Sample-Template-Editor扩展的模板写法"><a href="#Sample-Template-Editor扩展的模板写法" class="headerlink" title="Sample-Template (Editor扩展的模板写法)"></a>Sample-Template (Editor扩展的模板写法)</h3><p>模板写法包含了一些关键部分，就是个参照。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">EditorExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CustomEditor(typeof(ExtensionClass), true)</span>]</span><br><span class="line">    public class ExtensionClassInspector ： Editor</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">protected</span> ExtensionClass extensionClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">protected</span> SerializedProperty attributeA;</span><br><span class="line">        <span class="keyword">protected</span> SerializedProoerty attributeB;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            extensionClass = target <span class="keyword">as</span> ExtensionClass;</span><br><span class="line"></span><br><span class="line">            attributeA = serializedObject.FindObject(<span class="string">"ExtensionClass_AttributeAName"</span>);</span><br><span class="line">            attributeB = serializedObject.FindObject(<span class="string">"ExtensionClass_AttributeBName"</span>);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            serializedObject.Update();</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.PropertyField(attributeA);</span><br><span class="line">            EditorGUILayout.PropertyField(attributeB);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            serializedObject.ApplyModifiedProperties();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最普通的格式就是上面那样，这是对Inspector格式的扩展，内容都是最基础的。需要注意的是在对<code>OnInspectorGUI</code>函数进行重写的时候，最开始要<strong>Update()</strong>，最后要<strong>ApplyModifiedProperties()</strong>。</p>
<h4 id="indentLevel-缩进"><a href="#indentLevel-缩进" class="headerlink" title="indentLevel (缩进)"></a>indentLevel (缩进)</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在上面的例子中的话</span></span><br><span class="line">EditorGUILayout.PropertyField(attributeA);</span><br><span class="line"></span><br><span class="line">EditorGUI.indentLevel++;</span><br><span class="line">EditorGUILayout.PropertyField(attributeB);</span><br><span class="line">EditorGUI.indentLevel--;</span><br></pre></td></tr></table></figure>
<h4 id="Content-Name-Inspector变量名设定"><a href="#Content-Name-Inspector变量名设定" class="headerlink" title="Content-Name (Inspector变量名设定)"></a>Content-Name (Inspector变量名设定)</h4><p>在Inspector不指定变量名字的话就会使用默认的变量名字，但是也可以自己设置。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EditorGUILayout.PropertyField(attributeA, <span class="keyword">new</span> GUIContent(<span class="string">"NameA"</span>));</span><br></pre></td></tr></table></figure>
<p>这里的话就不自觉的产生了<strong>EditorGUILayout</strong>是什么的想法，还有其它的作用吧</p>
<ol>
<li>EditorGUILayout</li>
<li>GUIContent</li>
</ol>
<h4 id="Type-judgement-类型判断"><a href="#Type-judgement-类型判断" class="headerlink" title="Type-judgement (类型判断)"></a>Type-judgement (类型判断)</h4><p>在<code>OnInspectorGUI</code>函数中也想要使用条件判断，这个时候不知道变量的类型不好办，上面的代码中表示的，变量类型都是<strong>SerializedProperty</strong>，条件语句对这个变量类型并不知晓。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(attributeA.boolValue) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(attributeB.intValue) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>等等类型，基本数据类型应该都会有覆盖到，不太清楚。</p>
<h4 id="Disable-Area-Inspector在运行时添加不可交互内容"><a href="#Disable-Area-Inspector在运行时添加不可交互内容" class="headerlink" title="Disable-Area (Inspector在运行时添加不可交互内容)"></a>Disable-Area (Inspector在运行时添加不可交互内容)</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(EditorAppliation.isPlaying)</span><br><span class="line">&#123;</span><br><span class="line">    EditorGUILayout.BeginVertical(GUI.skin.box);</span><br><span class="line">    EditorGUILayout.LabelField(<span class="string">"Running status"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EditorGUI.BeginDisabledGroup(<span class="literal">true</span>);</span><br><span class="line">    EditorGUILayout.PropertyField(flag1);</span><br><span class="line">    EditorGUILayout.PropertyField(flag2);</span><br><span class="line">    EditorGUI.EndDisabledGroup();</span><br><span class="line"></span><br><span class="line">    EditorGUILayout.BeginHorizontal();</span><br><span class="line">    GUILayout.FlexibleSpace();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GUILayout.Button(<span class="string">"buttonA"</span>, GUILayout.Width(<span class="number">100</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        (target <span class="keyword">as</span> ExtensionClass)?.SampleFunctionA();</span><br><span class="line">    &#125;</span><br><span class="line">    EditorGUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">    EditorGUILayout.EndVertical();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我只是拿来用而已…..出现了好多我不会用的控件。还需要学习啊。</p>
<h3 id="Inspector中显示List元素"><a href="#Inspector中显示List元素" class="headerlink" title="Inspector中显示List元素"></a>Inspector中显示List元素</h3><ul>
<li><a href="http://light11.hatenadiary.com/entry/2019/04/13/232549" target="_blank" rel="noopener">【Unity】【エディタ拡張】配列やリストのInspector表示を改良する</a></li>
</ul>
<p>因为比我想象的要麻烦，我就直接用了人家的代码……原本颜色什么的都无所谓的。</p>
<p>真的超级麻烦，如果希望上面的List中的元素是List又该怎么办呢？</p>
<p>答案是没人这么写啊…只好自己写个类，类里面的属性加上List好了。</p>
<ol>
<li>error解决</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsupport type ..</span><br><span class="line">ApplyModifiedProperties()</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://answers.unity.com/questions/533541/unsupported-type-error-in-custom-editor-script.html" target="_blank" rel="noopener">‘Unsupported type’ error in custom editor script</a></li>
</ul>
<p>删掉重新再add component之后就修复了。</p>
<h3 id="Inspector中显示多元List"><a href="#Inspector中显示多元List" class="headerlink" title="Inspector中显示多元List"></a>Inspector中显示多元List</h3><ul>
<li><a href="http://kan-kikuchi.hatenablog.com/entry/ValueListList" target="_blank" rel="noopener">多次元のListをInspectorに表示する【Unity】</a></li>
</ul>
<p>方法很简单，但是这里遇见了一个问题，因为使用了Inspector扩展，Inspector上不显示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// EditorGUILayout.PropertyField(pathAnchors);</span><br><span class="line">EditorGUILayout.PropertyField(pathAnchors, true);</span><br></pre></td></tr></table></figure></p>
<p>加上一个true的参数就好了，原因我也不知道，之后在调查吧。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AreaPathAnchor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;GameObject&gt; List = <span class="keyword">new</span> List&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AreaPathAnchor</span>(<span class="params">List&lt;GameObject&gt; list</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List = list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> List&lt;AreaPathAnchor&gt; pathAnchors = <span class="keyword">new</span> List&lt;AreaPathAnchor&gt;();</span><br></pre></td></tr></table></figure>
<p>Inspector扩展中对应的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public override void OnInspectorGUI()</span><br><span class="line">&#123;</span><br><span class="line">    EditorGUILayout.PropertyField(pathAnchors, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Inspector中加入HDRColor选择-未整理"><a href="#Inspector中加入HDRColor选择-未整理" class="headerlink" title="Inspector中加入HDRColor选择(未整理)"></a>Inspector中加入HDRColor选择(未整理)</h3><p>其实这个属性也不需要刻意的去扩展，只要在属性前加上限定Unity就会自动处理了。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">ColorUsage(false,true)</span>] <span class="keyword">private</span> Color color1;</span><br></pre></td></tr></table></figure></p>
<p>像这样子。</p>
<p>关于这个属性的更详细的说明之后再整理。</p>
<ul>
<li><a href="https://docs.unity3d.com/ScriptReference/ColorUsageAttribute-ctor.html" target="_blank" rel="noopener">ColorUsageAttribute Constructor</a></li>
<li><a href="https://nopitech.com/2019/01/29/post-962/" target="_blank" rel="noopener">マテリアルのEmissionを操作</a></li>
</ul>
<h3 id="MinMaxSlider实现-（可以拖拽的SliderBar"><a href="#MinMaxSlider实现-（可以拖拽的SliderBar" class="headerlink" title="MinMaxSlider实现 （可以拖拽的SliderBar)"></a>MinMaxSlider实现 （可以拖拽的SliderBar)</h3><p>目的是实现一个有最大值和最小值的可拖拽的SlideBar，而且最大值和最小值可以指定，但是不能超过固定的范围。</p>
<p>用的是自己做的项目中的一些实现，所以直接粘贴了。</p>
<p>首先是要扩展的变量声明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">namespace CubeFantasy.EditorExtension</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// Sample Editor Extension basic class.</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    ///</span><br><span class="line">    [Serializable, AddComponentMenu(&quot;CubeFantasy/SampleEditorExtension&quot;)]</span><br><span class="line">    public class SampleEditorExtension : MonoBehaviour</span><br><span class="line">    &#123;</span><br><span class="line">        // sample for MinMaxSlider</span><br><span class="line">        [SerializeField, Range(0, 30), HideInInspector]</span><br><span class="line">        public int timeMin = 0;</span><br><span class="line">        [SerializeField, Range(0, 30), HideInInspector]</span><br><span class="line">        public int timeMax = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是真正的扩展实现：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> CubeFantasy.EditorExtension;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CubeFantasy</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CustomEditor(typeof(SampleEditorExtension),true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleEditorExtensionInspector</span> : <span class="title">Editor</span></span><br><span class="line">    &#123;</span><br><span class="line">        SerializedProperty TimeMin;</span><br><span class="line">        SerializedProperty TimeMax;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            TimeMin = serializedObject.FindProperty(<span class="string">"timeMin"</span>);</span><br><span class="line">            TimeMax = serializedObject.FindProperty(<span class="string">"timeMax"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            serializedObject.Update();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// base.OnInspectorGUI();</span></span><br><span class="line"></span><br><span class="line">            EditorGUILayout.BeginHorizontal();</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.PrefixLabel(<span class="string">"MinMaxSlider"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> min = (<span class="keyword">float</span>)TimeMin.intValue;</span><br><span class="line">            <span class="keyword">var</span> max = (<span class="keyword">float</span>)TimeMax.intValue;</span><br><span class="line"></span><br><span class="line">            min = Mathf.Clamp((<span class="keyword">int</span>)EditorGUILayout.FloatField(min), <span class="number">0</span>, max);</span><br><span class="line">            EditorGUILayout.MinMaxSlider(<span class="keyword">ref</span> min, <span class="keyword">ref</span> max, <span class="number">0</span>, <span class="number">30</span>);</span><br><span class="line">            max = Mathf.Clamp((<span class="keyword">int</span>)EditorGUILayout.FloatField(max), min, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">            TimeMin.intValue = (<span class="keyword">int</span>)min;</span><br><span class="line">            TimeMax.intValue = (<span class="keyword">int</span>)max;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.EndHorizontal();</span><br><span class="line"></span><br><span class="line">            serializedObject.ApplyModifiedProperties();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后实现的效果：</p>
<p><img src="MinMaxSlider.png" alt="MinMaxSlider实现效果"></p>
<h3 id="Foldout-and-window-Popup-实现"><a href="#Foldout-and-window-Popup-实现" class="headerlink" title="Foldout and window Popup 实现"></a>Foldout and window Popup 实现</h3><p>这是一个小的功能，和一个大的功能，我以为很简单但实际上是非常的浮复杂，涉及的知识也不少。我将其分为几部实现。</p>
<p>主要是参考了公司大佬的Wwise的Event的扩展，方便在Editor中添加删除WwiseEvent和选择WwiseEvent。我想这个功能会很常见就想着自己保存下来实践一下，发现要实现的内容不是那么简单。</p>
<h4 id="Foldout-实现"><a href="#Foldout-实现" class="headerlink" title="Foldout 实现"></a>Foldout 实现</h4><p>折叠效果的实现很简单，借助Unity的<code>EditorGUILayout.Foldout(bool folding, &quot;ContentName&quot;)</code>直接使用就可以了。重要的是需要折叠的内容，这次我要举的列子是ArrayList。</p>
<p>这是我们要进行扩展的对象：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略using部分</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CubeFantasy.EditorExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Sample Editor Extension basic class.</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span></span></span><br><span class="line">    [<span class="meta">Serializable, AddComponentMenu(<span class="meta-string">"CubeFantasy/SampleEditorExtension"</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleEditorExtension</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// sample for foldout and pop up list</span></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">public</span> List&lt;<span class="keyword">string</span>&gt; WwiseEventNameList = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是的，实际上我们想要扩展的只是这个文字列的数组而已，但是我希望这个文字列的数组，在Inspector上的表现是</p>
<ul>
<li>可以折叠</li>
<li>可以动态添加元素</li>
<li>添加的元素是我们指定添加的(Popup Window)</li>
<li>甚至可以在PopWindow中进行查找</li>
</ul>
<p>下面是Inspector的扩展实现，首先是Flodout实现：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略using部分的内容</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CubeFantasy</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">CustomEditor(typeof(SampleEditorExtension), true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SampleEditorExtensionInspector</span> : <span class="title">Editor</span></span><br><span class="line">    &#123;</span><br><span class="line">        SampleEditorExtension SampleObjectScript;</span><br><span class="line"></span><br><span class="line">        SerializedProperty WwiseEventName;</span><br><span class="line">        SerializedProperty WwiseEventNameList;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> floding = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            SampleObjectScript = target <span class="keyword">as</span> SampleEditorExtension;</span><br><span class="line"></span><br><span class="line">            WwiseEventNameList = serializedObject.FindProperty(<span class="string">"WwiseEventNameList"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInspectorGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            serializedObject.Update();</span><br><span class="line">            <span class="comment">// base.OnInspectorGUI();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Sample for Flodout</span></span><br><span class="line">            <span class="keyword">if</span> (floding = EditorGUILayout.Foldout(floding, <span class="string">"SampleFoldout"</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                EditorGUI.indentLevel++;</span><br><span class="line">                <span class="keyword">var</span> length = WwiseEventNameList.arraySize;</span><br><span class="line">                <span class="keyword">var</span> newLength = EditorGUILayout.IntField(<span class="string">"Size"</span>, length);</span><br><span class="line">                <span class="keyword">if</span> (newLength &gt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> currentSize = WwiseEventNameList.arraySize;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newLength - currentSize; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        WwiseEventNameList.InsertArrayElementAtIndex(WwiseEventNameList.arraySize);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newLength &lt; length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> currentSize = WwiseEventNameList.arraySize;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; currentSize - newLength; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        WwiseEventNameList.DeleteArrayElementAtIndex(WwiseEventNameList.arraySize - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; WwiseEventNameList.arraySize; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    WwiseEventNameField(WwiseEventNameList.GetArrayElementAtIndex(i));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                EditorGUI.indentLevel--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serializedObject.ApplyModifiedProperties();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">WwiseEventNameField</span>(<span class="params">SerializedProperty p</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> w = WwiseEvents.None;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">string</span>.IsNullOrEmpty(p.stringValue))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span></span><br><span class="line">                &#123;</span><br><span class="line">                    w = (WwiseEvents)Enum.Parse(<span class="keyword">typeof</span>(WwiseEvents), p.stringValue, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (ArgumentException)</span><br><span class="line">                &#123;</span><br><span class="line">                    UnityEngine.Debug.LogError(<span class="string">$"<span class="subst">&#123;SampleObjectScript.name&#125;</span> の <span class="subst">&#123;p.stringValue&#125;</span> は存在しません。"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> eventNamePopupRect = GUILayoutUtility.GetRect(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            eventNamePopupRect.y += EditorGUIUtility.singleLineHeight + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            EditorGUILayout.BeginHorizontal();</span><br><span class="line">            EditorGUILayout.PrefixLabel(<span class="string">"WwiseEventName"</span>);</span><br><span class="line"></span><br><span class="line">            eventNamePopupRect.x += EditorGUIUtility.labelWidth;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (EditorGUILayout.DropdownButton(<span class="keyword">new</span> GUIContent(w.GetDescription()), FocusType.Passive))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> WwiseEventSearchWindow().Popup(eventNamePopupRect, Enum.GetNames(<span class="keyword">typeof</span>(WwiseEvents)), w.GetDescription(),</span><br><span class="line">                    x =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        p.stringValue = ((WwiseEvents)x).GetDescription();</span><br><span class="line"></span><br><span class="line">                        serializedObject.ApplyModifiedProperties();</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            EditorGUILayout.EndHorizontal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的就是实现的一部分代码，为了能让其运行还缺三个部分：</p>
<ul>
<li><code>WwiseEvent</code>的<code>enum</code>类型</li>
<li><code>Enum</code>类型的扩展，好方便Wwise的类型获得其Attribute的Description内容</li>
<li>Popup窗口的扩展</li>
</ul>
<h4 id="WwiseEvent的enum创建"><a href="#WwiseEvent的enum创建" class="headerlink" title="WwiseEvent的enum创建"></a>WwiseEvent的enum创建</h4><p>主要为了用<code>enum</code>类型来管理Wwise的事件，什么场合下适合这么用呢，比如说想要把事件的名称传递给第三方库（这里就会Wwise），而这种事件又可能会产生很多，这种情况下，使用enum类型便能方便的管理。</p>
<p>这里的内容只要放到相应位置，比如说放置一些固定数据的文件内容中，然后把命名空间公开，方便扩展那一部分好使用就可以了。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CubeFantasy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CubeFantasyConst</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">enum</span> WwiseEvents : <span class="keyword">int</span></span><br><span class="line">        &#123;</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"None"</span>)</span>]</span><br><span class="line">            None,</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"Wwise_Event_Name_Sample_1"</span>)</span>]</span><br><span class="line">            Wwise_Event_Name_Sample_1,</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"Wwise_Event_Name_Sample_2"</span>)</span>]</span><br><span class="line">            Wwise_Event_Name_Sample_2,</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"Wwise_Event_Name_Sample_2"</span>)</span>]</span><br><span class="line">            Wwise_Event_Name_Sample_3,</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"Wwise_Event_Name_Sample_2"</span>)</span>]</span><br><span class="line">            Wwise_Event_Name_Sample_4,</span><br><span class="line">            [<span class="meta">System.ComponentModel.Description(<span class="meta-string">"Wwise_Event_Name_Sample_2"</span>)</span>]</span><br><span class="line">            Wwise_Event_Name_Sample_5</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="对Enum进行扩展"><a href="#对Enum进行扩展" class="headerlink" title="对Enum进行扩展"></a>对Enum进行扩展</h4><p>可以看到上面我们为WwiseEvent添加了Description，我也不知道中文怎么翻译，反正就是那个意思，为这个枚举的元素添加了属性描述，要取得这个描述就需要我们为Enum进行扩展。</p>
<p>那么Enum是什么呢？我也不清楚…</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.ComponentModel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CubeFantasy.Extensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumExtensions</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> <span class="title">GetDescription</span>(<span class="params"><span class="keyword">this</span> Enum <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> field = <span class="keyword">value</span>.GetType().GetField(<span class="keyword">value</span>.ToString());</span><br><span class="line">            <span class="keyword">var</span> attribute = Attribute.GetCustomAttribute(field, <span class="keyword">typeof</span>(DescriptionAttribute)) <span class="keyword">as</span> DescriptionAttribute;</span><br><span class="line">            <span class="keyword">if</span>(attribute != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> attribute.Description;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法我在学习UniRx的时候经常看到，貌似是C#的写法，可以为一个类添加在类外的静态函数？参数要使用本身<code>this</code>，当进行调用的时候this是缺省的。在有多个参数的时候，第一个一定是this，然后调用的时候是缺省的。</p>
<p>感觉C#方面的技术要提升了。</p>
<h4 id="对PopUpWindow进行扩展实现"><a href="#对PopUpWindow进行扩展实现" class="headerlink" title="对PopUpWindow进行扩展实现"></a>对PopUpWindow进行扩展实现</h4><p>即上面的代码中出现的<code>WwiseEventSearchWindow</code>这个类的实现，内容我没有搞懂，直接Copy过来就使用了。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WwiseEventSearchWindow</span> : <span class="title">PopupWindowContent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">FilterItem</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> WindowWidth = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> WindowHeight</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> height = <span class="number">0.0</span>f;</span><br><span class="line">            <span class="keyword">var</span> singleLineHeight = EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing;</span><br><span class="line"></span><br><span class="line">            height += (Math.Min(filterdItems.Length, <span class="number">10</span>) + <span class="number">1</span>) * singleLineHeight;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector2 scroll;</span><br><span class="line">    <span class="keyword">int</span> selectedIndex = <span class="number">0</span>;</span><br><span class="line">    FilterItem[] list;</span><br><span class="line">    FilterItem[] filterdItems;</span><br><span class="line">    Action&lt;<span class="keyword">int</span>&gt; onCloseAction;</span><br><span class="line">    <span class="keyword">bool</span> init;</span><br><span class="line">    <span class="keyword">string</span> filter;</span><br><span class="line"></span><br><span class="line">    GUIStyle toolbarSearchField;</span><br><span class="line">    GUIStyle toolbarSearchFieldCancelButton;</span><br><span class="line">    GUIStyle toolbarSearchFieldCancelButtonEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> サイズを取得する</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Vector2 <span class="title">GetWindowSize</span>(<span class="params"></span>) </span>=&gt; <span class="keyword">new</span> Vector2(WindowWidth, WindowHeight);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Popup</span>(<span class="params">Rect rect, <span class="keyword">string</span>[] list_, <span class="keyword">string</span> selectedVal, Action&lt;<span class="keyword">int</span>&gt; onClose</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list_.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list_[i] == selectedVal)</span><br><span class="line">            &#123;</span><br><span class="line">                selectedIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        init = <span class="literal">true</span>;</span><br><span class="line">        list = list_.Select((item, i) =&gt; <span class="keyword">new</span> FilterItem() &#123; Index = i, Name = item &#125;).ToArray();</span><br><span class="line">        filterdItems = list;</span><br><span class="line">        onCloseAction = onClose;</span><br><span class="line"></span><br><span class="line">        UnityEditor.PopupWindow.Show(rect, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> GUI描画</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params">Rect rect</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newFilter = SearchFilterField(filter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (init || newFilter != filter)</span><br><span class="line">        &#123;</span><br><span class="line">            init = <span class="literal">false</span>;</span><br><span class="line">            filter = newFilter;</span><br><span class="line">            filterdItems = list</span><br><span class="line">                .Where(x =&gt; x.Index == selectedIndex</span><br><span class="line">                    || <span class="keyword">string</span>.IsNullOrEmpty(filter)</span><br><span class="line">                    || x.Name.ToLower().Contains(filter.ToLower()))</span><br><span class="line">                .ToArray();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scroll = EditorGUILayout.BeginScrollView(scroll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> style = GUI.skin.GetStyle(<span class="string">"ExposablePopupItem"</span>);</span><br><span class="line">        style.richText = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; filterdItems.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> item = filterdItems[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> flag = GUILayout.Toggle(selectedIndex == item.Index, FormatString(item.Name, filter), style);</span><br><span class="line">            <span class="keyword">if</span> (flag != (selectedIndex == item.Index))</span><br><span class="line">            &#123;</span><br><span class="line">                selectedIndex = item.Index;</span><br><span class="line">                onCloseAction(selectedIndex);</span><br><span class="line">                editorWindow.Close();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EditorGUILayout.EndScrollView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> searchFieldHash = <span class="string">"SearchBoxTestWindow_SearchField"</span>.GetHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">SearchFilterField</span>(<span class="params"><span class="keyword">string</span> filter</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> style = GUI.skin.GetStyle(<span class="string">"ExposablePopupItem"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; filterdItems.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> w = style.CalcSize(<span class="keyword">new</span> GUIContent(filterdItems[i].Name));</span><br><span class="line">            maxWidth = Math.Max(maxWidth, (<span class="keyword">int</span>)w.x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WindowWidth = maxWidth + <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> rect = GUILayoutUtility.GetRect(<span class="number">16</span>f, <span class="number">24</span>f,</span><br><span class="line">            EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing,</span><br><span class="line">            EditorGUIUtility.singleLineHeight + EditorGUIUtility.standardVerticalSpacing,</span><br><span class="line">            <span class="keyword">new</span> GUILayoutOption[] &#123; GUILayout.Width(maxWidth) &#125;);</span><br><span class="line">        rect.x += <span class="number">4</span>f;</span><br><span class="line">        rect.y += <span class="number">4</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> controlID = GUIUtility.GetControlID(searchFieldHash, FocusType.Passive, rect);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ToolbarSearchField(controlID, rect, filter, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">ToolbarSearchField</span>(<span class="params"><span class="keyword">int</span> id, Rect position, <span class="keyword">string</span> text, <span class="keyword">bool</span> showWithPopupArrow</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> position2 = position;</span><br><span class="line">        position2.width -= <span class="number">14</span>f;</span><br><span class="line">        <span class="keyword">var</span> position3 = position;</span><br><span class="line">        position3.x += position.width;</span><br><span class="line">        position3.width = <span class="number">14</span>f;</span><br><span class="line"></span><br><span class="line">        GUI.SetNextControlName(<span class="string">"filterField"</span>);</span><br><span class="line">        text = EditorGUI.TextField(position, text, toolbarSearchField);</span><br><span class="line">        GUI.FocusControl(<span class="string">"filterField"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (text == <span class="string">""</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            GUI.Button(position3, GUIContent.none, toolbarSearchFieldCancelButtonEmpty);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GUI.Button(position3, GUIContent.none, toolbarSearchFieldCancelButton))</span><br><span class="line">            &#123;</span><br><span class="line">                text = <span class="string">""</span>;</span><br><span class="line">                GUIUtility.keyboardControl = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">private</span> GUIStyle <span class="title">GetStyle</span>(<span class="params"><span class="keyword">string</span> styleName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> style = GUI.skin.FindStyle(styleName);</span><br><span class="line">        <span class="keyword">if</span> (style == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            style = EditorGUIUtility.GetBuiltinSkin(EditorSkin.Inspector).FindStyle(styleName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (style == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            style = <span class="keyword">new</span> GUIStyle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">string</span> <span class="title">FormatString</span>(<span class="params"><span class="keyword">string</span> text, <span class="keyword">string</span> filter</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(filter))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> text;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> index = text.IndexOf(filter, StringComparison.CurrentCultureIgnoreCase);</span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (text.Length &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    b.Append(text);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            b.Append(text.Substring(<span class="number">0</span>, index));</span><br><span class="line">            b.Append(<span class="string">"&lt;b&gt;&lt;color=cyan&gt;"</span>);</span><br><span class="line">            b.Append(text.Substring(index, filter.Length));</span><br><span class="line">            b.Append(<span class="string">"&lt;/color&gt;&lt;/b&gt;"</span>);</span><br><span class="line">            text = text.Substring(index + filter.Length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 開いたときの処理</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnOpen</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        toolbarSearchField = GetStyle(<span class="string">"ToolbarSeachTextField"</span>);</span><br><span class="line">        toolbarSearchFieldCancelButton = GetStyle(<span class="string">"ToolbarSeachCancelButton"</span>);</span><br><span class="line">        toolbarSearchFieldCancelButtonEmpty = GetStyle(<span class="string">"ToolbarSeachCancelButtonEmpty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 閉じたときの処理</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnClose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然我不搞懂也行，当到了一定时间我就可以直接复制使用，但是万一出现了一些更新，里面的内容可能就会变得一团糟。</p>
<p><strong>所以我还是很有必要把这一部分的内容完全搞懂的。</strong></p>
<h4 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h4><p>写了那么多，实现的内容一张图片就足够总结了，这一部分说来简单也很复杂，算是各种知识的拓展了。</p>
<p><img src="FoldoutAndPopupView.png" alt="实现效果"></p>
<h4 id="Foldout效果的官网实现"><a href="#Foldout效果的官网实现" class="headerlink" title="Foldout效果的官网实现"></a>Foldout效果的官网实现</h4><ul>
<li><a href="https://docs.unity3d.com/ja/current/ScriptReference/EditorGUILayout.Foldout.html" target="_blank" rel="noopener">EditorGUILayout.Foldout</a></li>
</ul>
<p>嘛，重要的不是他的实现，而是里面的东西，一些没见过的东西。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a foldable menu that hides/shows the selected transform position.</span></span><br><span class="line"><span class="comment">// If no Transform is selected, the Foldout item will be folded until</span></span><br><span class="line"><span class="comment">// a transform is selected.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FoldoutUsage</span> : <span class="title">EditorWindow</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> showPosition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">string</span> status = <span class="string">"Select a GameObject"</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">"Examples/Foldout Usage"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        FoldoutUsage window = (FoldoutUsage)GetWindow(<span class="keyword">typeof</span>(FoldoutUsage));</span><br><span class="line">        window.Show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        showPosition = EditorGUILayout.Foldout(showPosition, status);</span><br><span class="line">        <span class="keyword">if</span> (showPosition)</span><br><span class="line">            <span class="keyword">if</span> (Selection.activeTransform)</span><br><span class="line">            &#123;</span><br><span class="line">                Selection.activeTransform.position =</span><br><span class="line">                    EditorGUILayout.Vector3Field(<span class="string">"Position"</span>, Selection.activeTransform.position);</span><br><span class="line">                status = Selection.activeTransform.name;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Selection.activeTransform)</span><br><span class="line">        &#123;</span><br><span class="line">            status = <span class="string">"Select a GameObject"</span>;</span><br><span class="line">            showPosition = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnInspectorUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Repaint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次见到的弹出新窗口的使用<code>(FoldoutUsage)GetWindow(typeof(FoldoutUsage))</code>，和<code>Selection.activeTransform</code>的使用。</p>
<p>至于这段代码的效果就是，调用这个方法后弹出一个窗口，里面包含着你选定物体的Transform，然后可以折叠，但是只能选一个，多选没有用。</p>
<p>都是比较重要的知识。</p>
<h3 id="UnityEditor-Inspector-script-field"><a href="#UnityEditor-Inspector-script-field" class="headerlink" title="UnityEditor Inspector script field"></a>UnityEditor Inspector script field</h3><p>当我选择注释掉<code>base.OnInspectorGUI()</code>这一行的时候，那个显示脚本名称的ScriptField就消失了，虽然看起来更清楚了但是有的时候还是会有混淆，这里讲如何恢复这个<em>ScriptField</em>。</p>
<p>首先是参考了下面两篇文章：</p>
<ul>
<li><a href="https://answers.unity.com/questions/550829/how-to-add-a-script-field-in-custom-inspector.html" target="_blank" rel="noopener">How to add a “Script” field in custom inspector?</a></li>
<li><a href="http://sokuhatiku.hateblo.jp/entry/2016/12/13/174513" target="_blank" rel="noopener">UnityのEditor拡張で「Script」フィールドを設置する方法</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CustomEditor(typeof(SampleClass))]</span><br><span class="line">public class SampleClassInspector : Editor</span><br><span class="line">&#123;</span><br><span class="line">    MonoScript script = null;</span><br><span class="line"></span><br><span class="line">    private void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        script = MonoScript.FromMonoBehaviour((SampleClass)target);</span><br><span class="line">    &#125;</span><br><span class="line">    public override void OnInspectorGUI()</span><br><span class="line">    &#123;</span><br><span class="line">        serializedObject.Update();</span><br><span class="line">        // base.OnInspectorGUI();</span><br><span class="line">        EditorGUI.BeginDisabledGroup(true);</span><br><span class="line">        EditorGUILayout.ObjectField(&quot;Script&quot;, script, typeof(MonoScript), false);</span><br><span class="line">        EditorGUI.EndDisabledGroup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码实现就是那样，至于参数，等遇到之后再追加说明吧。</p>
<h2 id="SerializedObject"><a href="#SerializedObject" class="headerlink" title="SerializedObject"></a>SerializedObject</h2><ul>
<li><a href="http://light11.hatenadiary.com/entry/2018/03/15/225709" target="_blank" rel="noopener">【Unity】【エディタ拡張】SerializedObjectの勘所をまとめてみる</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-トレマーチング入門</title>
    <url>/unityraymaching/</url>
    <content><![CDATA[<p>一时兴起，仔细阅读了一下公司前辈的投稿，看到了这个陌生的名词，刚开始一头雾水，不知道是干什么的，但是仔细了解一下后知道真是マジヤバくね。(未整理)</p>
<a id="more"></a>
<p>主要是Unity最新的更新可以使用工具来使用<strong>トレマーチング</strong>了。</p>
<ul>
<li><a href="https://twitter.com/notargs/status/1156241510670594048" target="_blank" rel="noopener">のたぐすさんのTweet</a></li>
</ul>
<p>激发了俺的求知欲。网上一搜，教程一大片，是我孤陋寡闻的错。</p>
<ul>
<li><a href="https://qiita.com/edo_m18/items/034665d42c562da88cb6" target="_blank" rel="noopener">[GLSL] レイマーチング入門 vol.1</a></li>
<li><p><a href="https://gam0022.net/tags/%E3%83%AC%E3%82%A4%E3%83%9E%E3%83%BC%E3%83%81%E3%83%B3%E3%82%B0/" target="_blank" rel="noopener">Unity×レイマーチングによる映像制作の実践手法</a></p>
</li>
<li><p><a href="https://www.slideshare.net/shohosoda9/threejs-58238484" target="_blank" rel="noopener">シェーダだけで世界を創る！three.jsによるレイマーチング</a></p>
</li>
</ul>
<p>这篇share中的链接：</p>
<ul>
<li><a href="https://twitter.com/motions_work/status/694898149622550528" target="_blank" rel="noopener">「How Raymarcher Works」</a></li>
</ul>
<p>确定不找时间整理么..</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>rendering</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的Prefab系统</title>
    <url>/unity-prefab-system/</url>
    <content><![CDATA[<p>关于Unity中的Prefab的使用。</p>
<a id="more"></a>
<ul>
<li><a href="http://kurihara-n.hatenablog.com/entry/2018/06/25/050035" target="_blank" rel="noopener">kurihara-nの日記</a></li>
<li><a href="https://qiita.com/Nitudon/items/e609dbcbf73cf5c3a17f" target="_blank" rel="noopener">Prefab Variants -Unity2018.3からのPrefab活用-</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Prefab</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-关于NativeArray</title>
    <url>/unity-native-array/</url>
    <content><![CDATA[<p>那一天，我听到了这个陌生的名词，不知道是什么，也不知道用来干什么的。它的名字叫”NativeArray”。</p>
<a id="more"></a>
<h2 id="NativeArray"><a href="#NativeArray" class="headerlink" title="NativeArray"></a>NativeArray</h2><ul>
<li><a href="https://www.urablog.xyz/entry/2018/03/24/140423" target="_blank" rel="noopener">【Unity】アセット読書会に行ってきたよ。NativeArrayってなんだろう？</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Performance提升</title>
    <url>/unity-performance/</url>
    <content><![CDATA[<p>我知道这只是早晚的事儿。</p>
<a id="more"></a>
<ul>
<li><a href="https://www.slideshare.net/UnityTechnologiesJapan/unity-111054310" target="_blank" rel="noopener">【CEDEC2018】一歩先のUnityでのパフォーマンス/メモリ計測、デバッグ術</a></li>
</ul>
<h2 id="UI部分"><a href="#UI部分" class="headerlink" title="UI部分"></a>UI部分</h2><p>大佬总是跟我说不要用Canvas，当然是指游戏运行中的某种情况，貌似公司的大佬对于UI的效率很是关心。因为我也不懂太多关于UI的渲染问题所以只能先记下。</p>
<ul>
<li><a href="https://unity3d.com/jp/how-to/unity-ui-optimization-tips" target="_blank" rel="noopener">Unity UI の最適化に関するヒント</a></li>
<li><a href="https://www.youtube.com/watch?v=_wxitgdx-UI&amp;index=7&amp;list=PLX2vGYjWbI0Rzo8D-vUCFVb_hHGxXWd9j" target="_blank" rel="noopener">Unite Europe 2017 - Squeezing Unity: Tips for raising performance</a></li>
</ul>
<p>上面的视频我看了两遍都没看完，中途都困得不行了…但是确实很重要，一定要整理。</p>
<h3 id="Unity中UI需要了解"><a href="#Unity中UI需要了解" class="headerlink" title="Unity中UI需要了解"></a>Unity中UI需要了解</h3><p>摘取上面的视频中的内容</p>
<blockquote>
<p><strong>The Absolute Basics</strong></p>
<ul>
<li>Canvases generate meshes &amp; draw them<ul>
<li>Drawing happens once per frame</li>
<li>Generation happens when “something changes”</li>
</ul>
</li>
<li>“Something changes” = “1 or more UI elements change”<ul>
<li>Change one UI element, dirty the whole canvas</li>
<li>Yes, one.</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>What’s a rebuild? Theoretically…</strong></p>
<ul>
<li>Three steps:<ul>
<li>Recalculate layouts of auto-layouted elements</li>
<li>Regenerate meshes for all <em>enabled</em> elements<ul>
<li><em>Yes, meshed are still created when alpha=0!</em></li>
</ul>
</li>
<li>Regenerate materials to help batch meshed</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>What’s a rebuild? In Reality…</strong></p>
<ul>
<li>Usually, all system are dirtied instead of individually</li>
<li>Notable exceptions:<ul>
<li>Color property</li>
<li>fill* properties on Image</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>After all that…</strong></p>
<ul>
<li>Canvas takes meshes, divides them into batches<ul>
<li>Sorts the meshes by depth (hierarchy order)</li>
<li><em>Yes, this involves a sort() operation!</em></li>
</ul>
</li>
<li>AllUI os transparent. No matter what.<ul>
<li>Overdraw is   a problem!</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>The Vicious Cycle</strong></p>
<ul>
<li>Sort means performance drops faster-than-linear as number of drawable elements rises.</li>
<li>Higher number of elements means a higher chance any given element will change.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Slice up your canvases!</strong></p>
<ul>
<li>Add more canvases.</li>
<li>Each canvas owns its own set of UI elements<ul>
<li>Elements on different canvases will not batch.</li>
</ul>
</li>
<li>Main tool for constraining size of UI batches.</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Nesting Canvases</strong></p>
<ul>
<li>Canvases can be created within other canvases</li>
<li>Child canvases inherit rendering settings.<ul>
<li>Maintain own geometry.</li>
<li>Perform own batching.</li>
</ul>
</li>
</ul>
</blockquote>
<p>后半段我开始听不太懂了……</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中的通信</title>
    <url>/unity-data-transission/</url>
    <content><![CDATA[<p>这篇文章主要是因为一篇讲Unity的实时数据通信内容博文很重要。</p>
<a id="more"></a>
<h2 id="MagicOnion"><a href="#MagicOnion" class="headerlink" title="MagicOnion"></a>MagicOnion</h2><p>因为数据传输也很重要，所以这篇文章非常重要。</p>
<ul>
<li><a href="http://tech.cygames.co.jp/archives/3181/" target="_blank" rel="noopener">MagicOnion – C#による .NET Core/Unity 用のリアルタイム通信フレームワーク</a></li>
</ul>
<h2 id="gPRC"><a href="#gPRC" class="headerlink" title="gPRC"></a>gPRC</h2><ul>
<li><a href="https://qiita.com/oohira/items/63b5ccb2bf1a913659d6" target="_blank" rel="noopener">gRPCって何？</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity-Shader学习</title>
    <url>/unity-shader-learning/</url>
    <content><![CDATA[<p>关于Unity的Shader，能说的内容很多，因为我是真的不懂。之前用了好长时间看了关于Unity的书，能看懂一些内容了，但是还远不到立马就能写的程度。这次把自己所见所得写下来。</p>
<a id="more"></a>
<h1 id="PostProcessing"><a href="#PostProcessing" class="headerlink" title="PostProcessing"></a>PostProcessing</h1><p>不知道该起什么名字为好。</p>
<h2 id="Post-Processing-Stack-v2"><a href="#Post-Processing-Stack-v2" class="headerlink" title="Post Processing Stack v2"></a>Post Processing Stack v2</h2><p>这个是一个Unity中方便添加PostProcessing特效的插件。</p>
<p>对这个插件有一个大体上的了解可以参照这篇文章：</p>
<ul>
<li><a href="https://www.gaprot.jp/gaprot-x-chogiken/xr/unity-lookdev-post-processing-stack-v2" target="_blank" rel="noopener">Unity ルックデヴ講座 Post Processing Stack v2編</a></li>
</ul>
<p>但是当你想要添加自己的自定义特效的话，就不够用了。</p>
<ul>
<li><a href="http://pond-comfat.hatenablog.com/entry/2019/01/23/031855" target="_blank" rel="noopener">Post Processing Stack v2にカスタムエフェクトを追加する方法</a></li>
</ul>
<p>使用这个插件添加自定义Post Processing Shader的话，就要写点代码了，不光是Shader的。</p>
<h1 id="Renderer-Pipeline"><a href="#Renderer-Pipeline" class="headerlink" title="Renderer Pipeline"></a>Renderer Pipeline</h1><h2 id="LWRP"><a href="#LWRP" class="headerlink" title="LWRP"></a>LWRP</h2><ul>
<li><a href="https://www.slideshare.net/UnityTechnologiesJapan/190130unitydojyo-tatsuhiko-yamamura" target="_blank" rel="noopener">【 Unity道場 1月 ~LWRPとシェーダー~】軽量レンダーパイプライン、Light Weight Renderer Pipeline…とは</a></li>
</ul>
<h2 id="Scriptable-Render-Pipeline"><a href="#Scriptable-Render-Pipeline" class="headerlink" title="Scriptable Render Pipeline"></a>Scriptable Render Pipeline</h2><ul>
<li><a href="https://github.com/Unity-Technologies/ScriptableRenderPipeline" target="_blank" rel="noopener">Unity Scriptable Render Pipeline</a></li>
</ul>
<h1 id="使用PostProcessingStack的实例"><a href="#使用PostProcessingStack的实例" class="headerlink" title="使用PostProcessingStack的实例"></a>使用PostProcessingStack的实例</h1><h2 id="使用PostProcess制作受伤效果"><a href="#使用PostProcess制作受伤效果" class="headerlink" title="使用PostProcess制作受伤效果"></a>使用PostProcess制作受伤效果</h2><p>感觉上就像是受到伤害的时候摄像机中心到边缘向红色渐变的效果。</p>
<p>首先是我使用的Unity版本是<strong>Unity2019.2.12f1</strong>。</p>
<p>参考的就除了上面贴出来的链接之外，还有最重要的官方文档了<a href="https://github.com/Unity-Technologies/PostProcessing/wiki/Writing-Custom-Effects" target="_blank" rel="noopener">PostProcessing-Writing Custom Effects</a></p>
<blockquote>
<p>Custom effects need a minimum of two files: a C# and a HLSL source files (note that HLSL gets cross-compiled to GLSL, Metal and others API by Unity so it doesn’t mean it’s restricted to DirectX).</p>
</blockquote>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.Rendering.PostProcessing;</span><br><span class="line"> </span><br><span class="line">[Serializable]</span><br><span class="line">[PostProcess(typeof(GrayscaleRenderer), PostProcessEvent.AfterStack, &quot;Custom/Grayscale&quot;)]</span><br><span class="line">public sealed class Grayscale : PostProcessEffectSettings</span><br><span class="line">&#123;</span><br><span class="line">    [Range(0f, 1f), Tooltip(&quot;Grayscale effect intensity.&quot;)]</span><br><span class="line">    public FloatParameter blend = new FloatParameter &#123; value = 0.5f &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public sealed class GrayscaleRenderer : PostProcessEffectRenderer&lt;Grayscale&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public override void Render(PostProcessRenderContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        var sheet = context.propertySheets.Get(Shader.Find(&quot;Hidden/Custom/Grayscale&quot;));</span><br><span class="line">        sheet.properties.SetFloat(&quot;_Blend&quot;, settings.blend);</span><br><span class="line">        context.command.BlitFullscreenTriangle(context.source, context.destination, sheet, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Important: this code has to be stored in a file named Grayscale.cs. Because of how serialization works in Unity, you have to make sure that the file is named after your settings class name or it won’t be serialized properly.</strong></p>
</blockquote>
<p>这里要注意的是脚本名字要一致。</p>
<h4 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h4><blockquote>
<p>The settings class holds the data for our effect. These are all the user-facing fields you’ll see in the volume inspector.</p>
</blockquote>
<p>之前用的时候就会觉得为什么还要做个这个类，原来是为了保存为PostProcess准备的预设数据，所以有<code>Serializable</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Serializable]</span><br><span class="line">[PostProcess(typeof(GrayscaleRenderer), PostProcessEvent.AfterStack, &quot;Custom/Grayscale&quot;)]</span><br><span class="line">public sealed class Grayscale : PostProcessEffectSettings</span><br><span class="line">&#123;</span><br><span class="line">    [Range(0f, 1f), Tooltip(&quot;Grayscale effect intensity.&quot;)]</span><br><span class="line">    public FloatParameter blend = new FloatParameter &#123; value = 0.5f &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……我觉得官网说的比我清楚多了，干脆贴上英文得了。</p>
<p>看英文，看英文。<a href="https://github.com/Unity-Technologies/PostProcessing/wiki/Writing-Custom-Effects" target="_blank" rel="noopener">Writing Custom Effects</a></p>
<h4 id="Renderer"><a href="#Renderer" class="headerlink" title="Renderer"></a>Renderer</h4><blockquote>
<p>Our renderer extends PostProcessEffectRenderer<t>, with T being the settings type to attach to this renderer.</t></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class GrayscaleRenderer : PostProcessEffectRenderer&lt;Grayscale&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public override void Render(PostProcessRenderContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        var sheet = context.propertySheets.Get(Shader.Find(&quot;Hidden/Custom/Grayscale&quot;));</span><br><span class="line">        sheet.properties.SetFloat(&quot;_Blend&quot;, settings.blend);</span><br><span class="line">        context.command.BlitFullscreenTriangle(context.source, context.destination, sheet, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看文档看文档。</p>
<h3 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h3><p>进入Shader的书写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shader &quot;Hidden/Custom/Grayscale&quot;</span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">        #include &quot;Packages/com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl&quot;</span><br><span class="line"></span><br><span class="line">        TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex);</span><br><span class="line">        float _Blend;</span><br><span class="line"></span><br><span class="line">        float4 Frag(VaryingsDefault i) : SV_Target</span><br><span class="line">        &#123;</span><br><span class="line">            float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.texcoord);</span><br><span class="line">            float luminance = dot(color.rgb, float3(0.2126729, 0.7151522, 0.0721750));</span><br><span class="line">            color.rgb = lerp(color.rgb, luminance.xxx, _Blend.xxx);</span><br><span class="line">            return color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">                #pragma vertex VertDefault</span><br><span class="line">                #pragma fragment Frag</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看文档，看文档。<strong>关于shader里面的内容还有好多我不懂的</strong>。</p>
<h3 id="Effect-ordering"><a href="#Effect-ordering" class="headerlink" title="Effect ordering"></a>Effect ordering</h3><h3 id="Custom-editor"><a href="#Custom-editor" class="headerlink" title="Custom editor"></a>Custom editor</h3><h3 id="Additional-notes"><a href="#Additional-notes" class="headerlink" title="Additional notes"></a>Additional notes</h3><h3 id="特效制作"><a href="#特效制作" class="headerlink" title="特效制作"></a>特效制作</h3><p>所以上面的使用说明看完之后，就是实现部分了。不知不觉就把上面的部分写到这一章节离了= =。</p>
<p>因为上面的实现都差不多，只记下Shader部分的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shader &quot;Hidden/Custom/Damage&quot;</span><br><span class="line">&#123;</span><br><span class="line">    HLSLINCLUDE</span><br><span class="line"></span><br><span class="line">#include &quot;Packages/com.unity.postprocessing/PostProcessing/Shaders/StdLib.hlsl&quot;</span><br><span class="line"></span><br><span class="line">    TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex);</span><br><span class="line">    float _Range;</span><br><span class="line">    float4 _Color;</span><br><span class="line"></span><br><span class="line">    float4 Frag(VaryingsDefault i) : SV_Target</span><br><span class="line">    &#123;</span><br><span class="line">        float2 uv = i.texcoord;</span><br><span class="line">        float4 color = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, uv);</span><br><span class="line">        float radiusFactor = (1 - _Range) * (1 - _Range) / 4;</span><br><span class="line">        float radius = saturate(((uv.x - 0.5) * (uv.x - 0.5) + (uv.y - 0.5) * (uv.y - 0.5)) / radiusFactor);</span><br><span class="line">        return saturate(color * (1 - radius) + _Color * radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ENDHLSL</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Cull Off ZWrite Off ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            HLSLPROGRAM</span><br><span class="line"></span><br><span class="line">                #pragma vertex VertDefault</span><br><span class="line">                #pragma fragment Frag</span><br><span class="line"></span><br><span class="line">            ENDHLSL</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些都是要做的准备工作，最后要把这个PostProcess应用到Camer上。</p>
<ul>
<li>Camera上添加PostProcessLayer组件，指定PostProcessEffect的layer</li>
<li>New一个GameObject，添加PostProcessVolume组件，可以是子物体</li>
<li>GameObject的Layer需要指定上面提到的layer</li>
</ul>
<p>这些是有可能会忘的，其他的就很简单了。别忘了New一个新的Profile。参数的话可以参照<a href="https://docs.unity3d.com/Packages/com.unity.postprocessing@2.0/api/UnityEngine.Rendering.PostProcessing.PostProcessVolume.html" target="_blank" rel="noopener">Class PostProcessVolume</a></p>
<h2 id="使用PostPerocess制作向纯色渐变的效果"><a href="#使用PostPerocess制作向纯色渐变的效果" class="headerlink" title="使用PostPerocess制作向纯色渐变的效果"></a>使用PostPerocess制作向纯色渐变的效果</h2><p>说起来上面的效果也只是这个效果的拓展，这个效果是我从巨佬那里偷学来的。</p>
<h1 id="关于Shader的一些文章"><a href="#关于Shader的一些文章" class="headerlink" title="关于Shader的一些文章"></a>关于Shader的一些文章</h1><ul>
<li><p><a href="https://en.wikibooks.org/wiki/Cg_Programming/Unity/Translucent_Bodies" target="_blank" rel="noopener">Cg Programming/Unity/Translucent Bodies</a></p>
</li>
<li><p><a href="https://roystan.net/articles/toon-shader.html" target="_blank" rel="noopener">Toon Shader</a></p>
</li>
<li><p><a href="http://tsubakit1.hateblo.jp/entry/2018/01/04/235520" target="_blank" rel="noopener">【Unity】良い感じに見える（屋内向け）ライティングの設定手順</a></p>
</li>
<li><p><a href="https://ics.media/entry/19728/" target="_blank" rel="noopener">Unity Post Processing Stackで作る光芒エフェクト</a></p>
</li>
<li><p><a href="http://light11.hatenadiary.com/entry/2018/03/15/000022" target="_blank" rel="noopener">【Unity】【シェーダ】ブルームを独自実装する</a></p>
</li>
</ul>
<p>原先在知乎上看到的文章，这回有大图看：</p>
<ul>
<li><p><a href="https://connect.unity.com/p/unite-2018-beng-pi-3-zai-unityzhong-shi-xian-gao-pin-zhi-de-qia-tong-xuan-ran-shang" target="_blank" rel="noopener">Unite 2018 | 《崩坏3》：在Unity中实现高品质的卡通渲染（上）</a></p>
</li>
<li><p><a href="http://vfxmike.blogspot.com/2018/07/dark-and-stormy.html" target="_blank" rel="noopener">Dark and Stormy</a></p>
</li>
</ul>
<p>一个关于Shader的WIKI，据说关于Unity的Shader讲得很详细。（但是貌似不翻墙看不到。）</p>
<ul>
<li><a href="https://en.wikibooks.org/wiki/Cg_Programming" target="_blank" rel="noopener">Cg Programming</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/git-learning/</url>
    <content><![CDATA[<p>Git的使用尤为重要，只要是做项目开发没有版本管理的话，那就没个玩。但是Git的使用虽然是很简单但是精通的话还是要时间。</p>
<a id="more"></a>
<p>这里就是要记下我在使用Git的过程中遇到的问题和解决方案。像记事本一样。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="https://github.com/geeeeeeeeek/git-recipes/wiki" target="_blank" rel="noopener">git-recipes</a></li>
</ul>
<p>这是Git的中文Wiki，我还没看过，真是罪过，一定要看！！</p>
<ul>
<li><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README.md" target="_blank" rel="noopener">Flight rules for Git</a></li>
</ul>
<p>有中文翻译。顺便一提这个是日语翻译<a href="https://blog.labot.jp/entry/2019/07/01/183204" target="_blank" rel="noopener">【永久保存版】Gitのあらゆるトラブルが解決する神ノウハウ集を翻訳した</a></p>
<h2 id="Git使用中遇到的"><a href="#Git使用中遇到的" class="headerlink" title="Git使用中遇到的"></a>Git使用中遇到的</h2><h3 id="关于换行符"><a href="#关于换行符" class="headerlink" title="关于换行符"></a>关于换行符</h3><ul>
<li><a href="https://qiita.com/uggds/items/00a1974ec4f115616580" target="_blank" rel="noopener">気をつけて！Git for Windowsにおける改行コード</a></li>
</ul>
<h3 id="关于差分（diff）"><a href="#关于差分（diff）" class="headerlink" title="关于差分（diff）"></a>关于差分（diff）</h3><p>在提交(add)代码之前，使用差分工具看看自己修改过的内容是一个极好的习惯，确保自己代码修改的地方，防止提交一些自己失误添加的内容。</p>
<p>最近就发生了我提交了迷之代码的尴尬事情，查看历史的提交记录，追溯到我，场面一度非常尴尬。</p>
<ul>
<li><a href="https://qiita.com/shibukk/items/8c9362a5bd399b9c56be" target="_blank" rel="noopener">忘れやすい人のための git diff チートシート</a></li>
</ul>
<h3 id="关于忽略文件的变动"><a href="#关于忽略文件的变动" class="headerlink" title="关于忽略文件的变动"></a>关于忽略文件的变动</h3><p>有的时候会遇见一些Run-Time类型的文件，可以上传一个版本但是每次运行的时候总会变，每次都要commit就很不现实，于是便有了这个问题：</p>
<p>如何停止对一个文件（或者文件夹中的文件）进行版本管理？</p>
<p>找到的方法是：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/936249/how-to-stop-tracking-and-ignore-changes-to-a-file-in-git" target="_blank" rel="noopener">How to stop tracking and ignore changes to a file in Git?</a></li>
</ul>
<blockquote>
<p>There are 3 options, you probably want #3</p>
<ol>
<li><p>This will keep the local file for you, but will delete it for anyone else when they pull.</p>
<p><code>git rm --cached &lt;file-name&gt;</code> or <code>git rm -r --cached &lt;folder-name&gt;</code></p>
</li>
<li><p>This is for optimization, like a folder with a large number of files, e.g. SDKs that probably won’t ever change. It tells git to stop checking that huge folder every time for changes, locally, since it won’t have any. The assume-unchanged index will be reset and file(s) overwritten if there are upstream changes to the file/folder (when you pull).</p>
<p> <code>git update-index --assume-unchanged &lt;path-name&gt;</code></p>
</li>
<li><p>This is to tell git you want your own independent version of the file or folder. For instance, you don’t want to overwrite (or delete) production/staging config files.</p>
<p> <code>git update-index --skip-worktree &lt;path-name&gt;</code></p>
</li>
</ol>
<p>It’s important to know that git update-index will not propagate with git, and each user will have to run it independently.</p>
</blockquote>
<p>我实际上使用的是第一种方法，但由于我是一个人开发的所以没有验证过是不是别人Pull的时候会删掉我取消Track的文件。</p>
<p>但我感觉我实际上应该使用的是第二种方法，的确是使用了某个SDK，即Plugins，基本上不会再有改动，除非其他人对插件的内容进行了修改。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>多人一起工作的时候就会经常遇到需要删除自己提交的远程分支的情况，在这里做一下记录。</p>
<p>首先先看一下自己本地的分支和远程的分支：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></p>
<p>在确认了想要删除的分支的名字之后首先执行本地的分支删除操作吧：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git brance -d Branch-Name</span><br></pre></td></tr></table></figure></p>
<p>如果没有什么问题本地的分支就会被删除。下一步是删除远程的分支<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -d origin Branch-Name</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了，上面的<code>-d</code>跟<code>--delete</code>是等效的。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://qiita.com/iorionda/items/c7e0aca399371068a9b8" target="_blank" rel="noopener">Git で不要になったローカルブランチ・リモートブランチを削除する方法</a></li>
</ul>
<h2 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h2><p>最近一直在用这个工具，很方便了，代替Git吧，但是遇到了问题。</p>
<p>在SourceTree中使用Git LFS的时候，文件超过一定大小当你准备提交的时候就会提醒你把这个文件交给Git LFS来处理，于是我照办了。由于这个文件的路径有些奇葩，有<code>space</code>的存在，于是我明明在<code>.gitattribute</code>文件中添加了路径，SourceTree还是会提醒我这个文件要用Git LFS来处理。</p>
<p>文件路径奇葩带空格又不是我的错，我只是导入一个插件而已。至于解决方案，那就是使用命令行工具来提交啊。关键时候还得是Bash。</p>
<p>参考了下面的文章：</p>
<ul>
<li>[<a href="https://github.com/git-lfs/git-lfs/issues/2668" target="_blank" rel="noopener">[:space:]] seam to prevent Git lfs to work with SourceTree</a></li>
</ul>
<h2 id="Git-LFS-2"><a href="#Git-LFS-2" class="headerlink" title="Git LFS 2"></a>Git LFS 2</h2><p>在UE4中可以使用这个插件来完成项目的多人协作，割舍不下的功能就是在UE4中对Asset进行编辑时可以远程加锁，UE4的Asset版本管理很麻烦的，又不能像C++代码那样简单的Merge。</p>
<ul>
<li>Github项目<a href="https://github.com/SRombauts/UE4GitPlugin" target="_blank" rel="noopener">Unreal Engine 4 Git Source Control Plugin</a></li>
</ul>
<h3 id="Git-LFS"><a href="#Git-LFS" class="headerlink" title="Git LFS"></a>Git LFS</h3><p>这东西用于管理大数据文件很有用，使用的时候也会遇到很多问题，当然是我的问题，上面SourceTree的内容就有提到。</p>
<p>关于一些命令的使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git lfs locks             #获取现在加锁文件的一览</span><br><span class="line">$ git lfs unlock --id=555   #为555号id文件解锁，当然是自己加锁的文件</span><br></pre></td></tr></table></figure></p>
<p>还有就是一些批量操作默认的GitLFS命令并不支持，这也是我要在这里记录这个的原因。</p>
<p>在<code>ProjectName/.git/config</code>文件里面添加下面的内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        lock = &quot;!f()&#123; git pull ; for file in \&quot;$@\&quot;; do git lfs lock $file; done &#125;;f&quot;</span><br><span class="line">        unlock = &quot;!f()&#123; for file in \&quot;$@\&quot;; do git lfs unlock $file; done &#125;;f&quot;</span><br><span class="line">        unlockall = &quot;!f() &#123; git lfs locks | grep [my-git-user-name] | cut -f 1 | while read -r file; do git lfs unlock $file; done; &#125;;f&quot;</span><br><span class="line">        locks = &quot;!f() &#123; git lfs locks; &#125;;f&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>[my-git-user-name]</code>根据自己的账户名字进行替换，使用<code>git lfs locks</code>就可以看到自己加锁的账户名字，<code>[]</code>是必须的，不要省略。</p>
<p>这样在使用下面的命令的时候，就会把自己加锁的文件全部解锁。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unlockall</span><br></pre></td></tr></table></figure></p>
<p><code>git unlock a.txt b.txt</code>和<code>git lock a.txt b.txt</code>这样可以对文件进行批量的加锁解锁操作，但还是需要指定路径，也许可以加以改造，指定id就可以简单的批量解锁文件，但是我也只是参照别人的文章复制过来的，对<code>.git/config</code>文件的内容语法也不是很了解。</p>
<p>参考文章:</p>
<ul>
<li><a href="https://qiita.com/gecko655/items/89085bad77fb83c98267" target="_blank" rel="noopener">Git LFS lockを使うためのエイリアス メモ</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的TraceFunctions</title>
    <url>/ue4-trace-fnctions/</url>
    <content><![CDATA[<p>UE4中的Trace比我想象中的要重要，除了模拟交互之外，获取两点之间的距离，也可以起到非常大的作用。(未整理）</p>
<a id="more"></a>
<h2 id="如何知道物体离地面的高度？"><a href="#如何知道物体离地面的高度？" class="headerlink" title="如何知道物体离地面的高度？"></a>如何知道物体离地面的高度？</h2><p>这是我迫切想要知道的事情，搜了一下果然发现有人问了相同的问题。</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/83065/how-to-obtain-landscape-height.html" target="_blank" rel="noopener">How to obtain landscape height?</a></li>
</ul>
<p>于是我就用Trace试了一下，完美。</p>
<h2 id="Trace-Functions"><a href="#Trace-Functions" class="headerlink" title="Trace Functions"></a>Trace Functions</h2><p><a href="https://wiki.unrealengine.com/Trace_Functions" target="_blank" rel="noopener">Trace Functions</a></p>
<p>基本上就是人家这篇Wiki写的内容，但是`LineTraceSingle这个函数编译没有通过，我用了<a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UWorld/LineTraceSingleByChannel/index.html" target="_blank" rel="noopener">UWorld::LineTraceSingleByChannel</a><br>来替代了。</p>
<h3 id="LineTraceSingleByChannel"><a href="#LineTraceSingleByChannel" class="headerlink" title="LineTraceSingleByChannel"></a>LineTraceSingleByChannel</h3><h4 id="FCollisionQueryParams"><a href="#FCollisionQueryParams" class="headerlink" title="FCollisionQueryParams"></a>FCollisionQueryParams</h4><h3 id="LineTraceSingleByObjectType"><a href="#LineTraceSingleByObjectType" class="headerlink" title="LineTraceSingleByObjectType"></a>LineTraceSingleByObjectType</h3><h4 id="FCollisionObjectQueryParams"><a href="#FCollisionObjectQueryParams" class="headerlink" title="FCollisionObjectQueryParams"></a>FCollisionObjectQueryParams</h4><h2 id="Collision"><a href="#Collision" class="headerlink" title="Collision"></a>Collision</h2><p>关于UE4中的碰撞系统，是个很复杂的问题，在这里只是针对Trace需要的碰撞记记载。</p>
<h3 id="Collision-Response-Reference"><a href="#Collision-Response-Reference" class="headerlink" title="Collision Response Reference"></a>Collision Response Reference</h3><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Physics/Collision/Reference/index.html" target="_blank" rel="noopener">Collision Response Reference</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>我所理解的Unity-IK</title>
    <url>/the-inverse-kinematics-wat-i-understand/</url>
    <content><![CDATA[<p>在程序中人物模型出现很自然的运动的时候，大部分情况下我都觉得应该是动画的运动。由动作设计师准备好的动画，工程师将动画拆分组合这样的。然而实际上貌似并不是。</p>
<a id="more"></a>
<h2 id="Root-Motion"><a href="#Root-Motion" class="headerlink" title="Root Motion"></a>Root Motion</h2><ul>
<li><a href="https://docs.unity3d.com/2018.3/Documentation/Manual/RootMotion.html" target="_blank" rel="noopener">Unity - Manual: Root Motion - how it works</a></li>
</ul>
<p>在此之前，先介绍一下RootMotion。</p>
<ul>
<li><a href="https://blog.csdn.net/swj524152416/article/details/54973164" target="_blank" rel="noopener">Generic 动画中 Root Motion的概念和使用</a></li>
</ul>
<h2 id="Inverse-Kinematics"><a href="#Inverse-Kinematics" class="headerlink" title="Inverse Kinematics"></a>Inverse Kinematics</h2><ul>
<li><a href="https://docs.unity3d.com/2018.3/Documentation/Manual/InverseKinematics.html" target="_blank" rel="noopener">Unity - Manual: Inverse Kinematics</a></li>
</ul>
<p>反向运动学，这是中文翻译，一开始是懵的。</p>
<blockquote>
<p>IK和FK对应，正向运动学就是根骨骼带动节点骨骼运动。而反向运动学就是由子节点带动父节点运动。</p>
</blockquote>
<ul>
<li><a href="https://www.cnblogs.com/ghl_carmack/archive/2012/11/12/2765658.html" target="_blank" rel="noopener">游戏中反向运动学(ik)的研究与简介 - 风恋残雪 - 博客园</a><br>话说这个大佬的文章，我应该常常关注的。<h3 id="IK使用"><a href="#IK使用" class="headerlink" title="IK使用"></a>IK使用</h3>在上面提到的官方文档中有大致的使用方法。具体的使用之后整理</li>
</ul>
<h3 id="VR-Final-IK"><a href="#VR-Final-IK" class="headerlink" title="VR - Final IK"></a>VR - Final IK</h3><p>这个算是主角了，这篇文章的目的就是熟悉并使用这个Asset。（好贵）</p>
<p>主要还是看人家的官方视频：</p>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=7__IafZGwvI&amp;list=PLVxSIA1OaTOu8Nos3CalXbJ2DrKnntMv6" target="_blank" rel="noopener">FINAL IK TUTORIAL</a></p>
</li>
<li><p><a href="http://www.root-motion.com/finalikdox/html/index.html" target="_blank" rel="noopener">Final IK Document</a></p>
</li>
<li><p><a href="https://qiita.com/_karukaru_/items/b74bb5bdf08f5de32d0e" target="_blank" rel="noopener">Final IK の VRIK の Solver にある各値の説明</a></p>
</li>
</ul>
<p>这个东西怎么说呢，我试着用了用，方便是方便，源码是C#的，读起来也不是很费力。但是最后我也就是用了FinalIk里的InteractionSystem，其他的都放弃了。想要在自己的代码里引用他的脚本文件会出error，然后一大堆的初始化内容需要重写，在Unity的Editor里直接拖拽就很方便，自己在代码里写就各种null。</p>
<p>搜了一下感觉这篇很有意思，先保存一下。</p>
<ul>
<li><a href="https://atl-hiroo.recruit-tech.co.jp/2018/01/unity_vive_virtual_idle/" target="_blank" rel="noopener">UnityとHTC VIVEでバーチャルアイドルに変身（ATL客員研究員寄稿記事） | Advanced Technology Lab.</a></li>
</ul>
<h2 id="Leap-Motion"><a href="#Leap-Motion" class="headerlink" title="Leap Motion"></a>Leap Motion</h2>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>IK</tag>
      </tags>
  </entry>
  <entry>
    <title>UniRx从入门到放弃</title>
    <url>/unirx-learning-note/</url>
    <content><![CDATA[<p>时隔一年再次接触Unity，发生了好多变化，也许是之前见识也少的原因，遇到了UniRx这个库，刚遇到的时候感觉真是无从下手，就俩接口，叫我看不出来个所以然。</p>
<a id="more"></a>
<h1 id="理解UniRx"><a href="#理解UniRx" class="headerlink" title="理解UniRx"></a>理解UniRx</h1><p>我来了，我表示我并没有理解UniRx，只知道是个什么东西远远不够。当出现Operator的使用的时候，我发现我根本不理解。</p>
<ul>
<li><p><a href="http://kan-kikuchi.hatenablog.com/entry/What_is_UniRx" target="_blank" rel="noopener">UniRx(ユニアールエックス)の基本的な使い方と具体的な利用例【Unity】【UniRx】</a></p>
</li>
<li><p><a href="https://kuailey.github.io/DungeonsGame/2016/11/06/UniRx-%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">UniRx 学习</a></p>
</li>
</ul>
<h2 id="Reactive-Extension"><a href="#Reactive-Extension" class="headerlink" title="Reactive Extension"></a>Reactive Extension</h2><h2 id="UniRx"><a href="#UniRx" class="headerlink" title="UniRx"></a>UniRx</h2><hr>
<ul>
<li>2020/02/17更新</li>
</ul>
<p>又是我们的老朋友，<strong>UniRX</strong>，这次我来彻彻底底的更新UniRX的内容了，因为发现要是还不好好的整理，深入理解UniRX的使用和原理，连热度都蹭不上了。</p>
<p>在逐渐接触到UniRx的过程中，更为准确的是接触现在项目的过程中，我对<strong>UniRX</strong>，<strong>Observable</strong>，<strong>UniTask</strong>这三者之间的界限越来越模糊，什么时间什么场合该使用哪个完全不清楚。</p>
<h3 id="从Observer模式理解UniRx"><a href="#从Observer模式理解UniRx" class="headerlink" title="从Observer模式理解UniRx"></a>从Observer模式理解UniRx</h3><p>主要参考文章：</p>
<ul>
<li><a href="https://learning.unity3d.jp/1324/" target="_blank" rel="noopener">ObserverパターンからはじめるUniRx</a></li>
</ul>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>观察者模式</strong>(Observer Pattern)，即经常提到的设计模式的一种。实现<strong>事件的发行和订阅的一种设计模式</strong>。</p>
<p><img src="Observer-Pattern.png" alt="Observerパターン" title="ObserverParttern"></p>
<p>UniRx中登场的就是<code>Observer</code>和<code>Subject</code>这两个重要的概念。</p>
<ul>
<li>Observer<ul>
<li>观察者，监听者(Listener)，Message Receiver</li>
</ul>
</li>
</ul>
<ul>
<li>Subject<ul>
<li>观察对象，Event发行方</li>
<li>记录着所有Observer的订阅</li>
</ul>
</li>
</ul>
<p>两者的关系就是<strong>Subject管理着所有订阅的Observer，Subject向Observer发送消息</strong>。</p>
<h4 id="简单的观察者模式实现"><a href="#简单的观察者模式实现" class="headerlink" title="简单的观察者模式实现"></a>简单的观察者模式实现</h4><ol>
<li><p><code>IMyObserver&lt;T&gt;</code>接口</p>
<ul>
<li>接收消息的接口  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">My</span></span><br><span class="line">&#123;</span><br><span class="line">    interface IMyObserver&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>收到消息的时候执行</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnReceived</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Observer的具体实现</p>
<ul>
<li>收到消息则打印消息  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">My</span></span><br><span class="line">&#123;</span><br><span class="line">    class PrintObserver&lt;T&gt; : IMyObserver&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> voi <span class="title">OnReceived</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            UnityEngine.Debug.Log(<span class="keyword">value</span>.ToString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>MySubject&lt;T&gt;</code>类的实现</p>
<ul>
<li>实现登记功能的类  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">class MySubject&lt;T&gt; : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IMyObserver&lt;T&gt;&gt; _observers = <span class="keyword">new</span> List&lt;IMyObserver&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Observer登记（订阅）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterObserver</span>(<span class="params">IMyObserver&lt;T&gt; observer</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _observers.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Observer解除登记（取消订阅）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterObserver</span>(<span class="params">IMyObserver&lt;T&gt; observer</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _observers.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 消息发行</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">pblic <span class="keyword">void</span> <span class="title">SendMessage</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> myObserver <span class="keyword">in</span> _observers)</span><br><span class="line">        &#123;</span><br><span class="line">            myObserver.OnReceived(<span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _observers.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用测试</p>
<ul>
<li><p>这里可以生成多个Observer来举例，这里只列出一个</p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成Subject</span></span><br><span class="line"><span class="keyword">var</span> mySubject = <span class="keyword">new</span> MySubject&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer生成</span></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> PrintObserver&lt;<span class="keyword">string</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登记Observer到Sbject上</span></span><br><span class="line">mySubject.RegisterObserver(observer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送信</span></span><br><span class="line">mySubject.SendMessage(<span class="string">"Hello!"</span>);</span><br><span class="line">mySubject.SendMessage(<span class="string">"World!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除所有登记</span></span><br><span class="line">mySubject.Dispose();</span><br></pre></td></tr></table></figure>
<p>  结果是依次输出两个字符串。</p>
</li>
</ul>
</li>
</ol>
<h4 id="向UniRx进行转变"><a href="#向UniRx进行转变" class="headerlink" title="向UniRx进行转变"></a>向UniRx进行转变</h4><ol>
<li><p><strong>UniRx.IObserver&lt;T></strong></p>
<ul>
<li><p>IMyObserve&lt;T> -&gt; <span style="color:orange">UniRx.IObserver&lt;T></span></p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">UniRx</span></span><br><span class="line">&#123;</span><br><span class="line">    public interface IObserver&lt;T&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception error</span>)</span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  图片更为直观,需要注意的是:</p>
<ul>
<li>注意.NET4.6的时候变成了System.IObservable&lt;T></li>
<li>OnReceived(T value) -&gt; <span style="color:orange">OnNext(T value)</span></li>
</ul>
<p><img src="TransformToUniRx.png" alt="TransformToUniRx"></p>
</li>
<li><p>PrintObserver -&gt; <span style="color:orange">IObserver&lt;T></span></p>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">class PrintObserver&lt;T&gt; : IObserver&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnCompleted</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">"OnCompleted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnError</span>(<span class="params">Exception error</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UnityEngine.Debug.LogError(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnNext</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UnityEngine.Debug.Log(<span class="keyword">value</span>.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>UniRx.Subject&lt;T></strong><br>这里我们需要把<code>MySubject&lt;T&gt;</code>的接口分解一下，来对应<code>UniRx.Subject&lt;T&gt;</code>中的变化。</p>
<ul>
<li><p>将处理Observer部分的内容按照接口的形式分离:<br><img src="MySubjectObserver.png" alt="MySubjectObserver"></p>
</li>
<li><p>UniRx.<span style="color:orange">IObservable&lt;T></span>是声明负责订阅的接口<br><img src="IObservable.png" alt="IObsrvable"></p>
</li>
<li><p>Subject的发送消息处理，使用<code>IObserver&lt;T&gt;</code>接口来代替<br><img src="IObserver.png" alt="IObserver"></p>
</li>
<li><p>ISubject&lt;T>接口，只是用来为了证明这:是个Subject哦 的接口，当然只是文章里说的<br><img src="ISubject-Interface.png" alt="ISubject-Interface"></p>
</li>
<li><p>UniRx.Subject&lt;T>是对上面所有继承的接口的实装类<br><img src="SubjectClass.png" alt="SubjectClass"></p>
</li>
<li><p>使用的例子</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> UniRx.Subject&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> PrintObserver&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer订阅</span></span><br><span class="line"><span class="keyword">var</span> disposable = subject.Subscribe(observer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息发行</span></span><br><span class="line">subject.OnNext(<span class="string">"Hello!"</span>);</span><br><span class="line">subject.OnNext(<span class="string">"World!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer订阅取消</span></span><br><span class="line">disposable.Dispose();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束通知</span></span><br><span class="line">subject.OnCompleted();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我感觉是解除所有的订阅，难不成还有些其他比较重要的操作？</span></span><br><span class="line">subject.Dispose();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Subscribe()中经常见到的Lambda式<br>在UniRx的使用中，Lambda是非常常见的，以至于我几乎没有见到老老实实在<code>Subscribe()</code>的里面见到一个简单的变量。其原因就在于它的扩展方法。</p>
<p> 当向<code>Subscribe()</code>中传递一个Lambda表达式的时候，在内部会生成一个Observer实例。在Unity中Lambda和代理(delegate)貌似都可以用<code>Action&lt;T&gt;</code>的类型来代替(未验证)。</p>
<p> <img src="IObservable-Action.png" alt="IObservable-Action"></p>
<p> 使用方法就是经常见到的那样:</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subject = <span class="keyword">new</span> UniRx.Subject&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> disposable = subject.Subscribe(x =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(x);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">subject.OnNext(<span class="string">"Hello!"</span>);</span><br><span class="line">subject.OnNext(<span class="string">"World!"</span>):</span><br><span class="line"></span><br><span class="line">disposable.Dispose();</span><br><span class="line"></span><br><span class="line">subject.OnCompleted();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>图片一多起来感觉就正式起来了，但是由于画面太长，承载的信息量较少，直观是很直观但是不够集中流畅，感觉图片的方式还是要限制的好一些。</p>
<ul>
<li>关于UniRx接口的总结<ul>
<li>interface: <code>IObserver&lt;T&gt;</code> : <strong>接收消息</strong>定义的接口。</li>
<li>interface: <code>IObservable&lt;T&gt;</code> : <strong>消息订阅</strong>，<strong>消息处理</strong>定义的接口。<ul>
<li>这里的消息处理不是指收到消息进行处理，而是指对消息对象的本身进行处理，后面会有图更直观一些。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UniRx构成的三大要素"><a href="#UniRx构成的三大要素" class="headerlink" title="UniRx构成的三大要素"></a>UniRx构成的三大要素</h3><p>也还是根据这篇演讲的内容，与其说是整理，倒不如说是汉化。</p>
<ul>
<li><span style="color:orange">Observable</span></li>
<li><span style="color:orange">Operator</span></li>
<li><span style="color:orange">Scheduler</span></li>
</ul>
<h4 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h4><p>UniRx中有很多的操作符，关于操作符</p>
<ul>
<li><strong>操作符继承了IObserverT>和IObservable&lt;T>两个接口并实现功能</strong></li>
<li><strong>在Subject -&gt; Observer 之间进行消息的处理</strong></li>
<li>顺便一提这个叫做装饰模式(Decrator Pattern)</li>
</ul>
<p>…这个是突然说是装饰模式我也不是特别理解，我所知道的装饰模式是动态的为类添加功能的模式，听起来挺符合的。</p>
<p><img src="Unirx-Operator.png" alt="Operator"></p>
<h4 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h4><p>这个我也不知道该怎么翻译，调度器？</p>
<ul>
<li><strong>管理消息的执行时机，执行线程的</strong><ul>
<li>UniRx基本上使用的是Unity的WaitForSeconds来计量时间(MainThreadScheduler)</li>
<li>不想使用WaitForSeconds也可以指定其它的Scheduler来切换</li>
</ul>
</li>
</ul>
<p>使用的例子暂时还没有遇见，暂时先空着。</p>
<h4 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h4><p>这里是理解UniRx的关键，各种设计模式，操作符，Lambda，什么的</p>
<ul>
<li>发行的消息，经过Operator的处理，到达最后的Observer</li>
<li><strong>这个消息被运送的路径，构成，组织结构，被叫做Observable</strong><ul>
<li>也会被叫做流(Stream)</li>
</ul>
</li>
</ul>
<p><img src="Unirx-Observable.png" alt="Observable"></p>
<p>这张图片是我这篇文章里最想放的图片，非常直观的了解UniRx的动作方式。</p>
<h3 id="深入理解UniTask中的async-await"><a href="#深入理解UniTask中的async-await" class="headerlink" title="深入理解UniTask中的async/await"></a>深入理解UniTask中的async/await</h3><p>关于Unity中的UniTask，对我来说一直都是一个盲点，看到大佬的代码的时候会出现，关键是在C#中也是有这个关键字的，和UniRx使用的时候就开始乱套了，该怎么用。这里我可能会整理两篇文章，先理解，再入门。</p>
<ul>
<li><a href="https://learning.unity3d.jp/1493/" target="_blank" rel="noopener">Deep Dive async/await in Unity with UniTask(UniRx.Async)</a></li>
</ul>
<p>这篇是UniRx的制作人neueccさん在UnityBlog的稿子。除了UniRx之外还有他的<strong>MessagePack-CSharp</strong>的知识点啊文章啊值得我去理解和整理。别总是说什么自己不做web端的东西啊什么的，时代变了。</p>
<p>下面就开始对这个稿子的总结记录(汉化？)</p>
<h4 id="Rx-vs-async-await"><a href="#Rx-vs-async-await" class="headerlink" title="Rx vs async/await"></a>Rx vs async/await</h4><p>首先是Observable可以做什么？<br><img src="LINQtoAsynchronous.png" alt="Rx-Observable"></p>
<blockquote>
<p>注: コレクション操作</p>
<p>この操作は、指定した配列に対して、連結、相違、フラット、交差、結合、一意、順序、フィルタ、日付フィルタなどのコレクション操作を実行するときに使用します。</p>
</blockquote>
<p>图片中的内容我也不敢贸然翻译，反正就我个人的理解，UniRx中的Observable从LINQ到异步处理，都能胜任。能做到很多的事情是强项同时也是缺点。</p>
<p><strong>async/await</strong>的语法则是能让异步处理的写法跟同步处理的写法很相似。<br><img src="Async-Await.png" alt="Async-Await"></p>
<p><img src="Synchronous-Asynchronous.png" alt="Synchronous-Asynchronous"></p>
<p>正如上面也提到过的，<code>IObservable&lt;T&gt;</code>的功能很强大，从Event到异步处理都可以胜任，但是实现也只是一个操作符，让人无法准确的区分实现的功能，可读性变差也是非常不好的。按照作者的说法就是，对于<code>IObservable&lt;T&gt;</code>的实现来说，无论是Event(无限多个)还是异步处理(长度1)，使用相同的Operator来实现功能都是可能的，即实现的代码相同但是功能不同，功能非常强大。但是在应用层面上的使用就会出现问题。</p>
<p>比如说Event(的Observable流)使用Where等的关键字(这里只听懂了Where关键词)是可以的，但是异步处理使用Where等关键字就不可以。因为异步处理的返回结果是0，就会什么都不会返回（这里没能理解准确的意思）。异步处理的长度不能增加不能减少，这种情况下就希望能够区分处理。必要的时候可以互相转换就足够。</p>
<p>Rx可以用简单的写法实现复杂的功能，就使得源码的解读像是解密一样，stream的流向不是单方向，复杂度也会提升。这里我深有体会，操作符中用了<code>Repeat</code>，数据的流向就不知道跑去了哪里，简直就是灾难。所以如何写的简明易懂也是非常必要的。</p>
<p>总结起来就是：<strong>异步处理使用async/await，事件(Event)使用Rx。</strong><br><img src="Async-Await-Rx-Conclusion.png" alt="Conclusion"></p>
<h5 id="理解并正确使用async-await"><a href="#理解并正确使用async-await" class="headerlink" title="理解并正确使用async/await"></a>理解并正确使用async/await</h5><p>首先是<strong>async/await不是多线程！！</strong></p>
<p>原本一个我很早之前知道的但是忘记了的就是，游戏是没有多线程的使用的，但是我现在不是很确定这一个概念是否准确，只是隐隐约约这么感觉。</p>
<p><img src="Csharp-Task1.png" alt="Task"><br><img src="Csharp-Task2.png" alt="Task"><br><img src="Csharp-Task3.png" alt="Task"><br><img src="Csharp-Task4.png" alt="Task"></p>
<p>贴了好多图片，但是我感觉图片的内容总结的很好…所以就还是贴图片了。</p>
<p>最后引出了我们主角<strong>UniTask</strong>,这是为Unity量身打造的Task系统，结合async/await来使用，效率非常的高。</p>
<p>async/await是如何工作的<br><img src="UnderstandAsyncAwait.png" alt="理解Async/await"></p>
<p>按照作者所说，那个<strong>CPS</strong>的名字看起似乎很了不起，实际上也没什么，<strong>就是Callback的连锁</strong>。当await的内容执行完就执行回调。被作者叫做<em>自动回调制造机</em>。<br><img src="AsyncAwait-Callback.png" alt="自动回调制造机"></p>
<p>同时对于async/await的处理进行了优化，虽然是异步的写法但是在实际的运行中也有可能是同步执行。<br><img src="OptimizationForAsyncAwait.png" alt="对异步处理的优化"></p>
<p>具体的话Awaiter是怎么是实现的呢？我在别的文章看到过貌似，就是这个Awaiter实现异步处理的类是可以自己实现的，它提供了一些接口和类来实现。<code>IsCompleted</code>的标志位则是用来控制同步还是异步处理，避免了重复执行的时候产生的额外的Delegate调用。<br><img src="AwaiterClass.png" alt="Awaiter的实现"><br><img src="AwaiterClassUse.png" alt="Awaiter实现的伪代码"></p>
<p>除此之外，对于有复数的await调用的情况下也有一些优化:<br><img src="MultilpleAwaitOptimization1.png" alt="复数Await的优化1"></p>
<p>这里有复数个await，看起来会有三个Action continuation(Delegate)组成的，但实际上一个continuation都不会生成。根据作者的描述是说在async类型的方法中会有一个状态机(AsyncStateMachine)，所有的continuation都会由<code>this.MoveNext()</code>方法表示，通过推进状态机的状态，来完成所有的continuation。节省了为每一个continuation生成Delegate的开销。<br><img src="MultilpleAwaitOptimization2.png" alt="复数Await的优化2"></p>
<p>那么UniTask又是什么？UniTask是作者设计用来代替Task的，当然是为Unity而特化的类。C#原本的Task系统有许多Unity开发用不到或者很重的操作。<br><img src="UniTask.png" alt="UniTask"></p>
<p><strong>Unity是单线程运作的（基本上）。</strong>Unity是由C++的引擎层和C#的脚本层构成，C#的部分基本上都是使用的单线程处理。在使用C#的Task的时候很容易就使用了多线程的操作。所以出于各种Unity自身的特殊性，作者从特殊性和性能的方面强推使用UniTask的功能。<br><img src="UnityIsSingleThread.png" alt="Unity的特殊性"></p>
<p>async/await(Task)有能把多线程的功能统合到单线程的功能(SynchronizationContext),但是在Unity的情况下，多线程是基本上不会用到甚至是不推荐用的情况下，就会算是额外的开销。<br><img src="UnityWithSynchronizationContext.png" alt="Unity With SynchronizationContext"></p>
<p>关于Task中的一些调用知识，算是轻微的拓展。通过观察两者的调用情况可以发现，UniTask中舍弃了ExecutionContext和SynchronziationContext两种Capture。<br><img src="OverheadOfTask.png" alt="Overhead of Task"><br><img src="OverheadOfUniTask.png" alt="Overhead of UniTask"></p>
<p>async/await是基于Gameloop的。需要使用Unity中的Coroutine的时候，UniTask中也提供了一些替换Task中的操作的功能，由于没有多余的Allocation，效率会好一些。<br><img src="GameloopBasedAsyncAwait.png" alt="基于Gameloop"></p>
<p>对比使用Unity中的Coroutine，UniTask减少了很多Allocation。<br><img src="UniTaskVsCoroutine1.png" alt="Vs Coroutine"><br><img src="UniTaskVsCoroutine2.png" alt="Vs Coroutine"></p>
<p>UniTask Tracker可以用来观察UniTask的状态。使用不当会发生Leak（类似于内存泄漏？），根据情况多多使用是好的。<br><img src="UniTaskTracker.png" alt="UniTask Tracker"></p>
<p>最后是作者的总结：</p>
<ul>
<li><strong>出于性能的选择 UniTask + async/await</strong><ul>
<li>UniTask是为了Unity而特化的工具，相比于Task性能好好很多是肯定的</li>
<li>No ExecutionContext, No SynchronizationContext</li>
<li>UniTask相比于Coroutne有更少的Allocation</li>
<li>在异步处理的方面的性能要强于UniRx(Observable)</li>
</ul>
</li>
<li><strong>出于自由的选择 UniTask + async/await</strong><ul>
<li>单线程是使用的前提，不用担心掉进多线程的坑</li>
<li>提供丰富的功能，在绝大多数情况下可以替换Coroutine</li>
<li>有UniTask Tracker可以简单回避Leak(泄漏)</li>
<li>和Task,Rx混合使用没有问题</li>
</ul>
</li>
</ul>
<p><img src="UniTaskConclusion.png" alt="UniTask-Conclusion"><br><img src="UniTaskConclusion1.png" alt="UniTask-Conclusion"></p>
<p><strong>State of UniTask</strong>。UniTask内部有四个状态。由UniTaskCompletionSource生成的情况下，可以使用TrySetResult/TrySetException/TrySetCancled来切换状态。<br><img src="AwaiterStatus.png" alt="AwaiterStatus"></p>
<p>各个状态的时间段：<br><img src="AwaiterStatus-Pending.png" alt="Pending"><br><img src="AwaiterStatus-Succeeded.png" alt="Succeeded"><br><img src="AwaiterStatus-Faulted.png" alt="Faulted"><br><img src="AwaiterStatus-Cancled.png" alt="Cancled"></p>
<p>异常处理,当捕获到异常之后都会一层一层的向调用的上级上抛，在哪里停止呢？作者提供了<code>Forget()</code>的方法用来终结UniTask的异常处理。<br><img src="UniTaskException1.png" alt="UniTask的异常处理"><br><img src="UniTaskException2.png" alt="UniTask的异常处理"><br><img src="UniTaskException3.png" alt="UniTask的异常处理"><br><img src="UniTaskException4.png" alt="UniTask的异常处理"></p>
<p>这里有一个问题就是<code>Observable.Empty/Never</code>可以用来做什么？</p>
<p><strong>async中的Cancellation</strong>，async/await的痛点，就作者的话来说就是麻烦。取消很麻烦。</p>
<ul>
<li>相比于Rx的IDisposable返回值，async/awai没有了IDisposable的Allocation，但是有了CancellationToken这个参数</li>
</ul>
<p>具体的说来(参照下面的图片)，就是需要在异步函数的最后一个参数那里添加<code>CancellationToken cancellationToken = default</code>这个参数，按照作者所说，算是一个半强制的操作，如果说取消的这个操作保证绝对没有的话，不写这个参数也是可以的，但是基本上是推荐带上这个参数的。<br><img src="PainpointOfAsyncAwait.png" alt="async/await的痛点"></p>
<p>那么由谁来发送这个OperationCanceledExcrption呢？取消就代表着<code>OperationCanceledException</code>，可以通过<code>cancellationToken.IsCancelationRequested</code>来检查是否被取消，但是，<strong>在在代码中去使用这个东西来检查是不需要的</strong>。因为在(Unity)用户代码中都是一些同步处理，而实际上抛出这个<code>OperationCanceledException</code>异常的是异步处理，也就是说来源都是<code>= asyncOperation.ConfigureAwait(token), UniTask.Delay(token), etc...</code>，而我们所要做的就是把这个Token传递给这些异步处理的当中就OK了。<br><img src="OperationCanceledException.png" alt="取消 = OperationCanceledException"></p>
<p>在Unity中的MonoBehaviour/OnDestory便利的使用：<br><img src="CanceledTokenSource.png" alt="CanceledTokenSource in MonoBehaviour"></p>
<p>异常处理是会拖累性能的，针对特殊情况，比如说同时大量的Cancle异常发生，针对同一个事件大量的对象对此发出异常事件的情况，我们可以使用提供的<code>UniTask.SuppressCancellationThrow</code>来抑制这一层例外的大量发射的情况，但是这个方法只能抑制这一层的情况。只会在特殊情况下使用这个，记着吧。<br><img src="SuppressCancellationThrow.png" alt="异常的高代价"></p>
<p><strong>Async Eventhandling</strong>。而实际上async/await不单单可以实现异步处理，也是可以用来做Event(事件)的实现的。但是原则上还是推荐EventHandling由Rx为主实现。async/await的EventHandling实现还是作为一个可以实现的一个方式，但是不做推荐。<br><img src="AsyncEventHandling1.png" alt="AsyncTrigger/AsyncUGUI"><br><img src="AsyncEventHandling2.png" alt="AsyncTrigger/AsyncUGUI"><br><img src="AsyncEventHandling3.png" alt="什么时候使用"></p>
<p>作者出于性能的考虑，一些本地的变量可以被重复使用。如下面的代码，我没有实际上试过，但是那个变量<code>i</code>貌似应该有些问题。<br><img src="ReusablePromise.png" alt="UniTask的一部分再利用"></p>
<p>还有一些别的使用可以参考UniTask(async/await?)的ReadMe文档。(当然我是还没找啦)</p>
<p>最后总结一下，用作者的意思就是恐れず、どんどん使いましょう、と。</p>
<hr>
<p>大体上的印象我是从这篇文章终于算是稍微理解了一些：</p>
<ul>
<li><a href="https://qiita.com/toRisouP/items/2f1643e344c741dd94f8" target="_blank" rel="noopener">UniRx入門 その1</a></li>
</ul>
<p>这个作者还有一些其他的入门文章有时间也可以观摩一下:<a href="https://qiita.com/toRisouP/items/00b8a5bb8e7b68e0686c" target="_blank" rel="noopener">UniRx入門シリーズ 目次はこちら</a></p>
<ul>
<li><a href="https://qiita.com/Marimoiro/items/2ad8a1b422a3fe98f938" target="_blank" rel="noopener">UniRxを導入するメリット ～こういう時にUniRxは使えるよ～</a></li>
</ul>
<p>超级有用的一篇知乎文章：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/35189325" target="_blank" rel="noopener">又见Rx——Rx via UniRx</a></li>
</ul>
<p>里面的那个讲Rx的视频真的很厉害。</p>
<h2 id="UniRx中遇见的"><a href="#UniRx中遇见的" class="headerlink" title="UniRx中遇见的"></a>UniRx中遇见的</h2><h3 id="PlayerLoop"><a href="#PlayerLoop" class="headerlink" title="PlayerLoop"></a>PlayerLoop</h3><p>所以说<strong>PlayerLoop</strong>是个什么东西我还没搞懂，只不过在读源码的时候发现了这么几行：<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UniRx用</span></span><br><span class="line"><span class="keyword">var</span> playerLoop = ScriptBehaviourUpdateOrder.CurrentPlayerLoop;</span><br><span class="line">PlayerLoopHelper.Initialize(<span class="keyword">ref</span> playerLoop);</span><br></pre></td></tr></table></figure></p>
<p>有时候大佬的两行代码我的用一天来理解。首先我不知道UniRx怎么用，其次为什么要在这里这么用。几番调查锁定了这两行代码的用意。</p>
<ul>
<li><a href="https://notargs.hateblo.jp/entry/ecs_unirx" target="_blank" rel="noopener">【Unity2018】Entity Component System(ECS)とUniRx.Asyncを和解させる</a></li>
</ul>
<p>在使用Unity的ECS和UniRx的时候，两者的<code>PlayerLoop</code>会冲突，读源码就会大概理解(接受？)这个情况。</p>
<blockquote>
<p>ECSを使っているプロジェクトにUniRxをぶちこむと、ECSとUniRxのPlayerLoopが喧嘩してUniRxが勝ちます（ECSが動かなくなります）</p>
</blockquote>
<p><strong>ECS:</strong><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GameBootstrap.cs</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Unity.Entities</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !UNITY_DISABLE_AUTOMATIC_SYSTEM_BOOTSTRAP</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">AutomaticWorldBootstrap</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            DefaultWorldInitialization.Initialize(<span class="string">"Default World"</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ScriptBehaviourUpdateOrder.cs</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SetPlayerLoop</span>(<span class="params">PlayerLoopSystem playerLoop</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlayerLoop.SetPlayerLoop(playerLoop);</span><br><span class="line">    currentPlayerLoop = playerLoop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UpdatePlayerLoop</span>(<span class="params"><span class="keyword">params</span> World[] worlds</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> defaultLoop = PlayerLoop.GetDefaultPlayerLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (worlds?.Length &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> ecsLoop = InsertWorldManagersInPlayerLoop(defaultLoop, worlds.Where(x =&gt; x != <span class="literal">null</span>).ToArray());</span><br><span class="line">        SetPlayerLoop(ecsLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetPlayerLoop(defaultLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>UniRx:</strong><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlayerLoopHelper.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params"><span class="keyword">ref</span> PlayerLoopSystem playerLoop</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    yielders = <span class="keyword">new</span> ContinuationQueue[<span class="number">7</span>];</span><br><span class="line">    runners = <span class="keyword">new</span> PlayerLoopRunner[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> copyList = playerLoop.subSystemList.ToArray();</span><br><span class="line"></span><br><span class="line">    copyList[<span class="number">0</span>].subSystemList = InsertRunner(copyList[<span class="number">0</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldInitialization), yielders[<span class="number">0</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerInitialization), runners[<span class="number">0</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">1</span>].subSystemList = InsertRunner(copyList[<span class="number">1</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldEarlyUpdate), yielders[<span class="number">1</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerEarlyUpdate), runners[<span class="number">1</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">2</span>].subSystemList = InsertRunner(copyList[<span class="number">2</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldFixedUpdate), yielders[<span class="number">2</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerFixedUpdate), runners[<span class="number">2</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">3</span>].subSystemList = InsertRunner(copyList[<span class="number">3</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldPreUpdate), yielders[<span class="number">3</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerPreUpdate), runners[<span class="number">3</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">4</span>].subSystemList = InsertRunner(copyList[<span class="number">4</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldUpdate), yielders[<span class="number">4</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerUpdate), runners[<span class="number">4</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">5</span>].subSystemList = InsertRunner(copyList[<span class="number">5</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldPreLateUpdate), yielders[<span class="number">5</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerPreLateUpdate), runners[<span class="number">5</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line">    copyList[<span class="number">6</span>].subSystemList = InsertRunner(copyList[<span class="number">6</span>], <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerYieldPostLateUpdate), yielders[<span class="number">6</span>] = <span class="keyword">new</span> ContinuationQueue(), <span class="keyword">typeof</span>(UniTaskLoopRunners.UniTaskLoopRunnerPostLateUpdate), runners[<span class="number">6</span>] = <span class="keyword">new</span> PlayerLoopRunner());</span><br><span class="line"></span><br><span class="line">    playerLoop.subSystemList = copyList;</span><br><span class="line">    PlayerLoop.SetPlayerLoop(playerLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// capture default(unity) sync-context.</span></span><br><span class="line">    unitySynchronizationContetext = SynchronizationContext.Current;</span><br><span class="line">    mainThreadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runners != <span class="literal">null</span>) <span class="keyword">return</span>; <span class="comment">// already initialized</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> playerLoop = PlayerLoop.GetDefaultPlayerLoop();</span><br><span class="line">    Initialize(<span class="keyword">ref</span> playerLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我把代码一起粘贴出来是因为这里面有好多我知识点的盲区，有代码能加快一些理解。</p>
<p>最终结论就是加上最上面的两行使得ECS和UniRx的PlayerLoop不冲突，不会造成一方失效的问题。<br>也就是这一步并不是UniRx要做的设定而是为了让两者共存而做的设定。</p>
<p>那么通过这个问题我发现的一些知识盲区：</p>
<ul>
<li>ECS是什么？</li>
<li>PlayerLoop是什么，为什么游戏开始之前要指定PlayerLoop的设定？</li>
</ul>
<p>调查了一下发现这个问题是真的很复杂，需要展开另一篇关于Unity的ECS的内容来加深理解了。</p>
<h2 id="UniRx-各种用法"><a href="#UniRx-各种用法" class="headerlink" title="UniRx-各种用法"></a>UniRx-各种用法</h2><h3 id="SubscribeOnMainThread-amp-ObserveOnMainThread"><a href="#SubscribeOnMainThread-amp-ObserveOnMainThread" class="headerlink" title="SubscribeOnMainThread &amp; ObserveOnMainThread"></a>SubscribeOnMainThread &amp; ObserveOnMainThread</h3><p>这个是做什么的</p>
<ul>
<li><a href="https://github.com/neuecc/UniRx/issues/282" target="_blank" rel="noopener">How to use SubscribeOnMainThread? It seems never working #282</a></li>
</ul>
<blockquote>
<p>SubscribeOnMainThread means that you are subscribing (therefore starting the task [for cold observables]) in main thread whereas ObserveOnMainThread means that you are observing (listening) onNext messages in main thread.</p>
</blockquote>
<blockquote>
<p>When you are using Observable.Start method, the task will be run on the ThreadPool by default. So use it with the ObserveOnMainThread to access Unity API in the Subscribe method.</p>
</blockquote>
<p>从名字上也能大致了解，就是为了让Subscribe中的内容在MainThread中执行。因为涉及到Unity的GameObject的操作都要在主线程中进行。</p>
<p>按理说我应该试着使用这两个方法，再去了解这个方法应不应该这样用，也就是试错。</p>
<p>但是我听前辈说这两个方法不太靠得住（意思应该就是使用的时候可能会报错，因为在子线程中动Unity的GameObject，或者Unity的一些东西，编译就会报错，会好好的报出错误信息的），最靠谱的方式是用<code>await UniTask.Yield()</code>。至于具体怎么用，在后面的地方专门展开。</p>
<h3 id="ObserveEveryValueChanged"><a href="#ObserveEveryValueChanged" class="headerlink" title="ObserveEveryValueChanged"></a>ObserveEveryValueChanged</h3><h3 id="Observable-1"><a href="#Observable-1" class="headerlink" title="Observable"></a>Observable</h3><ul>
<li><a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">Observable</a></li>
</ul>
<h3 id="Disposables"><a href="#Disposables" class="headerlink" title="Disposables"></a>Disposables</h3><p>这个也是一个很重要的概念。</p>
<ul>
<li><a href="http://rxwiki.wikidot.com/disposables" target="_blank" rel="noopener">Disposables</a></li>
</ul>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><ul>
<li><a href="https://qiita.com/toRisouP/items/3cf1c9be3c37e7609a2f" target="_blank" rel="noopener">UniRx オペレータ逆引き</a></li>
</ul>
<h4 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h4><ul>
<li><a href="http://neue.cc/2011/09/17_343.html" target="_blank" rel="noopener">Rxにおける並行非同期実行とリソース処理の問題</a></li>
</ul>
<h4 id="Do"><a href="#Do" class="headerlink" title="Do"></a>Do</h4><ul>
<li><a href="http://light11.hatenadiary.com/entry/2018/11/03/195828" target="_blank" rel="noopener">【Unity】【UniRx】Observable.DoXxx()系のメソッドの挙動まとめ</a></li>
</ul>
<h1 id="Reactive-Programming-重要"><a href="#Reactive-Programming-重要" class="headerlink" title="Reactive Programming(重要)"></a>Reactive Programming(重要)</h1><ul>
<li><a href="https://egghead.io/courses/introduction-to-reactive-programming" target="_blank" rel="noopener">Introduction to Reactive Programming</a></li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>UniRx</tag>
      </tags>
  </entry>
  <entry>
    <title>我所理解的Lambda表达式</title>
    <url>/the-lambda-what-i-understand/</url>
    <content><![CDATA[<p>纠结了好久，最终决定把lambda这个部分从Unity中分离出来单独总结。理解并能够使用Lambda表达式是这篇文章的目的。除此之外如果有关于lambda的拓展用法亦或者好的使用案例一并在这里记录。</p>
<a id="more"></a>
<p>首先是Lambda的基础概念</p>
<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><h2 id="lambda-expressions是什么"><a href="#lambda-expressions是什么" class="headerlink" title="lambda expressions是什么"></a>lambda expressions是什么</h2><blockquote>
<p>A lambda expression is a block of code (an expression or a statement block) that is treated as an object. It can be passed as an argument to methods, and it can also be returned by method calls.</p>
</blockquote>
<p>来自 <a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions" target="_blank" rel="noopener">Lambda expressions (C# Programming Guide)</a></p>
<p>匿名函数，也可以这样叫，将函数作为对象处理，用<code>{}</code>包含。因为最近一年之和C++打交道，C#的语言机制究竟是什么样子的完全不记得了，关于C#的编译执行过程应该与C++区别并整理到别的文章去。</p>
<p>但是就C++的感觉来说，lambda给我的印象就是函数指针。但是内部的处理我还是不清楚(无论是C#还是C++)，比如说函数指针(lambda)的调用代价是什么样子的，跟普通的函数调用有什么区别等等。</p>
<p>但是这些先放一边，将lambda视为一个对象，可以作为<strong>参数①</strong>，可以作为<strong>返回函数调用②</strong>。</p>
<h2 id="lambda怎么用"><a href="#lambda怎么用" class="headerlink" title="lambda怎么用"></a>lambda怎么用</h2><p>既然要使用lambda就要知道它的使用方式是什么样子的。</p>
<ul>
<li><a href="https://qiita.com/Aki_mintproject/items/a70c33911ad96e5d8188" target="_blank" rel="noopener">私はこうしてLINQ・ラムダ式を理解できた（入門）</a></li>
</ul>
<p>这篇涉及了一些Linq的东西，讲的会比较多一些，但是很好的涵盖的lambda的继承用法。</p>
<ul>
<li><a href="https://qiita.com/rawr/items/11790e9ea08a29d028a4" target="_blank" rel="noopener">C# 今更ですが、ラムダ式</a></li>
</ul>
<p>这篇讲的内容比较少但是对于基础讲的很具体。</p>
<h3 id="lambda文法"><a href="#lambda文法" class="headerlink" title="lambda文法"></a>lambda文法</h3><h3 id="什么时候用lambda"><a href="#什么时候用lambda" class="headerlink" title="什么时候用lambda"></a>什么时候用lambda</h3>]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用VisualStudio</title>
    <url>/how-to-visual-studio/</url>
    <content><![CDATA[<p>我觉得我应该好好钻研一下这个“宇宙第一”的各种用法了，好多意想不到的插件甚至是快捷键我都不知道。<br><a id="more"></a></p>
<h1 id="VS中的DEBUG"><a href="#VS中的DEBUG" class="headerlink" title="VS中的DEBUG"></a>VS中的DEBUG</h1><p>如何使用VS进行Debug是非常重要的，致命的是我至今未能完全掌握，不要总是依靠Log的输出自己猜了。</p>
<h2 id="在UE4中使用VS进行调试"><a href="#在UE4中使用VS进行调试" class="headerlink" title="在UE4中使用VS进行调试"></a>在UE4中使用VS进行调试</h2><p>首先要把UE4的源码下载，然后按照官方的指示操作生成VS的工程文件。</p>
<p>~打开文件之后开始build，这里我遇见的一个问题是当我编译成功之后，不知道该怎么运行了。~</p>
<h3 id="UnrealVS-UBT编译-amp-UE4热更新"><a href="#UnrealVS-UBT编译-amp-UE4热更新" class="headerlink" title="UnrealVS - UBT编译&amp;UE4热更新"></a>UnrealVS - UBT编译&amp;UE4热更新</h3><ul>
<li>2021/06/07 前来更新</li>
</ul>
<p>看到上面自己写的，跟放屁没什么区别。UE4的源码编译参照官方提供的手顺一步一步来就行了。</p>
<p>这里介绍一下一个UE4的插件</p>
<ul>
<li><a href="https://docs.unrealengine.com/4.26/en-US/ProductionPipelines/DevelopmentSetup/VisualStudioSetup/UnrealVS/" target="_blank" rel="noopener">UnrealVS Extension</a></li>
</ul>
<p>对应的版本是4.26</p>
<p>严格来说这一部分应该是放在其它UE4相关的文章中再介绍的，但是使用的话主要还是为VS服务的，想了想还是放到VS的部分了。</p>
<p>使用场景主要是针对每次编译好源码想要反映到项目中的时候就得重启UE4的编辑器，实在太费时间，使用这个UnrealVS的插件，可以提供UBT的编译和UE4的热更新(hot reload),这样就<strong>不用一次次的重启UE4的Editor就能看到C++代码的更新内容了</strong>。</p>
<p>下面介绍如何开启和使用这个插件。</p>
<h4 id="UE4这边"><a href="#UE4这边" class="headerlink" title="UE4这边"></a>UE4这边</h4><p>首先需要先安装这个插件，去引擎的源文件这个路径下找到<code>Engine\Extras\UnrealVS\VS2019\UnrealVS.vsix</code>这个文件，点击安装，类似于给VS安装插件。</p>
<p>安装完毕，UE4这边就OK了。</p>
<p>版本根据自己的VS版本选择，我用的是2019专业版，就选择2019文件夹下的。</p>
<h4 id="VS这边"><a href="#VS这边" class="headerlink" title="VS这边"></a>VS这边</h4><p>成功安装好了之后打开VS，去<strong>Extension-&gt;Manage Extension-&gt;Installed</strong>下就可以看到我们安装好的VS插件：<strong>UnrealVS</strong>。</p>
<p>然后去<strong>View-&gt;ToolBars-&gt;UnrealVS</strong>将菜单栏显示，然后在<strong>UnrealVS</strong>菜单栏的最右边点击<strong>UnrealVS ToolBar Options</strong>，点开应该只有一个选项：<strong>Add or Remove Buttons</strong>，找到<strong>Customize</strong>。</p>
<p>这个时候我们就打开了<strong>UnrealVS</strong>的工具栏自定义界面，在<strong>Commands</strong>页面为UnrealVS的Toolbar添加新的Command。点击<strong>Add Command-&gt;Extensions-&gt;Build Startup Project</strong>。点击OK完成设置。</p>
<p>就这样在我们对源码进行编辑的时候想要查看工程的修改就直接点击上面的<strong>Build Startup Project</strong>等编译和HotReload完成就会反应到UE4的Editor中。</p>
<p>坏消息就是这个插件也不是什么万能的，函数内的修改倒是没什么，要是有序列化的属性(一般是指需要被显示到蓝图)被修改添加删除之类的操作，一般就算用它编译了，也不会反映到UE4Editor上，只有重启才会反映。轻则不反映，重则直接崩溃。</p>
<p>据我自己的体感就是<strong>安全的范围是在.cpp文件中对函数内的内容修改</strong>。</p>
<p><strong>一些小Tips</strong></p>
<ol>
<li><p>平常在SolutionExplorer右键工程可以找到<strong>Set as Startup Project</strong>，一般情况下第一次打开项目的时候就应该设置。去<strong>Tools-&gt;Options-&gt;UnrealVS-&gt;General-&gt;Hide Non-Game Startup Projects</strong>设置为True的话，那么菜单栏里只会显示<strong>Startup Projects</strong>。</p>
</li>
<li><p>为上面我们添加的<strong>Build Startup Project</strong>添加快捷键：<strong>Tools-&gt;Options-&gt;Environment-&gt;Keyboard</strong>,<strong>Keyboard Mapping Scheme</strong>就随自己喜欢了，搜索“UnrealVS”就会找到<code>UnrealVS.BuildStartupProject</code>这个点击选择添加新的快捷键。在<code>Global</code>一行添加<strong>Ctrl + Shift + Alt + B</strong>，然后<code>Assign</code>，这样添加就完成了。</p>
</li>
</ol>
<p>再就是UnrealVS提供的其他命令的使用方式我不是太明白，就是上面那个链接的其他内容。</p>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><h3 id="VsVim"><a href="#VsVim" class="headerlink" title="VsVim"></a>VsVim</h3><h3 id="Productivity-Power-Tools"><a href="#Productivity-Power-Tools" class="headerlink" title="Productivity Power Tools"></a>Productivity Power Tools</h3><ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=VisualStudioPlatformTeam.ProductivityPowerPack2017" target="_blank" rel="noopener">Productivity Power Tools 2017/2019</a></li>
</ul>
<p>具体的功能之后有时间整理一下。</p>
<h2 id="关于注释"><a href="#关于注释" class="headerlink" title="关于注释"></a>关于注释</h2><ul>
<li><a href="https://docs.microsoft.com/ja-jp/visualstudio/ide/reference/generate-xml-documentation-comments?view=vs-2019" target="_blank" rel="noopener">How to: Insert XML comments for documentation generation</a></li>
</ul>
<p>主要是我想知道使用<code>///</code>来插入一段完整的段落注释的方法。</p>
<h1 id="简单的设置VS"><a href="#简单的设置VS" class="headerlink" title="简单的设置VS"></a>简单的设置VS</h1><h2 id="Solution-Configurations"><a href="#Solution-Configurations" class="headerlink" title="Solution Configurations"></a>Solution Configurations</h2><p>使用VS的时候，尤其是我在使用UE4的时候可能会切换编译的模式，什么<strong>Development Editor</strong>, <strong>Debug Editor</strong>等等，又长又短，长了就看不清自己设置的什么模式。</p>
<p>就想让他变长，我说那个drop-down list。</p>
<ul>
<li><a href="https://visualstudioextensions.vlasovstudio.com/2014/08/14/adjusting-the-width-of-solution-configurations-drop-down-list-in-the-visual-studio-toolbar/" target="_blank" rel="noopener">Adjusting the width of “Solution Configurations” drop-down list in the Visual Studio toolbar</a></li>
</ul>
<p>Tools -&gt; Customize -&gt; Commands -&gt; Toobar -&gt; 下拉找到Standard -&gt; 找到Solution Configuration -&gt; 右边的Modify Selection -&gt; 把Width改成165</p>
<p>就OK了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity知识点记录</title>
    <url>/unity-learning-note/</url>
    <content><![CDATA[<h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><ul>
<li>(2019/05/29) 更新MenuItem的详细使用</li>
<li>(2020/03/21) 更新CustomEditor的内容<h1 id="Unity的使用"><a href="#Unity的使用" class="headerlink" title="Unity的使用"></a>Unity的使用</h1>这次终于不是自己单枪匹马的干，而是真的项目中使用Unity引擎来做开发了。</li>
</ul>
<p>先附上官方文档：</p>
<ul>
<li><a href="https://docs.unity3d.com/Manual/index.html" target="_blank" rel="noopener">Unity User Manual (2019.1)</a></li>
</ul>
<h2 id="1-Unity-C-中的一些比较重要的使用"><a href="#1-Unity-C-中的一些比较重要的使用" class="headerlink" title="1.Unity C# 中的一些比较重要的使用"></a>1.Unity C# 中的一些比较重要的使用</h2><h3 id="1-MenuItem"><a href="#1-MenuItem" class="headerlink" title="1.MenuItem"></a>1.MenuItem</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if UNITY_EDITOR</span><br><span class="line">        [UnityEditor.MenuItem(&quot;Project/Operation&quot;)</span><br><span class="line">        public static void OperationRun()&#123;&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">    [MenuItem(&quot;Project/Operation&quot;)]</span><br><span class="line">    public static void OperationRun()&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的用法，貌似也可以被叫做<strong>Debug Menu</strong> ,感觉用处相当大。</p>
<p>便利的调用一些比较麻烦的函数，触发条件和时机需要自己掌控等等，总而言之，这个很重要。</p>
<ul>
<li><a href="https://anchan828.github.io/editor-manual/web/part1-menuitem.html" target="_blank" rel="noopener">第8章　MenuItem</a></li>
</ul>
<p>但是要注意添加的方法都是static的方法，调用非静态函数的方法，我知道的有两个:</p>
<ul>
<li>1.向静态函数中传递对象引用。</li>
<li>2.在静态函数遍历所有对象找到那个想要的对象并调用对象函数，这限于Unity中debug场景，毕竟可以遍历场景中的所有对象。使用<code>FindObjectofType</code>之类的函数。</li>
</ul>
<p>其他要注意的是，这个功能算是对UnityEditor的扩展功能，使用的时候不要忘记：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#if UNITY_EDITOR</span><br><span class="line">using UnityEditor</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">加上编译选项才安全。</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Unity-C-中的序列化-Serialization"><a href="#2-Unity-C-中的序列化-Serialization" class="headerlink" title="2.Unity C# 中的序列化(Serialization)"></a>2.Unity C# 中的序列化(Serialization)</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/27990334" target="_blank" rel="noopener">Unity与C#的序列化与反序列化</a></li>
<li><a href="https://dev.twsiyuan.com/2018/06/how-to-save-and-load-gamesaves-in-unity.html" target="_blank" rel="noopener">Unity 遊戲存檔機制淺談，從序列化 (Serialization) 到儲存裝置 (Storage)</a></li>
</ul>
<h4 id="SerializeField"><a href="#SerializeField" class="headerlink" title="SerializeField"></a>SerializeField</h4><ul>
<li><a href="https://qiita.com/makopo/items/8ef280b00f1cc18aec91" target="_blank" rel="noopener">Unityの[SerializeField]について色々な疑問に答えてみる</a></li>
</ul>
<h4 id="HideInInspector"><a href="#HideInInspector" class="headerlink" title="HideInInspector"></a>HideInInspector</h4><p><a href="https://ekulabo.com/hide-in-inspector" target="_blank" rel="noopener">【Unity】HideInInspectorとSerializeFieldの興味深い関係</a></p>
<h4 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h4><ul>
<li><a href="http://ftvoid.com/blog/post/732" target="_blank" rel="noopener">[Unity] 自前のクラスをインスペクタから編集できるようにする</a></li>
</ul>
<h3 id="3-MessagePack"><a href="#3-MessagePack" class="headerlink" title="3.MessagePack"></a>3.MessagePack</h3><ul>
<li><a href="http://engineering.grani.jp/entry/2017/05/24/160006" target="_blank" rel="noopener">黒騎士と白の魔王におけるMessagePack-CSharpのUnionの活用事例</a></li>
</ul>
<h3 id="4-FindObjectOfType"><a href="#4-FindObjectOfType" class="headerlink" title="4.FindObjectOfType"></a>4.FindObjectOfType</h3><blockquote>
<p>（シーン上にある該当する物の中からUnityが適当に選んだ１つが返ります。１つも存在していなかったらnullが返ります）</p>
</blockquote>
<blockquote>
<p>ゲームオブジェクトを参照して、スクリプトにアクセスするのがGetCompornetで、</p>
<p>スクリプトを参照して、スクリプトにアクセスするのがFindObjectOfTypeです。</p>
</blockquote>
<p>就像上面说的那样，下面附上使用：</p>
<ul>
<li><a href="https://docs.unity3d.com/ja/current/ScriptReference/Object.FindObjectOfType.html" target="_blank" rel="noopener">Object.FindObjectOfType</a></li>
<li><a href="https://docs.unity3d.com/ja/current/ScriptReference/Object.FindObjectsOfType.html" target="_blank" rel="noopener">Object.FindObjectsOfType</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Object FindObjectOfType (Type type);</span><br><span class="line"></span><br><span class="line">public static Object[] FindObjectsOfType (Type type);</span><br></pre></td></tr></table></figure>
<p>这个方法非常低效，不适合在每一帧都调用，可以利用SingletonPattern。</p>
<p><a href="http://baba-s.hatenablog.com/entry/2014/07/09/093240" target="_blank" rel="noopener">【Unity】GameObject.Find 系関数の処理速度の検証結果</a></p>
<h3 id="5-Attribute"><a href="#5-Attribute" class="headerlink" title="5. Attribute"></a>5. Attribute</h3><h4 id="1-AddComponentMenu"><a href="#1-AddComponentMenu" class="headerlink" title="1. AddComponentMenu"></a>1. AddComponentMenu</h4><h4 id="2-RequireComponent"><a href="#2-RequireComponent" class="headerlink" title="2. RequireComponent"></a>2. RequireComponent</h4><h3 id="6-CustomEditor"><a href="#6-CustomEditor" class="headerlink" title="6. CustomEditor"></a>6. CustomEditor</h3><blockquote>
<p>Defines which object type the custom editor class can edit.</p>
</blockquote>
<p>个人理解就是为自定义的类进行编辑器扩展。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参数</span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(CustomClass))</span>]</span><br><span class="line"><span class="comment">// 有参数</span></span><br><span class="line">[<span class="meta">CustomEditor(typeof(CustomeClass), true)</span>]</span><br></pre></td></tr></table></figure></p>
<p>关于参数的解释，我贴一下源码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UnityEditor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Summary:</span></span><br><span class="line">    <span class="comment">//     Tells an Editor class which run-time type it's an editor for.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomEditor</span> : <span class="title">Attribute</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     Defines which object type the custom editor class can edit.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Parameters:</span></span><br><span class="line">        <span class="comment">//   inspectedType:</span></span><br><span class="line">        <span class="comment">//     Type that this editor can edit.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   editorForChildClasses:</span></span><br><span class="line">        <span class="comment">//     If true, child classes of inspectedType will also show this editor. Defaults</span></span><br><span class="line">        <span class="comment">//     to false.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomEditor</span>(<span class="params">Type inspectedType</span>)</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     Defines which object type the custom editor class can edit.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Parameters:</span></span><br><span class="line">        <span class="comment">//   inspectedType:</span></span><br><span class="line">        <span class="comment">//     Type that this editor can edit.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//   editorForChildClasses:</span></span><br><span class="line">        <span class="comment">//     If true, child classes of inspectedType will also show this editor. Defaults</span></span><br><span class="line">        <span class="comment">//     to false.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CustomEditor</span>(<span class="params">Type inspectedType, <span class="keyword">bool</span> editorForChildClasses</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Summary:</span></span><br><span class="line">        <span class="comment">//     If true, match this editor only if all non-fallback editors do not match. Defaults</span></span><br><span class="line">        <span class="comment">//     to false.</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">bool</span> isFallback &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有参数版本的，设置为true的理由就是，inspedtedType子类也会显示这个部分的Editor内容。（说实话不太理解）</p>
<p>除此之外，<code>isFallback</code>变量的作用我也不是很理解。</p>
<h3 id="7-ContextMenu"><a href="#7-ContextMenu" class="headerlink" title="7. ContextMenu"></a>7. ContextMenu</h3><p>可以在Inspector视图里直接调用函数？</p>
<h2 id="2-C-语法"><a href="#2-C-语法" class="headerlink" title="2.C# 语法"></a>2.C# 语法</h2><h3 id="？类型声明"><a href="#？类型声明" class="headerlink" title="？类型声明"></a>？类型声明</h3><ul>
<li><a href="https://stackoverflow.com/questions/2326158/why-is-there-a-questionmark-on-the-private-variable-definition" target="_blank" rel="noopener">Why is there a questionmark on the private variable definition?</a></li>
</ul>
<h3 id="operator"><a href="#operator" class="headerlink" title="?? operator"></a>?? operator</h3><ul>
<li><a href="https://stackoverflow.com/questions/446835/what-do-two-question-marks-together-mean-in-c" target="_blank" rel="noopener">What do two question marks together mean in C#?</a></li>
</ul>
<h3 id="operator-1"><a href="#operator-1" class="headerlink" title="$ operator"></a>$ operator</h3><ul>
<li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/tokens/interpolated" target="_blank" rel="noopener">$ - 字符串内插（C# 参照）</a></li>
</ul>
<h3 id="gt-operator"><a href="#gt-operator" class="headerlink" title="=&gt; operator"></a>=&gt; operator</h3><p>看见的第一眼以为是lambda表达式，但是后面接着出现的是是变量而不是表达式。</p>
<ul>
<li><a href="http://var.blog.jp/archives/67192510.html" target="_blank" rel="noopener">C# の =&gt; プロパティ</a></li>
</ul>
<p>相当于<code>{get;}</code>但是又不是简单的get。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">◆ private A a =&gt; new A();</span><br><span class="line">◆ ＝ private A a &#123; get &#123; return new A(); &#125; &#125; </span><br><span class="line">◆ ≠ private A a &#123; get; &#125; = new A();</span><br></pre></td></tr></table></figure>
<h3 id="where关键字"><a href="#where关键字" class="headerlink" title="where关键字"></a>where关键字</h3><ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/where-generic-type-constraint" target="_blank" rel="noopener">where (generic type constraint) (C# Reference)</a></li>
</ul>
<p>一般类型约束？</p>
<blockquote>
<p>For example, you can declare a generic class, <code>MyGenericClass</code>, such that the type parameter T implements the <code>IComparable&lt;T&gt;</code> interface:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AGenericClass&lt;T&gt; where T : IComparable&lt;T&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用了模板但是约束了类型，是这样的么。</p>
<p>我发誓这个关键字在我以前用C#的时候肯定知道，但是我忘了。。</p>
<h3 id><a href="#" class="headerlink" title="@"></a>@</h3><ul>
<li><a href="https://stackoverflow.com/questions/429529/what-does-the-symbol-before-a-variable-name-mean-in-c" target="_blank" rel="noopener">What does the @ symbol before a variable name mean in C#? [duplicate]</a></li>
</ul>
<h3 id="await-async"><a href="#await-async" class="headerlink" title="await/async"></a>await/async</h3><ul>
<li><a href="https://qiita.com/rawr/items/5d49960a4e4d3823722f" target="_blank" rel="noopener">C# 今更ですが、await / async</a></li>
<li><a href="https://qiita.com/acple@github/items/8f63aacb13de9954c5da" target="_blank" rel="noopener">Taskを極めろ！async/await完全攻略</a></li>
</ul>
<h3 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h3><ul>
<li><a href="https://qiita.com/vc_kusuha/items/2048391d821cb94fa489" target="_blank" rel="noopener">[C#]IEnumeratorとIEnumerableを調べた</a></li>
</ul>
<h2 id="3-Unity语法"><a href="#3-Unity语法" class="headerlink" title="3.Unity语法"></a>3.Unity语法</h2><h3 id="1-Instantiate"><a href="#1-Instantiate" class="headerlink" title="1.Instantiate"></a>1.Instantiate</h3><p>根据Prefab生成实例。</p>
<h2 id="3-LINQ-Linq"><a href="#3-LINQ-Linq" class="headerlink" title="3.LINQ (Linq)"></a>3.LINQ (Linq)</h2><ul>
<li><a href="https://qiita.com/nskydiving/items/c9c47c1e48ea365f8995" target="_blank" rel="noopener">はじめての LINQ - Qiita</a></li>
</ul>
<p>当我想深入了解LINQ的时候，我发现我需要先理解Lambda表达式。</p>
<h2 id="4-Reactive-Extensions-Rx"><a href="#4-Reactive-Extensions-Rx" class="headerlink" title="4.Reactive Extensions (Rx)"></a>4.Reactive Extensions (Rx)</h2><ul>
<li><a href="https://qiita.com/acple@github/items/6cfee916f09632037a6e" target="_blank" rel="noopener">こわくないReactive Extensions超入門 - Qiita</a></li>
</ul>
<h2 id="5-UniRx"><a href="#5-UniRx" class="headerlink" title="5.UniRx"></a>5.UniRx</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/35189325" target="_blank" rel="noopener">又见Rx——Rx via UniRx</a></li>
</ul>
<p>这是我在知乎上找到的一篇文章，感觉能学到很多东西。</p>
<p><a href="https://github.com/neuecc/UniRx" target="_blank" rel="noopener">Reactive Extensions for Unity</a></p>
<ul>
<li><a href="https://qiita.com/Marimoiro/items/2ad8a1b422a3fe98f938" target="_blank" rel="noopener">UniRxを導入するメリット ～こういう時にUniRxは使えるよ～ - Qiita</a></li>
</ul>
<h2 id="6-Lambda"><a href="#6-Lambda" class="headerlink" title="6.Lambda"></a>6.Lambda</h2><p>直接搜<code>C# lambda</code>最先出来的三个链接。</p>
<ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions" target="_blank" rel="noopener">Lambda expressions (C# Programming Guide)</a></li>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/operators/lambda-operator" target="_blank" rel="noopener">=&gt; operator (C# Reference)</a></li>
</ul>
<h1 id="Unity中的插件"><a href="#Unity中的插件" class="headerlink" title="Unity中的插件"></a>Unity中的插件</h1><h2 id="SteamVR-Unity"><a href="#SteamVR-Unity" class="headerlink" title="SteamVR Unity"></a>SteamVR Unity</h2><p>要记录的是<br>SteamVR Unity Plugin v2这个Unity的VR开发插件。开始调查这个插件的契机是不知道<code>SteamVR_Behaviour_Pose</code>这个类的作用，而明白这个是插件的内容。</p>
<ul>
<li><p><a href="https://framesynthesis.jp/tech/unity/htcvive/" target="_blank" rel="noopener">Unity＋HTC Vive開発メモ</a></p>
</li>
<li><p><a href="https://framesynthesis.jp/tech/unity/xr/" target="_blank" rel="noopener">Unity標準のVR機能（UnityEngine.XR）メモ</a></p>
</li>
</ul>
<p>上面的这个人的文章我看很厉害就直接先粘链接了。</p>
<h3 id="SteamVR-Behaviour-Pose"><a href="#SteamVR-Behaviour-Pose" class="headerlink" title="SteamVR_Behaviour_Pose"></a>SteamVR_Behaviour_Pose</h3><h2 id="Amplify-Shader-Editor"><a href="#Amplify-Shader-Editor" class="headerlink" title="Amplify Shader Editor"></a>Amplify Shader Editor</h2><ul>
<li><a href="http://www.asset-sale.net/entry/Amplify_Shader_Editor" target="_blank" rel="noopener">【Amplify Shader Editor】ノードベースでシェーダ作りのAmplifyを触ってみました。エディタの操作性、学習コスト、サンプルデモを大量に紹介！</a></li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>笔记</tag>
        <tag>plugins</tag>
        <tag>Unity2019.1.3</tag>
      </tags>
  </entry>
  <entry>
    <title>学习OpenGL</title>
    <url>/learn-opengl/</url>
    <content><![CDATA[<p>再不赶上日程把OpenGL看了，那可就真的要懒死了啊。</p>
<ul>
<li><a href="https://learnopengl.com/Getting-started/OpenGL" target="_blank" rel="noopener">OpenGL</a></li>
</ul>
]]></content>
      <categories>
        <category>OpenGL</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的常见关键字记录</title>
    <url>/c++-modifier-keyword/</url>
    <content><![CDATA[<p>之后需要整理并理解的:</p>
<ul>
<li><a href="https://zh.cppreference.com/w/cpp/language/explicit" target="_blank" rel="noopener">explicit说明符</a></li>
</ul>
<p>偶然看见的:</p>
<ul>
<li><p><a href="http://c-crad.wktk.so/td/?p=250" target="_blank" rel="noopener">explicitとvolatileキーワード(C++)</a></p>
</li>
<li><p><a href="https://qiita.com/aminevsky/items/82ecce1d6d8b42d65533" target="_blank" rel="noopener">Typedefの考え方</a></p>
</li>
</ul>
<p>除了关键字，符号也算</p>
<ul>
<li><a href="https://qiita.com/1024chon/items/f17ee5afc6644cfd33f1" target="_blank" rel="noopener">*p++のお話(インクリメント演算子って不思議だね</a></li>
</ul>
<p>哇这篇文章根本没怎么更新呢..</p>
<p>这一天我在公司的项目中看到了大佬使用了<code>*&amp;</code>这个运算符，没用过这啊，看看什么意思</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5789806/meaning-of-and-in-c" target="_blank" rel="noopener">Meaning of *&amp; and **&amp; in C++</a></li>
</ul>
<h1 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h1><p>关于指针和引用这一块儿我不明白的地方有很多，可以简单验证的方法有很多，我就是懒。</p>
<h2 id="与-amp-的区别"><a href="#与-amp-的区别" class="headerlink" title="* 与 &amp; 的区别"></a>* 与 &amp; 的区别</h2><ul>
<li><a href="https://stackoverflow.com/questions/28778625/whats-the-difference-between-and-in-c/28778902" target="_blank" rel="noopener">What’s the difference between * and &amp; in C?</a><br>这里是这两种关键字出现在函数的参数修饰符的位置。关于作为函数的参数，有什么区别的问题：<blockquote>
<p><code>funct(int a)</code></p>
<p>Creates a copy of a</p>
<p><code>funct(int * a)</code> </p>
<p>Takes a pointer to an int as input. But makes a copy of the pointer.</p>
<p><code>funct(int&amp; a)</code></p>
<p>Takes an int, but by reference. a is now the exact same int that was given. Not a copy. Not a pointer.</p>
</blockquote>
</li>
</ul>
<p>还有其他的答案也很好，有一些我不知道的知识点，之后整理。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next博客修缮笔记</title>
    <url>/Hexo+Next-maintain-myblog-note/</url>
    <content><![CDATA[<p>自从发现自己写的东西被人原封不动的复制粘贴扔到了CSDN之后，曾经一度想要废了这个博客，写博客对我来说就是一个记笔记的过程，记录自己工作中遇到的问题和解决过程，顺便写写自己的心得什么的，就是很随意。未想着给别人看，但是要是写的某一个地方帮上了某个地方的某个人也是好事情，哪怕不知道有没有，但也是一种安慰了。所以博客自建成起，就根本没设置什么自欺欺人的评论功能点赞功能。也没想着会有。</p>
<p>但是整篇文章直接贴走，连个转载链接都不留是不是就有些过分了，生气不可避免了但是也只是只能无能狂怒了。去CSDN注册个账户举报？说到底对于我去CSDN注册账户这件事情都很抵触。算了，就算了吧。</p>
<a id="more"></a>
<h1 id="关于博客内容书写"><a href="#关于博客内容书写" class="headerlink" title="关于博客内容书写"></a>关于博客内容书写</h1><ul>
<li>2020/11/20 : 对新建文章的模板进行了修改</li>
<li>2021/02/19 : 把博客的配置及源文件上传到了Github仓库分支方便多台PC整理博客</li>
<li>2021/03/21 : 对新电脑上的博客重新配置遇到了好多问题</li>
</ul>
<h2 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h2><p>果然UE4中的有些代码不会给你高亮，看起来就很不舒服，有时间填一下坑。</p>
<h1 id="关于博客构建"><a href="#关于博客构建" class="headerlink" title="关于博客构建"></a>关于博客构建</h1><h2 id="博文压缩"><a href="#博文压缩" class="headerlink" title="博文压缩"></a>博文压缩</h2><p>我之前貌似有整过这个叫做<code>gulp</code>的东西。而且连<code>gulpfile.js</code>这个文件也存在。</p>
<p>因为用起来麻烦就忘了。</p>
<p>执行</p>
<p><code>hexo g &amp;&amp; gulp</code></p>
<p>就会压缩public中的静态资源文件。</p>
<h2 id="定义新建文章的模板"><a href="#定义新建文章的模板" class="headerlink" title="定义新建文章的模板"></a>定义新建文章的模板</h2><p>因为每次都要手动添加新的项目，心血来潮找了找有没有修改新建文章模板的方法</p>
<ul>
<li><a href="https://azriton.github.io/2016/11/04/Hexo%E3%81%AE%E6%96%B0%E8%A6%8F%E6%8A%95%E7%A8%BF%E3%83%86%E3%83%B3%E3%83%97%E3%83%AC%E3%83%BC%E3%83%88%E3%82%92%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%9E%E3%82%A4%E3%82%BA/" target="_blank" rel="noopener">Hexo の 新規投稿テンプレート を カスタマイズ</a></li>
</ul>
<h2 id="修改code代码块自定义样式"><a href="#修改code代码块自定义样式" class="headerlink" title="修改code代码块自定义样式"></a>修改<code>code</code>代码块自定义样式</h2><p><code>\themes\next\source\css\_custom\custom.styl</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我加入了上面的代码，原先是什么都没有的…</p>
<p>看了下效果，嗯，感觉什么都没变。</p>
<p>寝るか</p>
<h2 id="转移电脑的博客遇见的大坑"><a href="#转移电脑的博客遇见的大坑" class="headerlink" title="转移电脑的博客遇见的大坑"></a>转移电脑的博客遇见的大坑</h2><p>将自己的博客的内容转移到新的电脑遇见了不少的大坑，在这里稍作记录。</p>
<p>首先是如何使用双分支管理博客的源文件和生成的静态网页文件。<strong>SourceBranch</strong>用来管理博客的源文件，<strong>master</strong>则用来上传博客的静态文件。</p>
<p>平常的工作流程一般是先<code>pull origin SourceBranch</code>，嘛如果有在两个电脑上进行更新的话。先对源文件及<code>source/_post</code>文件夹下面的源文件进行博文的添加和书写。其次是<code>hexo d -g -m &quot;comment&quot;</code>对源文件进行镜头网页的生成和网页部署，即生成网页并推送到Github上。最后则是将本地的<strong>SourceBranch</strong>的内容改动commit结束。</p>
<p>前提是自己的部署Deploy文件会默认将部署推送到远程的<strong>master</strong>的分支上。</p>
<p>然后就是这个过程中遇到的大坑。首先是Window上需要运行Hexo的环境构建，Hexo的运行需要NodeJs，但是过高的版本Hexo并不支持。我自己选的版本是nodejs.v12.14版本。太新的版本没有办法将本地生成的网页部署到（推送）远程。安装完后基本上用到的命令就是<code>npm install</code>安装所有的node_module(注意要在博客的根目录，也就是这个文件夹所在的目录),<code>npm install hexo-cli -g</code>（Hexo不好用的时候重新安装Hexo）。</p>
<p>其次是主题的版本，我用的next的主题但是又不能随便找一个网上的主题，只好沿用自己之前的主题，把之前的电脑的主题文件整个文件夹压缩转移到了新电脑，然后运行<code>hexo clean</code>重新配置生成网页，才解决了网页里出现了不知道是哪国语言的尴尬问题。</p>
<hr>
<ul>
<li>2021/05/05 前来更新</li>
</ul>
<p>对于上面的问题，由于这之前遇到了博客界面格式没有了的问题，迫不得已逐个解决了。首先是上面的next主题文件的语言问题，主要是中文的解析没对上的原因。具体的解决问题的操作的是去next主题的language文件夹中找到自己在博客的整体<code>_config.yml</code>文件中设置的语言是否存在。</p>
<p>我上面网页中出现了不知道哪国语言的问题，经过查看之后发现,<code>_config.yml</code>文件中设置的语言是<strong>zh-Hans</strong>,而主题中的语言没有这个，解决方案是把其中的<code>zh-CN.yml</code>重命名为<code>zh-Hans.yml</code>，文字的问题就解决了。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/science_Lee/article/details/84633237" target="_blank" rel="noopener">Hexo语言不生效问题</a></li>
</ul>
<p>然后就是格式的问题，我在本地运行的环境(<code>hexo s</code>)中博客的格式都会完美的显示，但是部署到Github之后格式就没有了，尝试了很多，最后是从CSS文件找不到路径的问题找到了答案。<br><br>原因则是网页的URL设置有些问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://stonelzp.github.io</span><br><span class="line">root: /</span><br></pre></td></tr></table></figure></p>
<p>修改之后的结果。</p>
<p>参考链接:</p>
<ul>
<li><a href="https://github.com/hexojs/hexo/issues/1121" target="_blank" rel="noopener">生成路径的问题，导致css，js无法加载</a></li>
</ul>
<hr>
<ul>
<li>2021/06/01 更新</li>
</ul>
<p>博客换了电脑之后，主题虽然没变但是好多设定都丢了，包含我用的很顺手的本地搜索。实在是太常用了，没有的话很困扰，就前来解决了。</p>
<p>需要检查的有两处：</p>
<ol>
<li>hexo-generator-search插件是否安装</li>
<li>本地搜索是否开启</li>
</ol>
<p>第一个直接搜命令使用npm安装就好。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></p>
<p>第二个去主题的配置文件找到<strong>local_search</strong>条目<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想-第一卷-第十五章-多态性和虚函数</title>
    <url>/c++-chapter15-virtual/</url>
    <content><![CDATA[<p><em>多态性（在C++中通过虚函数来实现）是面向对象程序设计中数据抽象和继承之外的第三个基本特征。</em></p>
<a id="more"></a>
<h1 id="多态性和虚函数"><a href="#多态性和虚函数" class="headerlink" title="多态性和虚函数"></a>多态性和虚函数</h1><h2 id="15-1-C-程序员的演变"><a href="#15-1-C-程序员的演变" class="headerlink" title="15.1 C++程序员的演变"></a>15.1 C++程序员的演变</h2><p>虚函数增强了类型概念，而不是只在结构内部隐蔽的封装代码，所以毫无疑问，对于新的C++程序员来说，这些概念是最困难的。然而它们是理解面向对象程序设计的转折点。<strong>如果不用虚函数，就等于还不懂得面向对象程序设计（OOP）</strong>。</p>
<h2 id="15-2-向上类型转换"><a href="#15-2-向上类型转换" class="headerlink" title="15.2 向上类型转换"></a>15.2 向上类型转换</h2><p>在第14章中，我们已经看到对象如何能作为它自己的类或作为它的基类的对象使用。另外，<strong>还能通过基类的地址操作它。取一个对象的地址（指针或者引用），并将其作为基类的地址来处理，这被称为向上类型转换（upcasting），因为继承树的绘制方式是以基类为顶点的</strong>。</p>
<h2 id="15-3-捆绑（binding）"><a href="#15-3-捆绑（binding）" class="headerlink" title="15.3 捆绑（binding）"></a>15.3 捆绑（binding）</h2><h3 id="15-3-1-函数调用捆绑"><a href="#15-3-1-函数调用捆绑" class="headerlink" title="15.3.1 函数调用捆绑"></a>15.3.1 函数调用捆绑</h3><p>把函数体与函数调用相联系称为捆绑。当捆粄在程序运行之前（由编译器和连接器）完成时，称为早捆绑（early binding）。</p>
<p>晚捆绑（late bingding）根据对象的类型，发生在运行时。又称为动态捆绑（dynamic binding）或运行时捆绑（runtime binding）。</p>
<h2 id="15-4-虚函数"><a href="#15-4-虚函数" class="headerlink" title="15.4 虚函数"></a>15.4 虚函数</h2><p>对于特定的函数，为了引起晚捆绑，C++要求在基类中声明这个函数的时候使用<strong>virtual</strong>关键字。<strong>晚捆绑只对virtual函数起作用，而且只在使用含有virtual函数的基类的地址时发生，尽管它们也可以在更早的基类中定义。</strong></p>
<p><strong>仅仅在声明的时候需要使用virtual关键字，定义时不需要。</strong> 如果一个函数在基类中被声明为virtual，那么在所有的派生类中它都是virtual。在派生类中virtual函数的重定义通常称为重写（overriding）。</p>
<p>注意，仅需要在基类中声明一个函数为virtual。调用所有匹配基类声明行为的派生类函数都将使用虚机制。虽然可以在派生类声明前使用关键字virtual（这也是无害的），但这样会使程序段显得冗余和混乱。</p>
<h3 id="15-4-1-扩展性"><a href="#15-4-1-扩展性" class="headerlink" title="15.4.1 扩展性"></a>15.4.1 扩展性</h3><p>编译器保证对于虚函数总是有某种定义，所以绝不会出现最终调用不与函数体捆绑的情况（这种情况将导致灾难）。</p>
<p><span style="color:grey"><br>这里我有相当大的疑问：<br></span></p>
<p>按照上面的说法，继承的基类中有虚函数的情况下，派生类都将使用虚机制</p>
<ul>
<li>虚机制是什么</li>
</ul>
<p>其次，按照上面的描述在派生类声明前加上virtual也可以，也就是说派生类中的函数也称为了虚函数？</p>
<p>然后是在派生类中定义了一个名为<code>FunctionA()</code>的新的函数的话，这个函数尽管没有加入virtual关键字，实际上也是虚函数？</p>
<p>然后假设从相同基类派生的派生类<code>PAClass()</code>和<code>PBClass()</code>两个同时新定义了一个名为<code>FunctionA()</code>的函数的话，这种情况下他们是相同的虚函数吗？</p>
<p><span style="color:grey"><br>按照书上说的意思（我的理解），<em>出现上面情况的时候，将会自动的调用继承层次中“最近”的定义</em>。<br></span></p>
<p>但我不太懂。还是得继续摸索下去。</p>
<h2 id="15-5-C-如何实现晚捆绑"><a href="#15-5-C-如何实现晚捆绑" class="headerlink" title="15.5 C++如何实现晚捆绑"></a>15.5 C++如何实现晚捆绑</h2><p>当告诉编译器要晚捆绑时（通过创建虚函数来告诉），编译器安装必要的晚捆绑机制。</p>
<p>关键字virtual告诉编译器它不应当执行早捆绑，相反，它应当自动安装对于实现晚捆绑必须的所有机制。</p>
<p><strong>为了达到这个目的，典型的编译器（通用的方法）对每个包含虚函数的类创建一个表（称为VTABLE）。在VTABLE中，编译器放置特定类的虚函数的地址。在每个带有虚函数的类中，编译器秘密的放置一个指针，称为vpointer（缩写为VPTR），指向这个对象的VTABLE。当通过基类指针做虚函数调用时（也就是做多态调用），编译器静态的插入能取得这个VPTR并在VTABLE表中查找函数地址的代码，这样就能调用正确的函数并引起晚捆绑的发生。</strong></p>
<h3 id="15-5-1-存放类型信息"><a href="#15-5-1-存放类型信息" class="headerlink" title="15.5.1 存放类型信息"></a>15.5.1 存放类型信息</h3><p>必须有一些类型信息放在对象中，否则类型将不能在运行时建立。但是类型信息被隐蔽了。</p>
<p>不带虚函数，对象的长度恰好就是所期望的长度。而带有单个或多个虚函数的对象，是所期望的长度加上一个void指针的长度。</p>
<p>它反映出，如果有一个或多个虚函数，编译器都只在这个结构中插入一个单个指针（VPTR）。这是因为VPTR指向一个存放函数地址的表。</p>
<h3 id="15-5-2-虚函数功能图示"><a href="#15-5-2-虚函数功能图示" class="headerlink" title="15.5.2 虚函数功能图示"></a>15.5.2 虚函数功能图示</h3><p><span style="color:grey"><br>上不了图了<br><span></span></span></p>
<p><strong>每当创建一个包含有虚函数的类或从包含有虚函数的类派生一个类时，编译器就为这个类型创建一个唯一的VTABLE。在这个表中，编译器放置了在这个类中或在它的基类中所有已声明为virtual的函数的地址。如果在这个派生类中没有对基类中声明为virtual的函数进行重新定义，编译器就使用基类的这个函数的虚函数地址。</strong></p>
<p>当使用简单继承时，对于每个对象只有一个VPTR。VPTR必须被初始化为指向VTABLE的起始地址。（这个在构造函数中发生，在稍后会看的更清楚）</p>
<p>一旦VPTR被初始化为指定相应的VPTR。对象就知道它自己是什么类型。但只有当虚函数被调用的时候这种自我认知才有用。</p>
<p>当通过基类地址调用一个虚函数时（此时编译器没有能完成早捆绑所需的所有信息），要特殊处理。它不是实现典型的函数调用，那样只是简单的用汇编语言CALL特定的地址，而是编译器为完成这个函数调用而产生不同的代码。</p>
<p><span style="color:grey"><br>此处应有图但是上不了。<br><span></span></span></p>
<p>编译器从这个Instrument（基类）指针开始，这个指针指向这个对象的起始地址。对于所有的Instrument对象和由Instrument派生的对象，它们的VPTR都在对象的相同位置（常常在对象的开头），所以编译器就能取出这个对象的VPTR。VPTR指向VTABLE的起始地址。所有的VTABLE都具有相同的顺序，不管何种类型的对象。<code>Play()</code>是第一个， <code>What()</code>是第二个， <code>Adjust()</code>是第三个。所以无论是什么特殊的对象类型，编译器都知道<code>Adjust()</code>是必在VPTR+2处。这样就不是以“Instrument::Adjust”地址调用这个函数，而实际上是在“VPTR+2”处调用这个函数。因为获取VPTR和确定实际函数地址发生在运行时，所以这样就得到了所希望的晚捆绑。</p>
<h3 id="15-5-3-揭开面纱"><a href="#15-5-3-揭开面纱" class="headerlink" title="15.5.3 揭开面纱"></a>15.5.3 揭开面纱</h3><p>看一下虚函数调用产生的汇编语言代码。下面是在函数<code>f(Instrument&amp;i)</code>内部调用</p>
<p><code>i.Adjust(1);</code></p>
<p>某个编译器所产生的输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push  1</span><br><span class="line">push  si</span><br><span class="line">mov   bx, word ptr [si]</span><br><span class="line">call  word ptr [bx+4]</span><br><span class="line">add   sp, 4</span><br></pre></td></tr></table></figure></p>
<p><span style="color:grey"><br>说实话我是看不懂汇编的。<br><span></span></span></p>
<p>C++函数调用的参数与C函数调用一样，是从右向左进栈的（这个顺序是为了支持C的变量参数表），所以参数1首先压栈。对于这个函数，寄存器si（Intel x86处理器的一部分）存放i的地址。因为它是被选中对象的首地址，它也被压进栈。记住，这个首地址对应this的值，正因为调用每个成员函数时this都必须作为参数压进栈，所以成员函数知道它工作在哪个特殊对象上。这样我们总能看到，在成员函数调用之前压栈的次数等于参数个数加1（除了static成员函数，因为它没有this）。</p>
<p>然后必须实现实际的虚函数调用。首先，必须产生VPTR，找到VTABLE。对于这个编译器，VPTR在对象的开头，所以this的内容对应于VPTR。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov   bx, word ptr [si]</span><br></pre></td></tr></table></figure></p>
<p>取出si（即this）所指的字，它就是VPTR。将VPTR放入bx寄存器中。</p>
<p>在bx中这个VPTR指向VTABLE的首地址，调用的函数在VTABLE中的第二个位置（0，1，2,它是表中的第三个函数）。对于这种内存模式，每个函数指针是两个字节长，所以VPTR+4，计算相应的函数地址所在的地方。</p>
<p>幸好编译器仔细处理，并保证VTABLE中的所有函数指针都以相同的次序出现，而不论我们在派生类中是以什么样的顺序覆盖它们。</p>
<p>一旦VTABLE中相应函数指针的地址被计算出来，就调用这个函数。所以取出这个地址并马上在这个句子中调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call  word ptr [bx+4]</span><br></pre></td></tr></table></figure></p>
<p>最后栈指针移回去，以清除在调用之前压入栈的参数。在C和C++汇编代码中，将经常看到调用者清除这些参数，但这可能依据处理器和编译器的实现而有所不同。</p>
<h3 id="15-5-4-安装vpointer"><a href="#15-5-4-安装vpointer" class="headerlink" title="15.5.4 安装vpointer"></a>15.5.4 安装vpointer</h3><p>因为VPTR决定了对象的虚函数的行为，所以我们看到VPTR总是指向相应的VTABLE是多么重要。在VPTR适当初始化之前绝不能调用虚函数。</p>
<h3 id="15-5-5-对象是不同的"><a href="#15-5-5-对象是不同的" class="headerlink" title="15.5.5 对象是不同的"></a>15.5.5 对象是不同的</h3><p><strong>认识到向上类型转换仅处理地址，这是重要的。</strong></p>
<p>如果编译器有一个它知道确切类型的对象，那么（在C++中）对任何函数的额调用不再使用晚捆绑，或至少编译器不必使用晚捆绑。因为编译器知道对象的确切类型，为了提高效率，当调用这些对象的虚函数时，很多编译器使用早捆绑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Early binding &amp; virtual functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="string">""</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Bark"</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog ralph;</span><br><span class="line">    Pet* p1 = &amp;ralph;</span><br><span class="line">    Pet&amp; p2 = ralph;</span><br><span class="line">    Pet p3;</span><br><span class="line"></span><br><span class="line">    p1-&gt;speak();</span><br><span class="line">    p2.speak();</span><br><span class="line">    p3.speak();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用地址就意味着不完全，p1,p2可能表示Pet的地址，也可能是其派生对象的地址，所以必须使用虚函数。而当调用p3的时候,不存在含糊，编译器知道确切的类型并且知道它是一个对象，这样可以使用早捆绑。</p>
<h2 id="15-6-为什么需要虚函数"><a href="#15-6-为什么需要虚函数" class="headerlink" title="15.6 为什么需要虚函数"></a>15.6 为什么需要虚函数</h2><p><strong>virtual关键字可以改变程序的效率。</strong></p>
<p>从前面的汇编语言输出可以看出，它并不是对于绝对地址的一个简单的CALL，而是为设置虚函数调用需要两条以上的复杂的汇编指令。这既需要代码空间，又需要执行时间。</p>
<h2 id="15-7-抽象基类和纯虚函数"><a href="#15-7-抽象基类和纯虚函数" class="headerlink" title="15.7 抽象基类和纯虚函数"></a>15.7 抽象基类和纯虚函数</h2><p>在基类中加入至少一个纯虚函数（pure virtual function），来使基类称为抽象（abstract）类。纯虚函数使用virtual关键字，并且在后面加上=0.如果某人试着生成一个抽象类的对象，编译器就会制止他。</p>
<p>当继承一个抽象类时，必须实现所有的虚函，否则继承出的类也将是一个抽象类。</p>
<p>纯虚函数的声明语法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual void f() = 0;</span><br></pre></td></tr></table></figure></p>
<p>这样做，等于告诉编译器在VTABLE中为函数保留一个位置，但在这个特定位置中不放地址（<span style="color:grey">或者说是放不了地址</span>），只要有一个函数在类中被声明为纯虚函数，则VTABLE就是不完全的。编译器不能安全的创建一个纯抽象类的对象，保证了抽象类的纯洁性，就不会被误用了。</p>
<p><strong>注意，纯虚函数禁止对抽象类的函数以传值方式调用。</strong></p>
<p>这也是防止对象切片（object slicing）的一种方法。通过抽象类，可以保证在向上类型转换期间总是使用指针或引用。</p>
<p>纯虚函数防止产生完全的VTABLE，但这并不意味着我们不希望对其他一些函数产生函数体。我们常常希望调用一个函数的基类版本，即使它是虚拟的。把公共代码尽可能靠近我们的类层次根的地方，这是很好的想法。</p>
<p><span style="color:grey">也就是说下面的纯虚函数定义了</span></p>
<h3 id="15-7-1-纯虚定义"><a href="#15-7-1-纯虚定义" class="headerlink" title="15.7.1 纯虚定义"></a>15.7.1 纯虚定义</h3><p>在基类中，对纯虚函数提供定义是可能的。我们仍然告诉编译器不允许产生抽象基类的对象，如果想要创建对象，则纯虚函数必须在派生类中定义。</p>
<p><span style="color:grey">好处一：</span></p>
<p>然而我们希望一段公共代码，使一些或所有派生类都能调用，而不必在每个函数中重复这段代码。</p>
<p>如下面的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pure virtual base definitions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">const</span> </span>=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Inline pure virtual definitions illegal:</span></span><br><span class="line">    <span class="comment">//! virtual void sleep() const = 0 &#123;&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, not defined inline</span></span><br><span class="line"><span class="keyword">void</span> Pet::eat() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Pet::speak() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; Pet::speak(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; Pet::eat(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog d;</span><br><span class="line">    d.speak();</span><br><span class="line">    d.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Pet的VTABLE依然空着，但这个派生类中刚好有一个函数，可以通过名字调用它。</p>
<p><span style="color:grey">好处二：</span></p>
<p>这个特点的另一个好处是，它允许我们实现从常规函数到纯虚函数的改变，而无需打乱存在的代码。（这是一个处理不用重新定义虚函数的类的方法）</p>
<p><span style="color:grey">隐约觉得这个功能很强，让我联想到了静态函数，你看它直接通过类名调用就很厉害。这应该又涉及到另外的机制了吧。</span></p>
<h2 id="15-8-继承和VTABLE"><a href="#15-8-继承和VTABLE" class="headerlink" title="15.8 继承和VTABLE"></a>15.8 继承和VTABLE</h2><p>当实现继承和重新定义一些虚函数时，编译器对新类创建一个新的VTABLE表，并且插入新函数的地址，对于没有重新定义的虚函数使用基类函数的地址。无论如何，对于被创建的每个对象（即它的类不含有纯虚函数），在VTABLE中总有一个函数地址的全集，所以绝对不能对不在其中的地址进行调用（否则结果将是灾难性的）。</p>
<p>当派生类继承了基类中的虚函数之后又增加了新的虚函数。可以知道VTABLE中增加了新的虚函数。</p>
<p>然而在这里，编译器只对指向基类对象的指针工作。即基类的虚函数是指向基类对象指针的编译器唯一允许调用的函数。</p>
<p><span style="color:grey">这跟我的理解是一致的，使用指向基类的指针并不能够调用子类新添加的函数时理所应当的。</span></p>
<p>只有基类对象的指针，那么编译器也不知道这个指针指向的内容是不是派生类，所以编译器通过防止我们对只存在于派生类中的函数做虚函数调用来完成工作。</p>
<p>但是当我们知道指针实际上指向哪一种特殊对象时，还想要去使用的少数情况时，则必须类型转换这个指针。</p>
<p>这就是<strong>运行时类型辨认（Run-Time Type Identification, RTTI）</strong> 问题。</p>
<p>RTTI是有关向下类型转换基类指针到派生类指针的问题（向上和向下是相对典型类图而言的，典型类图以基类为顶点）。向上类型转换是自动发生的，不需强制，因为它是绝对安全的。向下类型转换是不安全的，因为这里没有实际类型的编译时信息，所以必须准确的知道这个类实际上是什么类型。</p>
<h3 id="15-8-1-对象切片"><a href="#15-8-1-对象切片" class="headerlink" title="15.8.1 对象切片"></a>15.8.1 对象切片</h3><p>对象切片实际上是当它拷贝到一个新的对象时，去掉原来对象的一部分，而不是使用指针或者引用那样简单的改变地址的内容。</p>
<h2 id="15-9-重载和重新定义"><a href="#15-9-重载和重新定义" class="headerlink" title="15.9 重载和重新定义"></a>15.9 重载和重新定义</h2><p><strong>在第14章中，我们看到重新定义一个基类中的重载函数将会隐藏所有该函数的其他基类版本。</strong> 而当对虚函数进行这些操作时，情况会有点不同。</p>
<p>编译器不允许我们改变重新定义过的函数的返回值（如果该函数不是虚函数，则是允许的）。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived3</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Can not change return type:</span></span><br><span class="line">    <span class="comment">//! void f() const &#123; // do something&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果重新定义了基类中的一个重载成员函数，则在派生类中其它的重载函数将会被隐藏。</p>
<p><span style="color:grey">虚函数还写函数重载这个想法我还真没想到。</span></p>
<p>有的时候这种情况还真有，也许是考虑不足的缘故，当试着写了一个共通的虚函数，这个虚函数并不能适应所有的情况，比如说参数个数或者类型不匹配的情况，就会写出将父类继承来的虚函数进行重载的情况。</p>
<p>这里需要理清的的是，我们是因为什么才引进的虚函数。</p>
<p>我自己的理解是，是为了一劳永逸，调用一处的代码（使用父类虚函数调用）然后传递子类指针，子类的虚函数实现就被执行。</p>
<p>但是发生上面的虚函数重载情况怎么说？</p>
<p>首先，需要理解虚函数重载之后发生了什么，即上面所说的，该函数的重载，使得该函数的所有其他版本被隐藏。救我自己的观察来看，造成的现象是：</p>
<ol>
<li><code>member function does not override any base class virtual member function</code> 并没有重写任何基类函数？！</li>
<li><code>no override available for virtual member function from base &#39;BaseFunction&#39;; function is hidden</code> 基类虚函数没有被实现，函数被隐藏？</li>
</ol>
<p>上面的这是编译器给出的警告信息，并不是错误。从信息来看，意思完全不一样。完全成了同名的函数，跟基类完全没有关系似的。</p>
<h3 id="override-Specifier"><a href="#override-Specifier" class="headerlink" title="override Specifier"></a>override Specifier</h3><ul>
<li><a href="https://docs.microsoft.com/ja-jp/cpp/cpp/override-specifier?view=vs-2019" target="_blank" rel="noopener">override Specifier</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function-declaration override;</span><br></pre></td></tr></table></figure>
<ul>
<li>对基类的虚函数进行重载时，加override会出编译错误(修改参数或者const修饰符等)</li>
<li>试图重载基类的非虚函数时，加override会出编译错误</li>
</ul>
<p>都是上面官方链接的例子。</p>
<h3 id="final-Specifier"><a href="#final-Specifier" class="headerlink" title="final Specifier"></a>final Specifier</h3><ul>
<li><a href="https://docs.microsoft.com/ja-jp/cpp/cpp/final-specifier?view=vs-2019" target="_blank" rel="noopener">final Specifier</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function-declaration final;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class</span>-<span class="title">name</span> <span class="title">final</span> <span class="title">base</span>-<span class="title">classes</span></span></span><br></pre></td></tr></table></figure>
<h3 id="15-9-1-变量返回类型"><a href="#15-9-1-变量返回类型" class="headerlink" title="15.9.1 变量返回类型"></a>15.9.1 变量返回类型</h3><p>上面显示了我们不能重新定义过程中修改虚函数的返回类型。通常是这样的，但也有特例，我们可以稍稍修改返回值类型。如果返回一个指向基类的指针或引用，则该函数的重新定义版本将会从基类返回的内容中返回一个指向派生类的指针或引用。</p>
<p>返回确切类型更通用些，而且在自动进行向上类型转换时不丢失特定的信息。然而，返回基类类型通常会解决我们的问题，所以这是一个特殊的功能。</p>
<p><span style="color:grey">这个感觉就像是编译器会做返回值的类型检查，对于指针而言，返回基类类型指针的函数得到了一个派生类类型的指针，由于继承的特性，所以这是成立的。反过来应该就不行。</span></p>
<h2 id="15-10-虚函数和构造函数"><a href="#15-10-虚函数和构造函数" class="headerlink" title="15.10 虚函数和构造函数"></a>15.10 虚函数和构造函数</h2><p>编译器在构造函数的开头部分秘密地插入能初始化VPTR的代码。正如第14张所述，如果我们没有为一个类显式创造构造函数，则编译器会为我们生成构造函数。如果该类含有虚函数，则生成的构造函数将会包含相应的VPTR初始化代码。这有几个含义。</p>
<p>首先，这涉及效率。<strong>内联（inline）函数</strong> 的作用是对小函数减少调用代价。如果C++不提供内联函数，则预处理器就可能被用来创建这些“宏”。然而预处理器没有访问或类的概念。因此不能被用来创建成员函数宏。另外，有了由编译器插入的隐藏代码的构造函数，预处理宏根本不能工作。</p>
<p><span style="color:grey">上面这段话看得我不知所谓，事实来说C++提供了内联函数。我不太理解预处理宏是什么，最后一句为什么那种情况下预处理宏不能工作的具体原因是什么？</span></p>
<p>当寻找效率漏洞时，我们必须明白，编译器正在插入隐藏代码到我们的构造函数中。这些隐藏代码不仅必须初始化VPTR，而且还必须检查this的值（以免operator new返回零）和调用基类构造函数。放在一起，这些代码可以影响我们认为是一个小内联函数的调用。特别是构造函数的规模会抵消函数调用代价的减少。如果做大量的内联函数调用，代码长度就会增长。而在速度上没有任何好处。</p>
<p>当然也许并不会立即把所有这些小构造函数都变成非内联，因为它们更容易写为内联构造函数。但是，当我们正在调整我们的代码时，记住，务必去掉这些内联构造函数。</p>
<p><span style="color:grey">所以这些内联构造函数是可以删除的？还是说变成非内联？</span></p>
<h3 id="15-10-1-构造函数调用次序"><a href="#15-10-1-构造函数调用次序" class="headerlink" title="15.10.1 构造函数调用次序"></a>15.10.1 构造函数调用次序</h3><p>所有基类构造函数总是在继承类构造函数中被调用。</p>
<h3 id="15-10-2-虚函数在构造函数中的行为"><a href="#15-10-2-虚函数在构造函数中的行为" class="headerlink" title="15.10.2 虚函数在构造函数中的行为"></a>15.10.2 虚函数在构造函数中的行为</h3><p><strong>对于在构造函数中调用一个虚函数的情况，被调用的只是这个函数的本地版本。也就是说，虚机制在构造函数中不工作。</strong></p>
<p>这种行为有两个理由。在概念上，构造函数的工作是构造一个对象。在构造函数中此时可能只是部分形成对象–我们只能知道基类已被初始化，但并不能知道是那个类从这个基类继承来的。然而，虚函数在继承层次上是“向前”和“向外”的进行调用。它可以调用在派生类中的函数。如果我们在构造函数中也这样做，那么我们所调用的函数可能操作尚未初始化的成员，导致灾难的发生。</p>
<p>第二个理由是机械的。当一个构造函数被调用的时候，它做的首要事情之一是初始化它的VPTR。然儿它知道它属于“当前”类，即构造函数所在的类。当编译器为这个构造函数产生代码时，它使用的VPTR必须是对于这个类的VTABLE。<strong>VPTR的状态是由最后被调用的构造函数确定的。</strong> 这就是为什么构造函数调用是按照从基类到最晚派生类的顺序的另一个理由。</p>
<p>另外，许多编译器认识到，如果在构造函数中进行虚函数调用，应该使用早捆绑，因为它们知道晚捆绑将只对本地函数产生调用。无论哪种情况，在构造函数中调用虚函数都不能得到预期的结果。</p>
<h2 id="15-11-析构函数和虚拟析构函数"><a href="#15-11-析构函数和虚拟析构函数" class="headerlink" title="15.11 析构函数和虚拟析构函数"></a>15.11 析构函数和虚拟析构函数</h2><p><strong>构造函数是不能为虚函数的。但析构函数能够且常常必须是虚的。</strong></p>
<p>构造函数有一项特殊的工作，就是一块一块的组合成一个对象。它首先调用基类构造函数，然后调用继承顺序中的更晚派生的构造函数（同样，它也必须按此方法调用成员对象构造函数）。类似的，析构函数也有一项特殊工作，即它必须拆卸属于某层次类的对象。为了做这些工作，编译器来生成代码来调用所有的析构函数，但它必须按照与构造函数调用相反的顺序。</p>
<p>应当记住，构造函数和析构函数是类层次进行调用的唯一地方（因此，编译器自动的生成适当的类层次）。在所有其它函数中，只有这个函数会被调用（非基类版本），而无论它是虚的还是非虚的。同一函数的基类版本在普通函数中被调用（无论是虚的还是非虚的）的唯一方法是显式的调用这个函数。</p>
<p>如果这个指针是指向基类的，在delete期间，编译器只能知道调用这个析构函数的基类版本。这听起来很耳熟，虚函数被创建恰恰是为了解决这个问题。幸运的是，就像除了构造函数以外的所有其他函数一样，析构函数可以是虚函数。</p>
<p><span style="color:grey">上面的指针指向基类的例子中，如果使用的delete，会依次调用自身的析构函数，然后调用基类的析构函数。前提是:基类的析构函数是虚函数。</span></p>
<p>这正是我们所期望的。<strong>不把析构函数设为虚函数是一个隐匿的错误，因为它常常不会对程序有直接的影响。</strong> 但要注意它不知不觉的引入存储器泄漏（关闭程序时内存未释放）。同样，这样的析构操作还有可能掩盖发生的问题。</p>
<p><span style="color:grey">我靠这到底想让我怎么写？！</span></p>
<p>即使析构函数像构造函数一样，是“例外”函数，但是析构函数可以是虚的，这是因为这个对象已经知道它是什么类型（而在构造期间则不然）。一旦对象已被构造，它的VPTR就已被初始化，所以能发生虚函数调用。</p>
<h3 id="15-11-1-纯虚析构函数"><a href="#15-11-1-纯虚析构函数" class="headerlink" title="15.11.1 纯虚析构函数"></a>15.11.1 纯虚析构函数</h3><p>尽管纯虚析构函数在标准C++中是合法的，但在使用的时候有一个限制:<strong>必须为纯虚析构函数提供一个函数体。</strong></p>
<p><strong>不像其他的纯虚函数，我们不要求派生类中提供纯虚函数的定义。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~AbstractBase() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>析构函数的纯虚性的唯一效果是阻止基类的实例化</strong>。如果有其他的纯虚函数，则它们会阻止，否则，纯虚析构函数会执行这项操作。所以当虚析构函数是十分必要时，则它是不是纯虚的就不是那么重要了。</p>
<h3 id="15-11-2-析构函数中的虚机制"><a href="#15-11-2-析构函数中的虚机制" class="headerlink" title="15.11.2 析构函数中的虚机制"></a>15.11.2 析构函数中的虚机制</h3><p><strong>在析构函数中，只有成员函数的“本地”版本被调用；虚机制被忽略。</strong></p>
<p>在构造函数的情况下这样做是因为类型信息还不可用，然而在析构函数中，这样做是因为信息（也就是VPTR）虽存在，但不可靠。（可能派生的对象已被析构）。</p>
<h3 id="15-11-3-创建基于对象的继承"><a href="#15-11-3-创建基于对象的继承" class="headerlink" title="15.11.3 创建基于对象的继承"></a>15.11.3 创建基于对象的继承</h3><p>利用多态性，强制容器中的所有对象从一个基类中继承而来，随后调用虚函数（虚析构函数）来解决所有权问题。</p>
<p>这种解决方法使用单根继承（singly-rooted hierarchy）或基于对象的继承（object-based hierachy）。</p>
<p>事实上，除了C++，每种面向对象的语言都强制使用这样的体系，这个基类由该语言的创建者生成的。C++中认为，强制使用这个公共基类会引起太多的开销，所以便没有使用它。</p>
<p>这里需要警惕<strong>多重继承（multiple inheritance）</strong>。多重继承是非常复杂的，应尽量少用这一功能。</p>
<p>创建包容Object的容器是一种合理的方法–如果使用单根继承（由于语言本身或需要的缘故，强制每个类继承自Object）。这时，保证一切都是一个Object，因此使用容器的时候并不是十分复杂。然而在C++中不能期望这适用于每一个类，所以如果有多重继承就会出现问题。在第16章中会看到模板可以使用更简单更灵巧的方式处理这个问题。</p>
<h2 id="15-2-运算符重载"><a href="#15-2-运算符重载" class="headerlink" title="15.2 运算符重载"></a>15.2 运算符重载</h2><p>就像对成员函数那样，我们可以使用virtual运算符。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于一个处理矩阵向量标量的系统，这三个成分都是派生自Math类</span></span><br><span class="line"><span class="comment">// Polymorphism with overload operators</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scalar</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span>&#123;</span></span><br><span class="line">piblic:</span><br><span class="line">    <span class="keyword">virtual</span> Math&amp; <span class="keyword">operator</span>*(Math&amp; rv) = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Math&amp; <span class="title">multiply</span><span class="params">(Matrix*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Math&amp; <span class="title">multiply</span><span class="params">(Scalar*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Math&amp; <span class="title">nultiply</span><span class="params">(Vector*)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Math() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> :</span> <span class="keyword">public</span> Math&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Math&amp; <span class="keyword">operator</span>*(Math&amp; rv)&#123;</span><br><span class="line">        <span class="keyword">return</span> rv.multiply(<span class="keyword">this</span>);  <span class="comment">// 2nd dispatch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Math&amp; <span class="title">multiply</span><span class="params">(Matrix*)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">"Matrix*Matrix"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Math&amp; <span class="title">multiply</span><span class="params">(Scalar*)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Scalar*Matrix"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Math&amp; <span class="title">multiply</span><span class="params">(Vector*)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Vector*Matrix"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scalar</span> :</span> <span class="keyword">public</span> Math&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 内容省略，跟Matrix类的实现基本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> :</span> <span class="keyword">public</span> Math&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 内容省略，跟Matrix类的实现基本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Martix m;Vector v;Scalar s;</span><br><span class="line">    Math* math[] = &#123;&amp;m, &amp;v, &amp;s&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">            Math&amp; m1 = *math[i];</span><br><span class="line">            Math&amp; m2 = *math[j];</span><br><span class="line">            m1*m2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>main()中的问题在于，表达式<code>m1*m2</code>包含了两个向上类型转换的Math引用，因此不知道这两个对象的类型。<strong>一个虚函数仅能进行单一指派–即判定一个未知对象的类型。</strong> 本例中使用的判定两个对象类型的技术称之为<strong>多重指派（multiple dispatching）</strong> ，一个单一虚函数调用引起了第二个虚函数的调用。在完成第二个调用的时候，已经得到了两个对象的类型，于是可以执行正确的操作。</p>
<h2 id="15-13-向下类型转换（downcasting）"><a href="#15-13-向下类型转换（downcasting）" class="headerlink" title="15.13 向下类型转换（downcasting）"></a>15.13 向下类型转换（downcasting）</h2><p>C++提供了一个特殊的称为<strong>dynamic_cast</strong>的显式类型转换（explict cast），它就是一种安全型向下类型转换（type-safe downcasting）的操作。当使用dynamic_cast来试着向下类型转换一个特定的类型，仅当类型转换是正确的并且是成功的时，返回值会是一个指向所需类型的指针，否则它将返回0来表示这并不是正确的类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">virtual</span> ~Pet()&#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Pet &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Pet &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pet* b = <span class="keyword">new</span> Cat; <span class="comment">// Upcast</span></span><br><span class="line"></span><br><span class="line">    Dog* d1 = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(b);</span><br><span class="line"></span><br><span class="line">    Cat* d2 = <span class="keyword">dynamic_cast</span>&lt;Cat*&gt;(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当使用dynamic_cast时，必须对一个真正多态的层次进行操作–它含有虚函数–这是因为dynamic_cast使用了存储在VTABLE中的信息来判断实际的类型。</strong></p>
<p>这里基类含有一个虚析构函数，这就足够了。</p>
<p>无论何时进行向下类型转换，我们都有责任进行检验以确保类型转换的返回值不为0。</p>
<p>dynamic_cast运行时需要一点额外开销；不多，但如果大量执行（程序设计有问题），就会影响性能。有时在进行向下类型转换的时候，我们知道正在处理的是何种类型，这时使用dynamic_cast产生的额外开销就没有必要，可以通过<strong>static_cast</strong>来代替它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span><span class="keyword">public</span>: <span class="keyword">virtual</span> ~Shape() &#123;&#125;;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Shape &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Other</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Circle c;</span><br><span class="line">    Shape * s =c;  <span class="comment">//Upcast: normal and ok</span></span><br><span class="line">    <span class="comment">// More explicit but unnecessary</span></span><br><span class="line">    s = <span class="keyword">static_cast</span>&lt;Shape*&gt;(&amp;c);</span><br><span class="line">    <span class="comment">// (Since upcating is such a safe and common operation, the cast becomes cluttering)</span></span><br><span class="line"></span><br><span class="line">    Circle* cp = <span class="number">0</span>;</span><br><span class="line">    Square* sp = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Static Navigation of class hierarchies requires extra type information:</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeid</span>(s) == <span class="keyword">typeid</span>(cp)) <span class="comment">//C++ RTTI</span></span><br><span class="line">        cp = <span class="keyword">static_cast</span>&lt;Circle*&gt;(s);</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">typeid</span>(s) == <span class="keyword">typeid</span>(sp)) </span><br><span class="line">        sp = <span class="keyword">static_cast</span>&lt;Circle*&gt;(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cp != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"It is a Circle"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(sp != <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"It is a Square"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Static navigation is ONLY an efficiency hack;</span></span><br><span class="line">    <span class="comment">// dynamic_cast is always safer.However:</span></span><br><span class="line">    <span class="comment">// Other* op = static_cast&lt;Other*&gt;(s);</span></span><br><span class="line">    <span class="comment">// Conveniently gives an error message,while</span></span><br><span class="line">    Other *op2 = (Other*)s;</span><br><span class="line">    <span class="comment">// does not</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RTTI允许我们得到向上类型转换时丢失的类型信息。dynamic_cast实际上就是RTTI的一种形式。这里typeid关键字（在<code>&lt;typeinfo&gt;</code>中声明）用来检测指针类型。RTTI的内容远不止typeid，我们也可以想象它能通过虚函数简单合理的实现我们自己的类型信息系统。</p>
<p>RTTI用于判定类型，static_cast用于执行向下类型转换。但要注意，这个设计中，处理效率同dynamic_cast是一样的，并且必须检测那些实际成功的类型转换。</p>
<p>如果类层次中没有虚函数（这是一个有问题的设计），或者如果有其他的需要，要求我们安全的进行向下类型转换，与使用dynamic_cast相比静态的执行向下类型转换会稍微快一点。另外，static_cast不允许类型转换到该类层次的外面，而传统的类型转换是允许的，所以他们会更安全。<strong>但是静态的浏览类层次是有风险的，所以除非特殊情况我们一般使用dynamic_cast。</strong></p>
]]></content>
      <categories>
        <category>C++编程思想</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-各种组件的学习使用</title>
    <url>/ue4-components-learning/</url>
    <content><![CDATA[<p>内容太少我决定把这篇合并一下，记录一些UE4中的插件亦或者某个组件（Component）的使用方法等等。</p>
<a id="more"></a>
<h1 id="Spline"><a href="#Spline" class="headerlink" title="Spline"></a>Spline</h1><p>偶然发现了一个很有趣的控件，<strong>Spline Component</strong>，感觉会很有用就记下来了。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=wR0fH6O9jD8" target="_blank" rel="noopener">Using Splines &amp; Spline Components | Live Training | Unreal Engine</a></li>
</ul>
<p>这是四年前的视频你敢信？！</p>
<p>记录一下这个视频里出现的常用的关于Spline的操作函数。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>1.GetNumSplinePoints</p>
<p>Store number of Spline points.</p>
<p>在Spline的Component中输入Get就能看到好多和其相关的函数。</p>
<p>2.AddSplinePoint</p>
<h2 id="Spline-Mesh"><a href="#Spline-Mesh" class="headerlink" title="Spline Mesh"></a>Spline Mesh</h2><h2 id="在C-中使用Spline"><a href="#在C-中使用Spline" class="headerlink" title="在C++中使用Spline"></a>在C++中使用Spline</h2><h3 id="从Actor中获取SplineComponent"><a href="#从Actor中获取SplineComponent" class="headerlink" title="从Actor中获取SplineComponent"></a>从Actor中获取SplineComponent</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AActor* Object;</span><br><span class="line"></span><br><span class="line">USplineComponent * comp = Object-&gt;FindComponentByClass&lt;USplineComponent&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> splineLength = comp-&gt;GetSplineLength();</span><br></pre></td></tr></table></figure>
<p>原本我是把这个Spline控件放在了一个Actor上面，然后更新DistanceAlongSpline的变量值来控制Actor在Spline上的位置，但是我却忽视了Actor移动的时候这个Spline也在移动，所以没有按照预期的进行。只有将Actor和spline分开，放到另外一个Actor上了。</p>
<h1 id="USpringArmComponent"><a href="#USpringArmComponent" class="headerlink" title="USpringArmComponent"></a>USpringArmComponent</h1><p>我只要遇见的场合就是Camera的操控，作为CameraBoom(相机臂)来使用的。</p>
<p><a href="https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/USpringArmComponent/index.html" target="_blank" rel="noopener">USpringArmComponent - This component tries to maintain its children at a fixed distance from the parent, but will retract the children if there is a collision, and spring back when there is no collision.</a></p>
<p>按照上面的描述说就是可以简单实现相机和目标之间有Collision的时候缩短相机臂，经常见到的那种效果。</p>
<p>还有一些那种相机与目标之间存在Collision或者Mesh的时候吧Mesh半透明化的使用，不知道要怎么实现。</p>
<h1 id="Gameplay-Tag"><a href="#Gameplay-Tag" class="headerlink" title="Gameplay Tag"></a>Gameplay Tag</h1><ul>
<li><a href="http://unrealengine.hatenablog.com/entry/2017/02/21/220000" target="_blank" rel="noopener">UE4 Gameplay Tagを使ってゲームプレイ時のタグ管理をより扱いやすくする</a></li>
</ul>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><ul>
<li><p><a href="http://www.aclockworkberry.com/unreal-engine-substepping/" target="_blank" rel="noopener">Everything you always wanted to know about Unreal Engine physics (but were afraid to ask)</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=zX0gilGIpRQ" target="_blank" rel="noopener">100 UE4 Tips and Tricks | Unreal Fest Europe 2019 | Unreal Engine</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-Material学习</title>
    <url>/ue4-material-shader-learning/</url>
    <content><![CDATA[<p>关于UE4中的材质，也有好多能说的，这里记录一些遇到的关于材质的知识点作为知识储备。</p>
<a id="more"></a>
<h1 id="更新履历"><a href="#更新履历" class="headerlink" title="更新履历"></a>更新履历</h1><ul>
<li>2020/01/24 添加shader部分的标题<ul>
<li>Fake ight shader</li>
</ul>
</li>
</ul>
<h1 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h1><h2 id="Material-node"><a href="#Material-node" class="headerlink" title="Material node"></a>Material node</h2><h3 id="ShadowPassSwitch"><a href="#ShadowPassSwitch" class="headerlink" title="ShadowPassSwitch"></a>ShadowPassSwitch</h3><h2 id="Material-Parameter-Collections"><a href="#Material-Parameter-Collections" class="headerlink" title="Material Parameter Collections"></a>Material Parameter Collections</h2><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/ParameterCollections" target="_blank" rel="noopener">Material Parameter Collections</a></li>
</ul>
<h1 id="材质应用"><a href="#材质应用" class="headerlink" title="材质应用"></a>材质应用</h1><ul>
<li><a href="https://aqu.hatenablog.com/entry/2018/07/09/000805" target="_blank" rel="noopener">UE4 : 水彩 Post Process Material</a></li>
</ul>
<ul>
<li><p><a href="https://www.slideshare.net/EpicGamesJapan/epic-games-japan-ue4dd" target="_blank" rel="noopener">マテリアルとマテリアルインスタンスの仕組みと問題点の共有 (Epic Games Japan: 篠山範明) #UE4DD</a></p>
</li>
<li><p><a href="https://www.slideshare.net/EpicGamesJapan/ue4-108770894" target="_blank" rel="noopener">猫でも分かるUE4のポストプロセスを使った演出・絵作り</a></p>
</li>
</ul>
<h1 id="Shader学习"><a href="#Shader学习" class="headerlink" title="Shader学习"></a>Shader学习</h1><p>在UE中也有很多Shader的知识学习，这里因为没有另起文章，而且还未整理</p>
<p><strong>Fake light shader</strong></p>
<p>在公司的学习会听到的这个名词，感觉很在意，就先记下了。<a href="https://forums.unrealengine.com/community/community-content-tools-and-tutorials/23031-fake-dynamic-lighting-material-for-mobile-devices" target="_blank" rel="noopener">Fake dynamic lighting material for mobile devices.</a></p>
<p>先记下文章的链接之后整理。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Material</tag>
        <tag>Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-Performance提升</title>
    <url>/ue4-performance/</url>
    <content><![CDATA[<p>主要记录一些能够查看UE4的性能工具和提升性能的一些手段记录。</p>
<a id="more"></a>
<p>我在知乎看见一篇文章整理的非常好：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/36434616" target="_blank" rel="noopener">Performance and Profiling(UE4优化)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/36851846" target="_blank" rel="noopener">Unreal 4 性能入门指南</a></li>
</ul>
<p>根据这个再根据自己在工作中遇到的问题进行进一步细致的总结吧。</p>
<p>发现了BasePass的消耗很高，查一下。</p>
<h1 id="1-Optimization"><a href="#1-Optimization" class="headerlink" title="1. Optimization"></a>1. Optimization</h1><p>关于一些渲染流程的说明：</p>
<ul>
<li><a href="https://www.slideshare.net/EpicGamesJapan/cedec2016-unreal-engine-4" target="_blank" rel="noopener">CEDEC2016: Unreal Engine 4 のレンダリングフロー総おさらい</a></li>
</ul>
<p>上面的文章我之前有总结过一些，但是并没有完全理解。</p>
<h2 id="1-1-Emulate-HMD-performance"><a href="#1-1-Emulate-HMD-performance" class="headerlink" title="1.1 Emulate HMD performance"></a>1.1 Emulate HMD performance</h2><p>下面有提到VRSDK的设置（v-sync）会使得帧数锁在90fps那里，如果小于90fps就会直接降到45fps，不能够正确的测试处理时间。</p>
<p>我们可以模拟VR的绘制：</p>
<ul>
<li><strong>Launch witch -emulatestereo</strong></li>
<li><strong>Set resolution 2160x1200</strong></li>
<li><strong>Set r.screenpercentage 140</strong></li>
</ul>
<p>具体的做法如下：</p>
<ol>
<li>在<em>Editor Preferences &gt; Play &gt; Play in Standalone Game &gt; Additional Launch Parameters</em>中填入 <code>-emulatestereo</code></li>
<li>Start with Standalone Mode and Set Resolution to <code>r.SetRes 2160x1200</code> or <code>r.SetRes 2160x1200f</code></li>
<li><code>r.screenpercentage 140</code></li>
</ol>
<h2 id="1-2-Ready-Profiling"><a href="#1-2-Ready-Profiling" class="headerlink" title="1.2 Ready Profiling"></a>1.2 Ready Profiling</h2><ul>
<li>Play in Standalone</li>
<li>Make sure the Editor is set to NOT update in realtime</li>
<li>Minimize the Editor</li>
<li>Make sure to turn off Frame Rate Smoothing[Project Settings]</li>
<li>Turn off VSync[r.vsync 0]</li>
</ul>
<p>使用<code>r.ScreenPercentage 10</code>命令，如果程序突然加速，说明性能瓶颈在GPU上。</p>
<p>引用来自下面的视频：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=hcxetY8g_fs" target="_blank" rel="noopener">UE4 Performance and Profiling</a></li>
</ul>
<p>关于开始优化前的准备问题，流程可以参考一下<a href="https://www.slideshare.net/EpicGamesJapan/cedec2017-ue4" target="_blank" rel="noopener">[CEDEC2017] UE4プロファイリングツール総おさらい（グラフィクス編）</a> 里面的内容。每次最好快速浏览一下。</p>
<p>然后是在准备Profile一定要先<strong>烘焙光照</strong>，要不然我真不知道在优化个什么鬼。因为在这个地方踩坑了。有位大佬在项目工程里放了一个范围超级大的<a href="https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/Lightmass/Basics/index.html" target="_blank" rel="noopener">Lightmass Importance Volume</a> 导致UE4在烘焙的时候总是让<strong>Swarm</strong>一直卡在ExportScene阶段。(这里参考了<a href="https://answers.unrealengine.com/questions/726808/why-is-swarm-taking-forever-to-export-scene.html" target="_blank" rel="noopener">Why is Swarm taking forever to export scene?</a>)</p>
<h2 id="1-3-VR-Instanced-Stereo"><a href="#1-3-VR-Instanced-Stereo" class="headerlink" title="1.3 VR Instanced Stereo"></a>1.3 VR Instanced Stereo</h2><p>这个可以在<br><strong>Edit &gt; Project Settings &gt; Rendering &gt; VR</strong></p>
<p>中开启。</p>
<p>目的是为了让双眼的画面同时渲染。减少Draw Call。</p>
<p>于是我试了试，并没有变快..反而感觉慢了，因为瓶颈本来不是CPU么。使用应该有条件的。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Platforms/VR/VRPerformance" target="_blank" rel="noopener">VR Instanced Stereo</a></li>
</ul>
<h2 id="1-4-Rendering-Pipeline"><a href="#1-4-Rendering-Pipeline" class="headerlink" title="1.4 Rendering Pipeline"></a>1.4 Rendering Pipeline</h2><p>刚刚好，趁着这个机会，顺便把渲染流程给描述出来，也就是每个阶段做了什么，既然要优化，就要知道做了设么，什么顺序做的。</p>
<p>至于流程的话参考了<a href>CEDEC2016 Unreal Engine 4 のレンダリングフロー総おさらい</a>这篇文章。</p>
<p>关于这篇文章详细的解说下面PrePass章节部分有链接。</p>
<p>这个网站相当的</p>
<ul>
<li><a href="https://unrealartoptimization.github.io/" target="_blank" rel="noopener">UNREAL ART OPTIMIZATION</a></li>
</ul>
<p>官方网站的<a href="https://docs.unrealengine.com/en-US/Engine/Performance/GPU/index.html" target="_blank" rel="noopener">GPU Profiling</a></p>
<h3 id="1-4-1-Z-PrePass"><a href="#1-4-1-Z-PrePass" class="headerlink" title="1.4.1 Z PrePass"></a>1.4.1 Z PrePass</h3><h4 id="PrePass-DDM-AllOpaque-Force-by-DBuffer"><a href="#PrePass-DDM-AllOpaque-Force-by-DBuffer" class="headerlink" title="PrePass DDM_AllOpaque(Force by DBuffer)"></a>PrePass DDM_AllOpaque(Force by DBuffer)</h4><p><del>这个PrePass是不是上面的<em>Z PrePass</em>还有待确认，因为我是在<strong>GPUProfiler</strong>中看到的这个，也许是Z PrePass的一部分。</del></p>
<p>我看到的不是单单的<strong>PrePass</strong>，而是<strong>PrePass DDM_AllOpaque(Forced by DBuffer)</strong>。</p>
<p><del>这个Pass是用来先行计算<strong>Depth-Buffer</strong>的，在BasePass把数据写G-Buffer之前，把深度通过测试的像素留下，达到减少处理的目的，但是不是一定会减少。</del></p>
<p><del>这个可以ON/OFF，也可以开启之后指定物体经不过经过该处理。</del></p>
<p><del>所以说PrePass的目的是为了减少BasePass的处理负荷。</del></p>
<p>我在项目中发现的特点是：在所有的View0/View1中的处理中，还是<strong>Dynamic</strong>的时间最长。上面也有提到当动态的顶点，skeleton动画比较多的时候就会这样，可以试试关掉PrePass或者把顶点动画的物体不经过该Pass处理会不会减轻一些负担。但是在此之前，我应该学会如何使用Profile工具。</p>
<p>我来更新了，这个地方果然是我瞎说的。之前说的都划掉，先来说前半部分。</p>
<p><strong>PrePass DDM_AllOpaque</strong>是什么？</p>
<p>在这篇文章里有简短的提到<a href="https://dawnarc.com/2018/12/ue4gpu-visualizer-gpu-profiling-specification/" target="_blank" rel="noopener">[UE4]GPU Visualizer (GPU Profiling) Specification</a>:</p>
<blockquote>
<p><strong>PrePass DDM_…</strong></p>
<p>Sense</p>
<ul>
<li>Early rendering of depth(Z) from non-translucent meshed.</li>
<li>Required by DBuffer decals.</li>
<li>May be used by occlusion culling.</li>
<li>Engine -&gt; Rendering -&gt; Optimizations -&gt; Early Z-pass.</li>
</ul>
<p>Cost affected by</p>
<ul>
<li>Triangle count of opaque objects.</li>
<li>Depending on Early Z settings: Overdraw and complexity of Masked materials.</li>
</ul>
</blockquote>
<p>好，是这个东西，但是为什么要做这个处理不知道。再来看后半部分。</p>
<p><strong>Forced by DBuffer</strong>是什么？</p>
<p>英文意思很好理解，但是<strong>DBuffer</strong>是个什么我总是找不到。最后还是在上面（或者下面？）提到的那个神一样的SlideShare的介绍文章<a href="https://www.4gamer.net/games/210/G021013/20160830082/" target="_blank" rel="noopener">［CEDEC 2016］UE4を扱うアーティストがつまづき易いポイントはここだ。Epic Gamesが解説する注意点と回避法</a>中找到了类似的定义：</p>
<blockquote>
<p>DBuffer DecalsまたはDeferred Decalとは，デカールをG-Bufferとは別の，「D-Buffer」と呼ばれるデカール専用特殊バッファに描画しておき，G-Bufferを用いてのライティングやシェーディングは，D-Bufferの内容も反映しながら行うという流れになる。デカールの描画結果がG-Bufferに統合されてしまうと，これが原因で前出のような問題が出てしまう。これを回避するために専用バッファを用意したというわけだ。</p>
</blockquote>
<blockquote>
<p>　ただ，D-Bufferの利用に加えて，描画系も今までより処理のパスが増えるため，描画負荷が高くなるのがネックといったところ。<br>　負荷は高くなるが正確なデカール表現が行えるDBuffer Decalsを導入すべきなのか。あるいは別の表現を選んでDBuffer Decalを避けるかは，よく検討して決めたほうがいいようだ。</p>
</blockquote>
<p>具体的意思要专门展开关于<strong>DBuffer Decal</strong>的文章，总而言之就是当你决定使用<strong>DBuffer Decals</strong>的时候，并在（Project Setting/Rendering/Lighting中）开启了DBuffer Decals功能时候，那么上面的<strong>PrePass DDM_AllOpaque</strong>就会被强制执行。由于某种原因（文章中表示是Pre-Lighting阶段的描画需要）后续在别的文章中展开。</p>
<p>上面关于<strong>PrePass DDM_…</strong>的内容貌似也在<a href="https://www.youtube.com/watch?v=C3lumWdwHmA&amp;list=PLF8ktr3i-U4A7vuQ6TXPr3f-bhmy6xM3S&amp;index=5" target="_blank" rel="noopener">UE4 Graphics Profiling: All Categories Guide (Rendering Passes)</a>中有提及，这是是我之前就收藏过的，但是我并没有很仔细的看。。。</p>
<p>关于<strong>Deferred Decal</strong>的讨论，本来想要在其它章节写，但是暂时先整理一下, <a href="http://monsho.blog63.fc2.com/blog-entry-139.html" target="_blank" rel="noopener">[UE4] Deferred Decal</a><br>中提到的几个设定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SystemSettings]</span><br><span class="line">r.EarlyZPassMovable=1</span><br><span class="line">r.EarlyZPass=2</span><br><span class="line">r.DBuffer=1</span><br></pre></td></tr></table></figure>
<p>我本来是想找是谁打开了DBuffer的设定，结果发现DBuffer是默认引擎开启的？！至于上面的问题，由于Dbuffer而强制计算的PrePass的操作，在我关掉DBuffer之后还是存在。</p>
<p>关于UE4中的<a href="http://www.kosmokleaner.de/ownsoft/UE4CVarBrowser.html" target="_blank" rel="noopener">Unreal Engine 4 Console Variables and Commands</a></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Help</th>
</tr>
</thead>
<tbody>
<tr>
<td>r.EarlyZPass</td>
<td>Whether to use a depth only pass to initialize Z culling for the base pass. Cannot be changed at runtime.<br>Note: also look at r.EarlyZPassMovable<br>0: off<br>1: only if not masked, and only if large on the screen<br>2: all opaque (including masked)<br>x: use built in heuristic (default is 3)</td>
</tr>
<tr>
<td>r.EarlyZPassMovable</td>
<td>Whether to render movable objects into the depth only pass. Movable objects are typically not good occluders so this defaults to off.<br>Note: also look at r.EarlyZPass</td>
</tr>
<tr>
<td>r.DBuffer</td>
<td>Enables DBuffer decal material blend modes.<br>DBuffer decals are rendered before the base pass, allowing them to affect static lighting and skylighting correctly.<br>When enabled, a full prepass will be forced which adds CPU / GPU cost. Several texture lookups will be done in the base pass to fetch the decal properties, which adds pixel work.<br>0: off<br>1: on (default)</td>
</tr>
</tbody>
</table>
<p>这里插播一条<a href="https://answers.unrealengine.com/questions/154220/decal-performance-question.html" target="_blank" rel="noopener">Decal performance question</a>：</p>
<blockquote>
<p>This is from the docs:</p>
<p>Performance</p>
<p>The mesh complexity of the objects affected by the decal is not affecting the performance. The decal performance depends on the shader complexity and the shader box size on the screen.</p>
<p>We can further improve the per decal performance. Ideally the bounding box of the decal is small to get better per pixel performance. This can be done manually. An automated method is possible but a good designer can also adjust the placement to improve performance further.</p>
<p>Current limitations</p>
<p>We currently only support deferred decals and they only work on static objects. Normal blending is currently not wrapping around the object. Mip map computation is not done yet so you might see 2x2 block artifacts on object borders. Streaming is not yet hooked up so make sure the texture is not streamed. Masking decals (not affecting other object) is not fully implemented.</p>
</blockquote>
<h3 id="1-4-3-Base-Pass"><a href="#1-4-3-Base-Pass" class="headerlink" title="1.4.3 Base Pass"></a>1.4.3 Base Pass</h3><p>关于base pass的总结：</p>
<ul>
<li><p><a href="https://unrealartoptimization.github.io/book/profiling/passes-base/" target="_blank" rel="noopener">UNREAL ART OPTIMIZATION - Base Pass</a></p>
<p>  <strong>Responsible for</strong></p>
<pre><code>• Rendering final attributes of Opaque or Masked materials to the G-Buffer

• Reading static lighting and saving it to G-Buffer

• Applying DBuffer decals

• Applying fog

• Calculating final velocity (from packed 3D velocity)

• In forward renderer: dynamic lighting
</code></pre><p>  <strong>Cost affected for</strong></p>
<pre><code>• Rendering resolution

• Shader complexity

• Number of objects

• Number of decals

• Triangle count
</code></pre></li>
</ul>
<p>在basepass阶段做了许多工作，其中<strong>Shader Complexity</strong> 是影响性能的一个很重要的因素。</p>
<h4 id="1-4-3-1-Optimization"><a href="#1-4-3-1-Optimization" class="headerlink" title="1.4.3.1 Optimization"></a>1.4.3.1 Optimization</h4><p>如何优化这个问题首先要知道那个地方需要优化。</p>
<ul>
<li>Shader Complexity: 在view-mode下可以查看shader的复杂度。</li>
<li>Stat: 在Material Editor里面有stat window查看pass的数量</li>
<li>Rendering Resolution: 可以查看和影响G-Buffer和其他贴图的质量。<ul>
<li><code>stat RHI</code>: 查看G-Buffer的内存占用</li>
</ul>
</li>
</ul>
<p>英文文章读起来不如中文的快，那么容易理解，但是有些话翻译成中文的话不知道为什么就变了味道。还是多读几遍人家的文章吧。</p>
<h4 id="1-4-3-2-GPU-Visualizer"><a href="#1-4-3-2-GPU-Visualizer" class="headerlink" title="1.4.3.2 GPU Visualizer"></a>1.4.3.2 GPU Visualizer</h4><h5 id="BasePass-Dynamic"><a href="#BasePass-Dynamic" class="headerlink" title="BasePass-Dynamic"></a>BasePass-Dynamic</h5><blockquote>
<p> <span style="color:red">BasePass 0 = Opaque Meshes.</span></p>
</blockquote>
<blockquote>
<p> <span style="color:red">BasePass 1 = Alpha Masked Opaque Meshes for Z-depth.</span></p>
</blockquote>
<blockquote>
<p> <span style="color:red">BasePass Dynamic = Animated Vertices such as Skeletal, GeoCache(Alembic),etc.</span></p>
</blockquote>
<p>在上面我只看到了<strong>Dynamic</strong>，而其他的是<strong>Static EBassPassDrawListType=0</strong>和<strong>Static EBasePassDrawListType=1</strong>意思是不是一样的我也不确定。</p>
<p>于是我查了查<strong>EBasePassDrawListType</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Source UnrealEngine4源码：Runtime\Render\Private\BasePassRendering.cpp</span></span><br><span class="line">EBasePassDrawListType DrawType = EBasePass_Default;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The definition of the type</span></span><br><span class="line"><span class="keyword">enum</span> EBasePassDrawListType</span><br><span class="line">&#123;</span><br><span class="line">    EBasePass_Default = <span class="number">0</span>,</span><br><span class="line">    EBasePass_Masked,</span><br><span class="line">    EBasePass_MAX</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看这个声明貌似上面的是对的。</p>
<p>还有一个我有点在意的是在VR的模式下会出现两种</p>
<ul>
<li>View0</li>
<li>View1</li>
</ul>
<p>VR眼镜不是有两个镜片么，就对应了两个摄像机。</p>
<p>所以<strong>Dynamic</strong>处理占用时间，是因为<strong>顶点动画</strong>比较多。</p>
<h3 id="1-4-4-Pre-Lighting"><a href="#1-4-4-Pre-Lighting" class="headerlink" title="1.4.4 Pre-Lighting"></a>1.4.4 Pre-Lighting</h3><h3 id="1-4-5-Lighting"><a href="#1-4-5-Lighting" class="headerlink" title="1.4.5 Lighting"></a>1.4.5 Lighting</h3><ul>
<li><a href="https://unrealartoptimization.github.io/book/profiling/passes-lighting/" target="_blank" rel="noopener">Lighting Passes</a></li>
</ul>
<h4 id="Unwrapping-UVs-for-Lightmaps"><a href="#Unwrapping-UVs-for-Lightmaps" class="headerlink" title="Unwrapping UVs for Lightmaps"></a>Unwrapping UVs for Lightmaps</h4><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Content/Types/StaticMeshes/LightmapUnwrapping/index.html" target="_blank" rel="noopener">UNREAL ENGINE - Unwrapping UVs for Lightmaps</a></li>
</ul>
<h4 id="1-4-5-1-GPU-Visualizer"><a href="#1-4-5-1-GPU-Visualizer" class="headerlink" title="1.4.5.1 GPU Visualizer"></a>1.4.5.1 GPU Visualizer</h4><p>这个是在<strong>ProfileGPU</strong>命令中出现的GPU Visualizer视图中的光照部分GPU消耗情况。</p>
<p>这里需要澄清的是，我按照渲染流程顺序题的标题，但是这个GPU Visualizer中的内容未必就是这个阶段做的事情，也许的确是这个阶段做的，但是我不知道。我只是看见名字相同，就整理到一起罢了。</p>
<p>层级关系：</p>
<ul>
<li>Lights<ul>
<li>DirectLighting<ul>
<li>NonShadowLightings</li>
<li>IndirectLighting</li>
<li>ShadowLights</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>大致上是这样的。</p>
<h5 id="ShadowLights-gt-…-gt-ShadowProjectionOnOpaque"><a href="#ShadowLights-gt-…-gt-ShadowProjectionOnOpaque" class="headerlink" title="ShadowLights -&gt; … -&gt; ShadowProjectionOnOpaque"></a>ShadowLights -&gt; … -&gt; ShadowProjectionOnOpaque</h5><p>这个项目下处理占用了好多的时间。这是在一个Stationary类型的Spot光源下，产生的大量的计算。关键字有<em>PerObject</em>和<em>PerShadow</em>。</p>
<p>一个Spot光源的出现在直射光的项目下面我就已经很吃惊了。顾名思义，这应该是阴影投影在不透明物体上的处理。当然直射光被设置为StationaryLight，需要动，所以每一帧更新都要重新计算阴影位置。</p>
<h3 id="1-4-6-Reflection"><a href="#1-4-6-Reflection" class="headerlink" title="1.4.6 Reflection"></a>1.4.6 Reflection</h3><ul>
<li><a href="https://docs.unrealengine.com/en-US/Resources/Showcases/Reflections/index.html" target="_blank" rel="noopener">UNREAL ENGINE - Reflections</a></li>
</ul>
<h4 id="Reflection-Environment"><a href="#Reflection-Environment" class="headerlink" title="Reflection Environment"></a>Reflection Environment</h4><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/ReflectionEnvironment/index.html" target="_blank" rel="noopener">UNIREAL ENGINE - Reflection Environment</a></li>
</ul>
<h4 id="Planar-Reflection"><a href="#Planar-Reflection" class="headerlink" title="Planar Reflection"></a>Planar Reflection</h4><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/PlanarReflections/index.html" target="_blank" rel="noopener">UNREAL ENGINE - Planar Reflection</a></li>
</ul>
<h3 id="1-4-7-Translucency"><a href="#1-4-7-Translucency" class="headerlink" title="1.4.7 Translucency"></a>1.4.7 Translucency</h3><p>按照处理顺序的话透明处理绝对不是那么靠前，之后应该调整一下顺序。</p>
<h4 id="Separate-Translucency"><a href="#Separate-Translucency" class="headerlink" title="Separate Translucency"></a>Separate Translucency</h4><p>把半透明的处理写到其他的Buffer中。</p>
<p><strong>Project Settings &gt; Engine &gt; Rendering &gt; Translucency</strong></p>
<p>我似乎有看过一点这方面的文章。</p>
<ul>
<li><code>r.SeparateTranslucencyScreenPercentage XX</code>: 指定该buffer的解像度</li>
<li><code>r.SeparateTranslucencyAutoDownsample</code>: 自动降低解像度</li>
</ul>
<h3 id="1-4-8-PostProcess"><a href="#1-4-8-PostProcess" class="headerlink" title="1.4.8 PostProcess"></a>1.4.8 PostProcess</h3><h3 id="1-4-9-Shadow"><a href="#1-4-9-Shadow" class="headerlink" title="1.4.9 Shadow"></a>1.4.9 Shadow</h3><p>阴影这一部分的内容有很多，顺序也需要之后调整。</p>
<h4 id="Fake-Shadow"><a href="#Fake-Shadow" class="headerlink" title="Fake Shadow"></a>Fake Shadow</h4><p>多在角色模型中使用，比如人物脚下一团黑影代表着阴影那样。</p>
<h4 id="Capsule-Shadow"><a href="#Capsule-Shadow" class="headerlink" title="Capsule Shadow"></a>Capsule Shadow</h4><ul>
<li>SkeletalMesh: Capsule Direct(Indirect) Shadow 等等</li>
</ul>
<h2 id="1-5-Command-Introduction"><a href="#1-5-Command-Introduction" class="headerlink" title="1.5 Command Introduction"></a>1.5 Command Introduction</h2><p>记录一些常用的命令和里面的参数解读。</p>
<h3 id="stat-SceneRendering"><a href="#stat-SceneRendering" class="headerlink" title="stat SceneRendering"></a>stat SceneRendering</h3><h4 id="RenderQueryResult"><a href="#RenderQueryResult" class="headerlink" title="RenderQueryResult"></a>RenderQueryResult</h4><p>关于这个参数，我也不太完全确定，在网上搜了也没有什么具体的答案。搜来搜去看到了<strong>OcclusionCulling</strong>感觉很像，但是按照这个方向去优化了一下试了试并不是很理想，貌似不是并不是一个概念，而且OcclusionCulling这个参数在另外一个命令，貌似是<em>stat InitView</em>中有貌似。</p>
<p>看到有人理解的是：</p>
<p><strong>RenderQueryResult是GPU完成整个一帧的渲染最后要做的事情。这个条目耗费时间很长说明GPU在这一帧内没有空闲，一直在工作。</strong></p>
<p>感觉还说的过去。</p>
<h1 id="2-Bluerint优化"><a href="#2-Bluerint优化" class="headerlink" title="2. Bluerint优化"></a>2. Bluerint优化</h1><p>像Blueprint和C++是由CPU处理的<strong>Game</strong>阶段的处理。</p>
<h2 id="Tick-Event"><a href="#Tick-Event" class="headerlink" title="Tick Event"></a>Tick Event</h2><p>如果不需要的话，将Actor中的Tick Enable 设置为Off。亦或者调整Tick Interval的数值减少每一帧的调用。</p>
<h2 id="Spawn"><a href="#Spawn" class="headerlink" title="Spawn"></a>Spawn</h2><p>Spawn处理不一定非要在一帧之内完成，可以分散到下下帧，由于间隔时间很短所以不会暴露什么。</p>
<p>但是分帧完成一个动作我还没见过这种操作，之后有时间找找看吧。</p>
<h2 id="Nativizing-Blueprint"><a href="#Nativizing-Blueprint" class="headerlink" title="Nativizing Blueprint"></a>Nativizing Blueprint</h2><p>这个我也不太懂，真要用的时候再看吧。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Blueprints/TechnicalGuide/NativizingBlueprints" target="_blank" rel="noopener">Nativizing Blueprint</a></li>
</ul>
<h1 id="3-Landscape-Optimization"><a href="#3-Landscape-Optimization" class="headerlink" title="3. Landscape Optimization"></a>3. Landscape Optimization</h1><p>自作大型的场景的时候就会用到Landscape，但是问题是在Statistics中查看的结果，这个东西的无论是顶点数还是资源大小还是光照贴图的大小都是场景里耗费最高的。</p>
<p>关于Landscape的制作也不是随意的。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=OWOlYoI-3tY" target="_blank" rel="noopener">Introduction to Landscapes - #6 Unreal Engine 4 Level Design Tutorial Series</a></li>
</ul>
<p>这个视频涉及到了如何合理的制作Landscape，还有其他的系列视频关于如何使用Landscape的工具的。</p>
<p>再就是官方文档了：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/Landscape/TechnicalGuide" target="_blank" rel="noopener">Landscape Technical Guide</a></li>
</ul>
<p>解释了各种参数的意义和推荐设置。</p>
<p>还有就是一些具体细节的调整：</p>
<ol>
<li>Navigation不用的话关掉</li>
<li>Collision不用的话关掉</li>
<li>LOD设置调低</li>
</ol>
<h1 id="4-HTC-Vive"><a href="#4-HTC-Vive" class="headerlink" title="4. HTC Vive"></a>4. HTC Vive</h1><p><strong>Vive的刷新率只有90Hz。</strong></p>
<p>这是什么概念？每秒刷新90帧的能力，这跟游戏能够达到的帧率有很大不同。</p>
<ol>
<li>这里就有疑问了，如果游戏的帧率高于显示器（VR）的刷新率会怎么样。</li>
</ol>
<p><span style="color:red"><strong>会造成撕裂(tearing)。</strong></span></p>
<p>GPU活儿干多了，比如说应该把一帧的图像交给显示器，结果交付了一帧还多的数据（显示器来取数据的速度慢了一拍，本应该取走的一帧数据被显卡二次更新中途，）。产生了画面撕裂。</p>
<p><strong>V-Sync</strong>被用来解决这个问题，垂直同步(Vertical Synchronization)通过建立一个不让在显示器刷新前将后备缓冲中的画面拷贝到显示缓冲中的规定来解决这个问(有条件的双倍缓冲)。如果FPS高于刷新率的话没有问题，后备缓冲的更新完成后，系统处于等待状态。当显示器刷新后，后备缓存拷入显示缓存，显卡则可以在后备缓存中描画新的画面。</p>
<ol start="2">
<li>游戏的帧率低于显示器（VR）的刷新率会怎样</li>
</ol>
<p>如果打开了垂直同步，那么帧数直接减半。理论上讲，双缓冲的VSync，FPS将是一组不连续的整数，其等于<strong>刷新率/n</strong>。</p>
<p>这就是为什么我总是看Vive的帧率被锁在45帧的原因。</p>
<p>那么进入正题，UE4中的<strong>Smoothed Frame Rate Range</strong>有什么用。</p>
<h2 id="Smoothed-Frame-Rate-Range"><a href="#Smoothed-Frame-Rate-Range" class="headerlink" title="Smoothed Frame Rate Range"></a>Smoothed Frame Rate Range</h2><ul>
<li><a href="https://answers.unrealengine.com/questions/90743/what-exactly-does-smooth-frame-rate-do.html" target="_blank" rel="noopener">What exactly does “Smooth Frame Rate” do?</a></li>
</ul>
<blockquote>
<p><strong>With Frame Rate Smoothing, the application is determining what range is acceptable for frame rate wandering,so you can cap your frame rate to between Min and Max allowable frame rates.Since this is application based,it will make these changes before any hardware vsync changes.</strong></p>
</blockquote>
<p>举例来说，如果设置了Max60f，Min40f的话，当超过60帧会保持在60帧，当低于60帧而高于40帧的时候会保持帧数，但是低于40帧的时候就会降到30帧。</p>
<p>得益于现在的显卡很多具有自适应的垂直同步功能。</p>
<p>当然上面的内容只是我看文章得到的，并没有实际试验过。</p>
<p>然后吧，我读到了一篇文章。</p>
<ul>
<li><a href="https://software.intel.com/zh-cn/articles/cpu-performance-optimization-and-differentiation-for-unreal-engine-4-vr-application-part1" target="_blank" rel="noopener">Unreal* Engine 4 VR应用的CPU性能优化和差异化：第一部分</a></li>
</ul>
<p>这里面提到了<strong>另外，因为VR是强制开启垂直同步的，所以只要一帧的渲染时间超过11.1ms，即使只超过0.1ms，也会导致一帧需要花两个完整的垂直同步周期完成，使得VR应用很容易因为场景稍微改变而出现性能大降的情形。这时候可以用“–emulatestereo”指令，同时把分辨率(resolution)设为2160x1200，屏幕百分比(screenpercentage)设为140，就可以在没有接VR头显及关闭垂直同步的情况下分析性能。</strong></p>
<p>好的。</p>
<h1 id="5-UE4中的一些概念"><a href="#5-UE4中的一些概念" class="headerlink" title="5. UE4中的一些概念"></a>5. UE4中的一些概念</h1><h2 id="Instanced-Static-Mesh"><a href="#Instanced-Static-Mesh" class="headerlink" title="Instanced Static Mesh"></a>Instanced Static Mesh</h2><p>关于这个东西，我纠结了好久。我是从<strong>foliage</strong>这个东西接触到它的。因为foliage刷出来的东西就是这个类型，生成一些随机的树啊花啊草啊就很方便，但是同时带来了性能消耗。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/Foliage" target="_blank" rel="noopener">Foliage Instanced Meshes</a></li>
</ul>
<p>为什么说带来了性能消耗呢，其实除了方便之外还有其他的好处。</p>
<ul>
<li>减少了<strong>Draw Call</strong></li>
</ul>
<p>据我的理解：<strong>一个Actor的渲染对于CPU来说就得生成一个draw call</strong>，所以庞大的Actor的数量会拖CPU的后腿，减少draw call是优化性能的方向之一。</p>
<p>但是与此同时，一个draw call的数据不充分就导致GPU做额外的工作。也就是我遇见的InstancedStaticMesh这个东西产生的影响。</p>
<h3 id="剔除"><a href="#剔除" class="headerlink" title="剔除"></a>剔除</h3><p>有两种剔除方式：</p>
<ul>
<li>Frustum Culling</li>
<li>Occlusion Culling</li>
</ul>
<p>对于InstancedStaticMesh来说，第一种视椎体剔除是可以降看不见的部分剔除的。而第二种遮挡剔除，对于它来说就完全不起作用了，反而加重了GPU的负担。</p>
<p>我这么认为的证据是，在我分析一个用满是foliage制作的大场景中，我试着：</p>
<ol>
<li>ToggleDebugCamera: 命令行打开Debug摄像机，找到想要看的位置</li>
<li>FreezeRendering:</li>
</ol>
<p>我忘记上面的命令是在哪里看到的了，在我暂停了渲染之后移动摄影机之后发现，在摄像机之外的内容被剔除掉但是在摄像机之内的所有InstancedStaticMash都还在。即下面的文章中提到的：</p>
<ul>
<li><a href="https://software.intel.com/en-us/articles/unreal-engine-4-optimization-tutorial-part-2" target="_blank" rel="noopener">Unreal* Engine 4 Optimization Tutorial, Part 2</a></li>
</ul>
<blockquote>
<p>One thing to know about instanced static meshes is that if any part of the mesh is rendered, the whole of the collection is rendered. This wastes potential throughput if any part is drawn off camera. It’s recommended to keep a single set of instanced meshes in a smaller area; for example, a pile of stone or trash bags, a stack of boxes, and distant modular buildings.</p>
</blockquote>
<p>如果将Foliage的部分做的很大，那么所有的内容都会被渲染，哪怕是一小部分进到了摄像机的视野里。</p>
<p>还要一种方式是在Editor中，不是运行的状态，输入命令：</p>
<ul>
<li>r.VisualOccludedPrimitives</li>
</ul>
<p>可以实时的查看被遮挡的物体的轮廓，上面的例子中，并看不见InstancedStaticMesh被遮挡的轮廓，因为他们是一体的，只要一部分出现在了视野里就会被渲染。</p>
<p>这里我突然就产生了对<em>遮挡</em>这个功能的疑惑，遮挡剔除这个部分对Instanced类型的物体做的不是很好，或者说是根本无能为力。按照我之前的理解，对看不见的片元，CPU和GPU不会去渲染才对，但是结果是，遇见这种类型的，都会被渲染，看不见的片元被渲染浪费了大量的GPU的能力和处理时间。<strong>GPU并没有认为这是一个物体，把出现在视野内的片元渲染，看不见的片元舍弃，而是全部听从了CPU的命令进行全部的渲染。</strong></p>
<p>这个是我之前的理解。</p>
<p>但是对于视野内的物体，遮挡剔除就完美的降被遮挡的非Instanced物体给剔除掉了，这是事实。</p>
<p><strong>遮挡剔除究竟是CPU的工作还是GPU的工作？</strong></p>
<h3 id="关于OcclusionCulling的一些问题"><a href="#关于OcclusionCulling的一些问题" class="headerlink" title="关于OcclusionCulling的一些问题"></a>关于OcclusionCulling的一些问题</h3><ul>
<li><a href="http://darakemonodarake.hatenablog.jp/entry/20181204-01-OcclusionCulling" target="_blank" rel="noopener">UE4のOcclusion Cullingで良く聞かれる質問1: Occlusion Culling自身の処理負荷を減らしたい - だらけ者だらけ</a></li>
<li><a href="http://darakemonodarake.hatenablog.jp/entry/20181204-02-OcclusionCulling" target="_blank" rel="noopener">UE4のOcclusion Cullingで良く聞かれる質問2 Occlusion Cullingによりオブジェクトが1フレーム消失することがある - だらけ者だらけ</a></li>
</ul>
<p>上面是关于遮挡剔除的一些问题的文章。重点是在第二篇。</p>
<p>这里提到了一些遮挡剔除的特性：</p>
<p>当摄像机的移动超过了一定的阈值OcclusionCulling就会Off</p>
<ul>
<li><code>CameraRotaionThreshold(Default 45.0)</code></li>
<li><code>CameraTranslationThreshold(Default 1000)</code></li>
</ul>
<p>另外，<code>r.AllowOcclusionQueries</code> 的ON/OFF 可以手动切换。</p>
<p>也可以通过扩大Occlusion的Bound来提前渲染object</p>
<ul>
<li><code>OCCLUSIN_SLOP</code></li>
<li><code>r.ExpandAllOcclusionTestedBBoxedAmount</code></li>
</ul>
<p>进入摄像机视野的一瞬间扩大OcclusionBound：</p>
<ul>
<li><code>r.ExpandNewlyOcclusionTestedBBoxsAmount(Default=0.0f)</code></li>
</ul>
<h3 id="简单的Profiling"><a href="#简单的Profiling" class="headerlink" title="简单的Profiling"></a>简单的Profiling</h3><ul>
<li>stat SceneRendering</li>
<li>stat InitView</li>
<li>Stat SceneUpdate</li>
</ul>
<p>命令应该别的地方有讲过。但是这里我注意到的是在<code>stat InitView</code>命令里，有一个处理占了我很多时间</p>
<h3 id="Render-Query-Result"><a href="#Render-Query-Result" class="headerlink" title="Render Query Result"></a>Render Query Result</h3><p>查了也不是很明白</p>
<blockquote>
<p>RenderQuery Result is when the render thread stalls waiting for the GPU to finish the Occlusion Query, and return the results to the render thread, so that it knows what to render.</p>
</blockquote>
<blockquote>
<p>At the same time, the game thread is stalled waiting for the render thread.</p>
</blockquote>
<blockquote>
<p>This can be turned on or off with the console command</p>
</blockquote>
<blockquote>
<p>r.AllowOcclusionQueries</p>
</blockquote>
<blockquote>
<p>0 - off 1 - on</p>
</blockquote>
<p>看了也不太懂系列。</p>
<p>什么是<strong>Occlusion Query</strong>?</p>
<ul>
<li><a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch29.html" target="_blank" rel="noopener">GPU Gems- Chapter 29. Efficient Occlusion Culling</a></li>
</ul>
<p>我下了PDF，可以看。</p>
<h3 id="如何正确的使用"><a href="#如何正确的使用" class="headerlink" title="如何正确的使用"></a>如何正确的使用</h3><ul>
<li><a href="https://www.youtube.com/watch?v=oMIbV2rQO4k" target="_blank" rel="noopener">UE4 Optimization : Instancing</a></li>
</ul>
<p>我觉得这个人的每个视频都值得我刷几遍。</p>
<h3 id="Culling-Distance"><a href="#Culling-Distance" class="headerlink" title="Culling Distance"></a>Culling Distance</h3><ol>
<li>Foliage Culling Distance</li>
<li>Culling Distance Volumn</li>
</ol>
<h1 id="UE4-Performance-and-Profiling"><a href="#UE4-Performance-and-Profiling" class="headerlink" title="UE4 Performance and Profiling"></a>UE4 Performance and Profiling</h1><p>实际上准确的标题名字应该是</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=hcxetY8g_fs" target="_blank" rel="noopener">UE4 Performance and Profiling | Unreal Dev Day Montreal 2017 | Unreal Engine</a></li>
</ul>
<p>这其实是一个视频，我尝试的边看边做笔记，结果足足整理了三页，虽然是就是抄的英文，等之后有时间再记录下来吧。</p>
<p>现在要将这些内容整理一下，同时也温习一下视频的内容。</p>
<h2 id="1-CPU-GPU-Profiler"><a href="#1-CPU-GPU-Profiler" class="headerlink" title="1.CPU/GPU Profiler"></a>1.CPU/GPU Profiler</h2><p>我觉得有必要区分这两种Profiler，因为我最近接触的总是GPUProfiler，搞得我都不知道CPU要怎么Profiling了。</p>
<h2 id="2-Profiling-in-a-Build"><a href="#2-Profiling-in-a-Build" class="headerlink" title="2.Profiling in a Build"></a>2.Profiling in a Build</h2><p>算是准备优化之前的准备工作吧。</p>
<ol>
<li><p>Minimize the noise that can interface with profiling</p>
<ul>
<li>Turn off everything you are not using</li>
<li>Turn off v-sync <code>r.vsync 0</code></li>
</ul>
</li>
<li><p>Turn off Framerate Smoothing</p>
</li>
<li><p>Make a Test build</p>
<ul>
<li>Testing in a Development build inflates the Draw thread with noise</li>
</ul>
</li>
</ol>
<p>尽可能的关闭噪声（noise），前两项是必须要做的，但是第三项，我也不太清楚我理解对不对，开发的时候使用的是<strong>Development mode</strong>，所以尽可能的减少噪音就直接build工程（即<strong>Shipping mode</strong>）来optimization。</p>
<p>但是吧，还能不能用<em>stat</em>一类的命令来debug了我还真没试过。</p>
<h2 id="3-Profiling-from-within-the-Editor"><a href="#3-Profiling-from-within-the-Editor" class="headerlink" title="3.Profiling from within the Editor"></a>3.Profiling from within the Editor</h2><p>可能就是上面的补充吧，其实我也是这么做的。在Editor中Optimization肯定会有noise。</p>
<p>前面也有提到具体怎么做(虽然是VR的，但是应该都一样)这里就简单抄一下。</p>
<ol>
<li>Play in Standalone</li>
<li>Make sure the Editor is set to NOT update i realtime</li>
<li><p>Minimize the Editor</p>
<ul>
<li>VR &gt; Editor Preference &gt; Play &gt; should minimize Editor on VRPIE</li>
</ul>
</li>
<li><p>Make sure to turn off Frame Rate Smoothing</p>
</li>
<li>Turn off VSync</li>
</ol>
<h2 id="4-General-Process"><a href="#4-General-Process" class="headerlink" title="4.General Process"></a>4.General Process</h2><ol>
<li><p>Identify the bottleneck</p>
<ul>
<li>Game Thread</li>
<li><p>Render Thread</p>
<ul>
<li>CPU</li>
<li>GPU</li>
</ul>
</li>
<li><p>Often jumps back and forth as you optimize</p>
</li>
<li>Use <code>r.ScreenPercentage 10</code> to quickly check if you are GPU bound</li>
</ul>
</li>
</ol>
<p>最后一条很有用。</p>
<h3 id="Game-Thread"><a href="#Game-Thread" class="headerlink" title="Game Thread"></a>Game Thread</h3><ul>
<li>Code or Blueprint</li>
</ul>
<h3 id="CPU-Render"><a href="#CPU-Render" class="headerlink" title="CPU Render"></a>CPU Render</h3><ul>
<li>Object count,draw calls,culling</li>
</ul>
<h3 id="GPU-Render"><a href="#GPU-Render" class="headerlink" title="GPU Render"></a>GPU Render</h3><ul>
<li>Shaders, overdraw,light</li>
</ul>
<h2 id="5-Measuring-in-Milliseconds"><a href="#5-Measuring-in-Milliseconds" class="headerlink" title="5.Measuring in Milliseconds"></a>5.Measuring in Milliseconds</h2><ul>
<li><p>Use <em><span style="color:green">stat unit</span></em>,not just <em><span style="color:green">stat fps</span></em></p>
<ul>
<li>Largest number shows you the likely bottleneck</li>
</ul>
</li>
<li><p>Milliseconds per frame</p>
<ul>
<li><span style="color:grey">Frame:</span> total time to finish each frame</li>
<li><span style="color:red">Game:</span> C++ or BP gameplay operations</li>
<li><span style="color:blue">Draw:</span> CPU render time</li>
<li><span style="color:purple">GPU:</span> GPU render time</li>
</ul>
</li>
<li>You can also use <em><span style="color:green">stat unitGraph</span></em>,whitch shows a line graph playback.<ul>
<li>Mostly useful for spotting repeating hitches</li>
</ul>
</li>
</ul>
<h3 id="ScreenPercentage"><a href="#ScreenPercentage" class="headerlink" title="ScreenPercentage"></a>ScreenPercentage</h3><p>前面有提到使用这个命令来模拟VR的性能，还有就是使用这个命令来快速确认游戏的性能瓶颈是不是GPU。</p>
<ul>
<li>Mostly useful to measure problems unrelated to Game Thread</li>
<li>Use <em>stat unit</em> to show milliseconds</li>
<li>Use <em><span style="color:green">r.ScreenPercentage 10</span></em><ul>
<li>Or any number smaller than 100</li>
<li>Reduces number od pixels sent to the GPU</li>
<li>If things get faster,you were GPU bound</li>
<li>If they dont get faster,you were CPU bound</li>
</ul>
</li>
</ul>
<h2 id="6-Show-Flags"><a href="#6-Show-Flags" class="headerlink" title="6.Show Flags"></a>6.Show Flags</h2><p>One of the simplest ways to look for problems is to turn off partsof your scene.</p>
<p>Helps know when to look into reducing</p>
<ul>
<li>LODs</li>
<li>Less translucency</li>
<li>Adjust lighting</li>
</ul>
<p><em><span style="color:green">show assetType</span></em> or <em><span style="color:green">showFlag.assetType 0-1</span></em></p>
<ul>
<li>Staticmeshes</li>
<li>Skeletalmeshes</li>
<li>Particles</li>
<li>Lighting</li>
<li>Transluncency</li>
<li>Reflectionenvironment</li>
<li>Many more listed in docs</li>
</ul>
<h2 id="7-Diagnostic-Tools-Realtime-stats-and-view-modes"><a href="#7-Diagnostic-Tools-Realtime-stats-and-view-modes" class="headerlink" title="7.Diagnostic Tools-Realtime stats and view modes"></a>7.Diagnostic Tools-Realtime stats and view modes</h2><h3 id="Stat-commands"><a href="#Stat-commands" class="headerlink" title="Stat commands"></a>Stat commands</h3><ul>
<li><em><span style="color:green">stat fps</span></em></li>
<li><em><span style="color:green">stat unit</span></em></li>
<li><em><span style="color:green">stat scenerendering</span></em></li>
<li><em><span style="color:green">stat gpu</span></em></li>
<li><em><span style="color:green">stat engine</span></em></li>
<li><em><span style="color:green">stat streaming</span></em></li>
<li><em><span style="color:green">stat emitters</span></em></li>
<li><em><span style="color:green">stat lighting</span></em></li>
</ul>
<p><span style="color:green"></span></p>
<h4 id="Stat-SceneRendering"><a href="#Stat-SceneRendering" class="headerlink" title="Stat SceneRendering"></a>Stat SceneRendering</h4><ul>
<li><p>Only place to see draw calls</p>
<ul>
<li>Draw call is a single request to GPU to draw something</li>
<li>Prime candidate for CPU slowdown on lower-end machines and also on mobile(less of a concern with Metal and Vulkan)</li>
</ul>
</li>
<li><p>Also good palce to see time for:</p>
<ul>
<li>Shadows</li>
<li>Decals</li>
<li>Post Processing</li>
<li>Lighting</li>
</ul>
</li>
</ul>
<p>这个命令挺重要的。</p>
<h4 id="Stat-GPU"><a href="#Stat-GPU" class="headerlink" title="Stat GPU"></a>Stat GPU</h4><ul>
<li>Relatively new 4.15</li>
<li>Realtime readout from GPU</li>
<li><p>Gives highlights, but not details</p>
<ul>
<li>Makes i very good to quickly target trouble spots</li>
</ul>
</li>
<li><p>Use the full GPU profiler if you want to target individual things</p>
<ul>
<li>Example:if you want to find specific lights that are casting shadows</li>
</ul>
</li>
</ul>
<h3 id="Optimization-View-Modes"><a href="#Optimization-View-Modes" class="headerlink" title="Optimization View Modes"></a>Optimization View Modes</h3><h4 id="Shader-Complexity"><a href="#Shader-Complexity" class="headerlink" title="Shader Complexity"></a>Shader Complexity</h4><ul>
<li>Show how much your shhaders are costing on the GPU</li>
<li><p>Good way to see overdraw issues</p>
<ul>
<li>Overdraw is when a pixel must be drawn multiple times</li>
<li>One of the most common content issues for optimization</li>
</ul>
</li>
<li><p>Graph at the bottom shows where the pixel and vertex shaders are in terms of performance</p>
</li>
<li>If you see a lot of red and white,reconsider your approach</li>
</ul>
<p>下面的话来自于官方文档里的</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/UI/LevelEditor/Viewports/ViewModes" target="_blank" rel="noopener">View Modes</a></li>
</ul>
<blockquote>
<p>Shader Complixty Mode is used to visualize the number of shader instructions being used t calculate each pixel ofour scene.It i a generally a good indicating of how performance-friendly your scene will be. In general, it is used to test overall performance for your base scene, as well as to optimize particle effects, which tend to cause performance spikes with a large amount of overdraw for a short period of time.</p>
</blockquote>
<h4 id="Quad-Overdraw"><a href="#Quad-Overdraw" class="headerlink" title="Quad Overdraw"></a>Quad Overdraw</h4><ul>
<li>Helps show how you are using your polygon count on the screen</li>
<li><p>Can help show where meshes should be LOD-ed down</p>
<ul>
<li>Too much green shows areas that should be simplified</li>
<li>Anything more than green is starting to get costly, commonly translucency overdraw</li>
</ul>
</li>
<li><p>Very useful for MSAA on Forward Rendering,as the number of poly edges dramatically affects performance</p>
</li>
</ul>
<h4 id="Quad-Overdraw-in-depth"><a href="#Quad-Overdraw-in-depth" class="headerlink" title="Quad Overdraw in-depth"></a>Quad Overdraw in-depth</h4><ul>
<li><p>Your GPU breaks the view up into quads</p>
<ul>
<li>2*2 groups of pixels</li>
<li>This is more efficient than performing all operations on all pixels</li>
</ul>
</li>
<li><p>Very small, or very long, thin geometry wastes pixels</p>
<ul>
<li>Regular, large polygons make the best use of pixel quads, best use of GPU</li>
</ul>
</li>
<li><p>Model with regular trangles and LDD aggressively</p>
</li>
</ul>
<blockquote>
<p>When you are looking at an opaque object on the deferred render, and you see a lot of green ,that means all 4 pixels of that quad had to be recalculated over and over.</p>
</blockquote>
<blockquote>
<p>you should probably be using lower LODs.</p>
</blockquote>
<p>*毫无意义的分割线</p>
<h4 id="Shader-Complexity-Quad-Overdraw"><a href="#Shader-Complexity-Quad-Overdraw" class="headerlink" title="Shader Complexity + Quad Overdraw"></a>Shader Complexity + Quad Overdraw</h4><ul>
<li>Combines two powerful view modes into one</li>
<li>USeful to get an idea of expensive shader anf geometry at a glance</li>
<li>You will still need the individual settings to help diagnose specifics</li>
</ul>
<h4 id="Liht-Complexity"><a href="#Liht-Complexity" class="headerlink" title="Liht Complexity"></a>Liht Complexity</h4><ul>
<li>Visualizes the cost of scene lighting</li>
<li>As lights overlap, the colors shift from cool to warm to white</li>
<li>Only shows cost of lighting, not shadowing</li>
<li>Obviously, white is bad</li>
<li>Great way to see where you should be lowing light radii</li>
<li>By flipping this on and off, you can quickly see if the cost of any given light is “worth it”</li>
</ul>
<h4 id="Lightmap-Density"><a href="#Lightmap-Density" class="headerlink" title="Lightmap Density"></a>Lightmap Density</h4><ul>
<li>Shows the density of texels for lightmap purposes</li>
<li><p>Color shifts from cool to warm an density increases</p>
<ul>
<li>Most things can be blue</li>
<li>Shadow maps don’t often need to be very high res</li>
</ul>
</li>
<li><p>Keep this as low as possible</p>
<ul>
<li>Cost adds up quickly</li>
</ul>
</li>
</ul>
<h4 id="Stationary-Light-Overlap"><a href="#Stationary-Light-Overlap" class="headerlink" title="Stationary Light Overlap"></a>Stationary Light Overlap</h4><ul>
<li>Only a maxium of 4 stationary lights can affect any given object</li>
<li>Beyound that,any other lights fall back to Movable(fully dynamic)</li>
<li>This view mode helps track down where that might be happening</li>
<li>Reminder to keep lighth radii as small as you can get it</li>
<li>Do you have a stationary sun?<ul>
<li>Congratulations! That’s one of the four lights!</li>
</ul>
</li>
</ul>
<h4 id="LOD-Coloration"><a href="#LOD-Coloration" class="headerlink" title="LOD Coloration"></a>LOD Coloration</h4><ul>
<li>This mode shows the current mesh LODs in use by color coding them</li>
<li>Very fast way to through ypur scene and verify that things are LODing when they should be</li>
<li>Interestingly, mode clearly shows that the trees are not LODing at all in this project<ul>
<li>Was able to diagnose frame drop instantly using this mode</li>
</ul>
</li>
</ul>
<h2 id="8-Profilling-Tools"><a href="#8-Profilling-Tools" class="headerlink" title="8.Profilling Tools"></a>8.Profilling Tools</h2><h3 id="CPU-Profiling"><a href="#CPU-Profiling" class="headerlink" title="CPU Profiling"></a>CPU Profiling</h3><ul>
<li><p>Integrated tool to take apart a segment od your gameplay and see wat’s happening on each tick</p>
<ul>
<li>Very useful way to profile Blueprint performance</li>
</ul>
</li>
<li><p>Measures a segment of time</p>
<ul>
<li>Within that segment, can look a individual frames or averages</li>
</ul>
</li>
<li><p>Requires two special Stat Commands</p>
<ul>
<li><em><span style="color:green">stat startfile</span></em> &amp; <em><span style="color:green">stat stopfile</span></em></li>
<li>Tese generate a log file between the interval of the commands</li>
<li>Profiller allows deep analysis that log</li>
</ul>
</li>
<li><p>Step down into world tick and see individual Blueprint functions</p>
</li>
<li>Can be used for CPU(Game and Draw) and GPU</li>
</ul>
<p>捕获下来的日志可以在UE4的<strong>Session Frontend</strong>中展开分析。</p>
<h3 id="GPU-Profiling"><a href="#GPU-Profiling" class="headerlink" title="GPU Profiling"></a>GPU Profiling</h3><ul>
<li><p>Three method to profile GPU functions</p>
<ul>
<li><span stype="color:green">stat GPU</span> command in tne viewport</li>
<li>Recorded file log in the <strong>Session Frontend</strong></li>
<li>GPU Profiler<ul>
<li>Can dump out to either the log or its own UI</li>
</ul>
</li>
</ul>
</li>
<li><p>Great way to visualize the cost of:</p>
<ul>
<li>Base pass</li>
<li>Lighting</li>
<li>Shadows</li>
<li>Post processing</li>
</ul>
</li>
</ul>
<h3 id="Tracking-Slow-Frame"><a href="#Tracking-Slow-Frame" class="headerlink" title="Tracking Slow Frame"></a>Tracking Slow Frame</h3><ul>
<li><p><em><span style="color:green">stat dumpHitches</span></em></p>
<ul>
<li>The command is used to dump any hitched over a given time in milliseconds out to the log</li>
<li>Use command <em><span style="color:green">t.hitchThreshhold 0.xx</span></em> to set value (0.05 is default)</li>
</ul>
</li>
<li><p><em><span style="color:green">memReport -full</span></em></p>
<ul>
<li>Full breakdown of how memory is being used</li>
<li>There’s a great blog post on how this works</li>
</ul>
</li>
</ul>
<p>虽然我还没有尝试过但是我可以使用上面的命令来找到游戏运行时候突然消耗非常高的那一帧究竟做了什么。</p>
<h3 id="startFPSChart-and-stopFPSChart"><a href="#startFPSChart-and-stopFPSChart" class="headerlink" title="startFPSChart and stopFPSChart"></a>startFPSChart and stopFPSChart</h3><ul>
<li><p>You can use the commands <em><span style="color:green">startFPSChart/span&gt;</span></em> and <em><span style="color:green">stopFPSChart/span&gt;</span></em> to create a diagram of framerates over time</p>
</li>
<li><p>You can call these at start and end of a Level Sequence to automatically read out the frame rates along a given course, as defined by a cinematic</p>
</li>
</ul>
<p>这里使用完这个命令之后会输出日志文件，需要使用别的软件把日志文件转化为图表。我用了GoogleDrive上的Excel做的。</p>
<h2 id="9-Blueprint-Optimizations-Or-Keeping-the-Kids-from-Eating-the-Crayons"><a href="#9-Blueprint-Optimizations-Or-Keeping-the-Kids-from-Eating-the-Crayons" class="headerlink" title="9.Blueprint Optimizations - Or:Keeping the Kids from Eating the Crayons"></a>9.Blueprint Optimizations - Or:Keeping the Kids from Eating the Crayons</h2><ul>
<li>Blueprints make it easy for folks to assemble gamepaly logic</li>
<li>Best results often come with engineer mentorship</li>
<li>Common challenge<ul>
<li>Reliance on Tick functionlity</li>
<li>Over-use of expensive functions(iterating on many objects)</li>
<li>Abuse of hard reference</li>
</ul>
</li>
</ul>
<h3 id="Reliance-on-Ticking-Blueprints"><a href="#Reliance-on-Ticking-Blueprints" class="headerlink" title="Reliance on Ticking Blueprints"></a>Reliance on Ticking Blueprints</h3><ul>
<li>Tick means should on every frame</li>
<li><p>Blueprints should almost never need Tick</p>
<ul>
<li>Remember to uncheck <em>Enable Actor Tick</em> in Class Defaults!<ul>
<li>This is on by default so that the Tick event will work</li>
</ul>
</li>
</ul>
</li>
<li><p>Alternatives to Tick</p>
<ul>
<li>Timers</li>
<li>Timelines</li>
<li>Manually enabling/disabling Tick on demand</li>
</ul>
</li>
<li>Make sure to adjust Tick Frequency<ul>
<li>0.0= every frame</li>
</ul>
</li>
</ul>
<h3 id="Expensive-Functionality"><a href="#Expensive-Functionality" class="headerlink" title="Expensive Functionality"></a>Expensive Functionality</h3><ul>
<li>Some functions are inherently expensive<ul>
<li>Get All Actors of Class</li>
<li>Spawn</li>
<li>Anything that needs to iterate over a large group of objects or properties</li>
</ul>
</li>
<li>Try not to use these if at all possiple<ul>
<li>If you are doing it to get a reference, consider having the referenced class pass itself up so the referencing object does not need to query</li>
<li>Use TSets instead of arrays</li>
</ul>
</li>
<li>If you must use them, do so as seldom as possible<ul>
<li>Perferably only once,such as at Begin Play</li>
</ul>
</li>
<li>Heavy ConstructionScripts can murder spawn times.<ul>
<li>Consider placing in the level beforehand</li>
</ul>
</li>
</ul>
<h3 id="Hard-References-in-Blueprint"><a href="#Hard-References-in-Blueprint" class="headerlink" title="Hard References in Blueprint"></a>Hard References in Blueprint</h3><ul>
<li>It is very easy for Blueprints to generate references to each other</li>
<li>When you load a Blueprint, every other Blueprint it references must be loaded<ul>
<li>And the Blueprints referenced by those</li>
<li>And so on,and so on..</li>
</ul>
</li>
<li>This will not slow dowwn in-game performance, but it can eat away at memory and load times</li>
<li><p>Some studios have thought the Editor just ran slow</p>
<ul>
<li>Turns out they were loading moost(ot all) of their game on startup</li>
</ul>
</li>
<li><p>Avoiding hard references:</p>
<ul>
<li><p>Avoiding casting operations unless you are certain you need them and know that it won’t cause issue</p>
<ul>
<li>For instance, if a Pickup class can only interact with the player, it might be fine to have it cast to Player</li>
<li>But having the Player class references every other type of pickup and interactive object in the game, you will likely see problems</li>
</ul>
</li>
<li><p>Instead, use Blueprint Interfaces</p>
</li>
<li>Try to get into the mentailty of not needin a very specific reference type<ul>
<li>Send your messages via an interface to a more generic class</li>
<li>If they land on something inplementing the interface, grate!</li>
<li>If not,no big deal</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Other-Blueprint-Optimizations"><a href="#Other-Blueprint-Optimizations" class="headerlink" title="Other Blueprint Optimizations"></a>Other Blueprint Optimizations</h3><ul>
<li>Avoiding doing too much of any one thing(like with any scripting language)<ul>
<li>Too much functionality in a sngle class<ul>
<li>Break things up</li>
<li>Use a class hierarchy<ul>
<li>But on that note, also avoid…</li>
</ul>
</li>
</ul>
</li>
<li>Class hierarchies that are too deep</li>
<li>Too many components within a class</li>
<li>Too much high-end math<ul>
<li>Use the Math Expression node- it’s optimized to speed things up</li>
</ul>
</li>
<li>When all else fails for BP performance: <strong>GO NATIVE</strong>!<ul>
<li>At Epic, many of our Blueprints derive from generic C++ classes</li>
<li>Yours should, too!</li>
<li>Keep all the heavy functionality in code, leave the lighter stuff for Blueprint</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="What-Actors-are-Ticking"><a href="#What-Actors-are-Ticking" class="headerlink" title="What Actors are Ticking?"></a>What Actors are Ticking?</h3><ul>
<li>Did you lose track of what’s ticking? Use <em><span style="color:green">dumpticks</span></em></li>
<li>Dumps a list of all ticking Actors out to the log, telling you how many tick functions are called</li>
<li>Also shows how many enabled and disabled ticking Actors are in the scene</li>
</ul>
<h2 id="10-Draw-Thread-Optimization"><a href="#10-Draw-Thread-Optimization" class="headerlink" title="10.Draw Thread Optimization"></a>10.Draw Thread Optimization</h2><h3 id="CPU-Rendering-Considerations"><a href="#CPU-Rendering-Considerations" class="headerlink" title="CPU Rendering Considerations"></a>CPU Rendering Considerations</h3><ul>
<li>Bottlenecks at the Draw thread are often caused by doing too much:<ul>
<li>Too many draw calls</li>
<li>Occlusion queries - see above</li>
<li>Simulating too many particles</li>
<li>Adding too many lights - often hits the GPU harder</li>
</ul>
</li>
<li>Generally the best way to speed up the Draw thread is to do less</li>
<li>Find every way you can to put fewer things on the screen</li>
<li>Generally this means either being very clever with content or using the integrated tools within UE4 start combining objects</li>
</ul>
<h3 id="Actor-Merge-Tool"><a href="#Actor-Merge-Tool" class="headerlink" title="Actor Merge Tool"></a>Actor Merge Tool</h3><ul>
<li>Located under <em>Window &gt; Developer Tools</em></li>
<li>Combines selection of meshes in to new asset, replacing originals</li>
<li>Can also combine Material via Simplygon</li>
<li>Works best with many meshes having the same Material</li>
</ul>
<blockquote>
<p>The Actor Merge tool works best with many meshed that have the same materials as possible.If you try to combine 20 meshed and each has its own Material every materail,you are not benefiting from the tool because every material is going to make a draw call anyway.</p>
</blockquote>
<h3 id="Instanced-Static-Meshes"><a href="#Instanced-Static-Meshes" class="headerlink" title="Instanced Static Meshes"></a>Instanced Static Meshes</h3><ul>
<li>Mechanism for generating multiple instances of a given mesh, with each considered part of the same mesh object.</li>
<li>Can only be created throuth code or Blueprint at this time, often via the Construction Script</li>
<li>Very easy to create a Blueprint set that helps generate this<ul>
<li>Placement Blueprint that is used to preview where mesh will be</li>
<li>Radius based ISM Blueprint that gathers transforms from Preview BPs and populates the instances with itself.</li>
<li>Be careful of Editor Utility class BPs-they’re Editor only!</li>
</ul>
</li>
<li>Also consider <em>Hierarchical Instanced Static Meshes</em><ul>
<li>Handle their own occlusion/visibility</li>
</ul>
</li>
</ul>
<h3 id="Hierarchical-LOD"><a href="#Hierarchical-LOD" class="headerlink" title="Hierarchical LOD"></a>Hierarchical LOD</h3><ul>
<li>Hierarchical LODs allow multiple meshed to be combined and then reduced as a single mesh</li>
<li>Will also combine textures into atlases. reducing overall Material demands</li>
<li>Very useful for buildings and cities, groups of large meshes that need to be viewed at extreme distance</li>
<li>Requires Simplygon implementation</li>
</ul>
<h2 id="11-GPU-Optimizations-What-to-do-about-all-those-pixels"><a href="#11-GPU-Optimizations-What-to-do-about-all-those-pixels" class="headerlink" title="11.GPU Optimizations - What to do about all those pixels"></a>11.GPU Optimizations - What to do about all those pixels</h2><h3 id="Vertex-Shader-Optimizatin"><a href="#Vertex-Shader-Optimizatin" class="headerlink" title="Vertex Shader Optimizatin"></a>Vertex Shader Optimizatin</h3><ul>
<li>Be careful how much you make use of World Position Offset<ul>
<li>Often cheaper than the alternative methods of vertex animation</li>
</ul>
</li>
<li>Vertex color can eventually get costly<ul>
<li>On Paragon, we ended up stripping it and adding it back per instance</li>
</ul>
</li>
</ul>
<h3 id="Pixel-Shader-Optimizations"><a href="#Pixel-Shader-Optimizations" class="headerlink" title="Pixel Shader Optimizations"></a>Pixel Shader Optimizations</h3><p><span style="color:red">Pixel Shader Don’ts</span></p>
<ul>
<li>Too much math</li>
<li>Too many textures</li>
<li>Too many procedural functions<ul>
<li>noise</li>
</ul>
</li>
<li>Too many Material layers</li>
<li>Reliance on lfs(if statements)<ul>
<li>Both sides have to calculate</li>
</ul>
</li>
</ul>
<p><span style="color:green">Pixel Shader Dos</span></p>
<ul>
<li>Use textures for lookups instead of mesh</li>
<li>Compress greyscale maps into single textures</li>
<li>Minimize Layer usage</li>
<li>Use Switch Parameters to turn off what you don’t need</li>
</ul>
<h3 id="Material-Instruction-Counts"><a href="#Material-Instruction-Counts" class="headerlink" title="Material Instruction Counts"></a>Material Instruction Counts</h3><ul>
<li>Always pay attention to Material instruction counts</li>
<li>Caution: the number indicated is not accurate until you click Apply<ul>
<li>Sometimes it’s best to re-compile the Material just to be safe</li>
</ul>
</li>
</ul>
<h3 id="Dealing-with-Overdraw"><a href="#Dealing-with-Overdraw" class="headerlink" title="Dealing with Overdraw"></a>Dealing with Overdraw</h3><ul>
<li>Overdraw is one of the leading causes of GPU slogging</li>
<li>Minimize the geometry area for overdraw<ul>
<li>Adding vertices is almost aways cheaper than relying in overdraw</li>
<li>For example, on A Boy and His Kite,we ended up cutting the grass planes to almost exactly match the outline of the grass texture alpha</li>
</ul>
</li>
<li>Make use of Particle Cutout property<ul>
<li>This is found under the Cascade Required Moudle</li>
<li>Feed it a texture, it automatically snips the spite</li>
<li>Also works in subUVs,with a different cutout for every frame</li>
</ul>
</li>
</ul>
<h3 id="Managing-Texture-Resolution"><a href="#Managing-Texture-Resolution" class="headerlink" title="Managing Texture Resolution"></a>Managing Texture Resolution</h3><ul>
<li>Author texture at whatever resolution you like,but keep in mind you may not always use full resolution</li>
<li>Use the Texture Streaming view to see what level of mips you’re using for any given texture</li>
<li>You can use the Statistics panel set to Texture Staticstics to see what levl of mips you are using at current levels</li>
<li>Then use the Texture Editor to force mip bias</li>
<li>Or better yet,reimport at lower resolution</li>
</ul>
<h3 id="Lighting-Considerations"><a href="#Lighting-Considerations" class="headerlink" title="Lighting Considerations"></a>Lighting Considerations</h3><ul>
<li><p>Dynamic lights are expensive (but somewhat cheaper in deferred)</p>
<ul>
<li>Small,unshadowed lights are the cheapest!</li>
<li>You can have lots of these</li>
</ul>
</li>
<li><p>Minimize number of dynamic lights</p>
</li>
<li>Minimize number of things dynamic lights have to effect</li>
<li>Minimize dynamic light radii -tighter is better</li>
<li>Cast shadows from as few dynamic lights as possible<ul>
<li>Dynamic shadow casting lights are the most expensive in UE</li>
</ul>
</li>
<li><p>Watch out for Stationary Light Overlap</p>
<ul>
<li>The fallback to dynamic lighting is extremely expensive</li>
</ul>
</li>
<li><p>Bake whenever you can</p>
</li>
<li>Don’t assume you need dynamic lights</li>
<li>Use Mesh Distance Field shadows at distance</li>
<li>Watch out for dense shado cascades</li>
<li>Many artifacts are cleaned up with Shadow Bias,but be gentle</li>
<li><p>Keep Lightmap Res as low as you can</p>
<ul>
<li>Use the view mode,keep it blue as much as possible</li>
</ul>
</li>
<li><p>Avoid Light Function unless you really need them</p>
<ul>
<li>Consider IES profiles, but understand they also have a cost</li>
</ul>
</li>
<li>Lit translucency gets expensive, use with caution</li>
<li>Cull shadows early (at close distance as possible)</li>
<li>Cull dynamic lights as early as possible</li>
<li>Spot lights are cheaper than Point lights</li>
<li>Don’t be afraid to completely fake shadows<ul>
<li>We do this a lot, especially for VR</li>
</ul>
</li>
</ul>
<h3 id="Replication-Optimization"><a href="#Replication-Optimization" class="headerlink" title="Replication Optimization"></a>Replication Optimization</h3><ul>
<li>Common problems for networking:<ul>
<li>Doing too much</li>
<li>Doing it too much</li>
</ul>
</li>
<li>Replicate as little as you can, as seldom as you can</li>
<li>Use <span style="color:green">net.*</span>  commands to check what’s going on<ul>
<li>Must be run on the sever<ul>
<li>Use cheat net.* to run the command on the server from the client</li>
</ul>
</li>
<li>Use net.DumpRelevantActors to see what is currently replicating<ul>
<li>This command features some improvements as of 4.19</li>
</ul>
</li>
<li>There are a lot of these net.* commands - check online for full list</li>
</ul>
</li>
</ul>
<p>*毫无意义的分割线</p>
<h3 id="Network-Relevancy-View-Mode-4-19"><a href="#Network-Relevancy-View-Mode-4-19" class="headerlink" title="Network Relevancy View Mode(4.19)"></a>Network Relevancy View Mode(4.19)</h3><p>…</p>
<p>我已经不知道他在讲什么了。。</p>
<h2 id="12-Content-Streaming"><a href="#12-Content-Streaming" class="headerlink" title="12.Content Streaming"></a>12.Content Streaming</h2><h3 id="Texture-Streaming"><a href="#Texture-Streaming" class="headerlink" title="Texture Streaming"></a>Texture Streaming</h3><ul>
<li>Textures streaming into and out of your scene at inopportune times cause visible pops</li>
<li>As of 4.15 we have some tools for texture streaming diagnostics<ul>
<li>Texture streaming view mode<ul>
<li>Primitive Distance Accuracy</li>
<li>Mesh Densities Accuracy</li>
<li>Material Texture Scales Accuracy</li>
<li>Required Texture Resolution</li>
</ul>
</li>
<li><span style="color:green">stat streaming</span></li>
</ul>
</li>
</ul>
<h4 id="Primitive-Distance-Accuracy"><a href="#Primitive-Distance-Accuracy" class="headerlink" title="Primitive Distance Accuracy"></a>Primitive Distance Accuracy</h4><ul>
<li>Visialization system for texture streaming</li>
<li><p>Enable users to see what mips the system things they should be using, allowing for intelligent mip limits</p>
<ul>
<li><span style="color:red">Red = 2 or more mips too few</span></li>
<li><span style="color:orange">Orange = 1 mip too few</span></li>
<li><span style="color:blue">White = the right degree of mips</span></li>
<li><span style="color:cyan">Cyan = 1 mip too many</span></li>
<li><span style="color:green">Green = 2 or more mips too many</span></li>
</ul>
</li>
<li><p>This setting can be adjusted using the <em><span style="color:green">StreamingDistanceMultiplier</span></em> property</p>
</li>
</ul>
<h4 id="Mesh-UV-Densities-Accuracy"><a href="#Mesh-UV-Densities-Accuracy" class="headerlink" title="Mesh UV Densities Accuracy"></a>Mesh UV Densities Accuracy</h4><ul>
<li>This uses the density of a mesh’s UVs</li>
<li>Visualizes how those UV densities are distributing to densities are contributing to streaming data</li>
<li><p>Use the same paradigm as Primitive Distance Accuracy</p>
<ul>
<li><span style="color:red">Red = 2 or more mips too few</span></li>
<li><span style="color:orange">Orange = 1 mip too few</span></li>
<li><span style="color:blue">White = the right degree of mips</span></li>
<li><span style="color:cyan">Cyan = 1 mip too many</span></li>
<li><span style="color:green">Green = 2 or more mips too many</span></li>
</ul>
</li>
<li><p>Fixing this requires the UVs on each mesh to be adjuested</p>
</li>
</ul>
<h4 id="Material-Texture-Scales-Accuracy"><a href="#Material-Texture-Scales-Accuracy" class="headerlink" title="Material Texture Scales Accuracy"></a>Material Texture Scales Accuracy</h4><ul>
<li>This view mode samples all textures and feeds back the worst culprits for over-streaming and under-streaming</li>
<li><p>Data is based on streaming affected by textures that have had their UVs scaled</p>
</li>
<li><p>Helps diagnose streaming errors caused by UV scaling</p>
</li>
</ul>
<h4 id="Required-Texture-Resolution"><a href="#Required-Texture-Resolution" class="headerlink" title="Required Texture Resolution"></a>Required Texture Resolution</h4><ul>
<li>This mode shows te required resolution for the given texture, indicating how many mips under or over it is</li>
<li>Helps show the delta between the ideal resolution for the texture-what the GPU wants to show-and what is the GPU wants to show- and what is currenrly avaliable<ul>
<li><span style="color:red">Red = 2 or more mips too few</span></li>
<li><span style="color:orange">Orange = 1 mip too few</span></li>
<li><span style="color:blue">White = the right degree of mips</span></li>
<li><span style="color:cyan">Cyan = 1 mip too many</span></li>
<li><span style="color:green">Green = 2 or more mips too many</span></li>
</ul>
</li>
</ul>
<h4 id="Stat-Streaming"><a href="#Stat-Streaming" class="headerlink" title="Stat Streaming"></a>Stat Streaming</h4><ul>
<li>Realtime metrics on texture streaming memory usage</li>
<li>Breaks down texure streaming memory into 3 pools<ul>
<li>Texture</li>
<li>Streaming</li>
<li>Wanted</li>
</ul>
</li>
</ul>
<h4 id="Level-Streaming"><a href="#Level-Streaming" class="headerlink" title="Level Streaming"></a>Level Streaming</h4><ul>
<li>Level streaming is an ideal way to control what content is in use in your game</li>
<li>What you currently need is streamed in, what you don’t is streamed out</li>
<li>Be careful how much you stream at once!<ul>
<li>You may need negate some of the benefit if you have over-referenced your content within code or Blueprint</li>
</ul>
</li>
</ul>
<h4 id="Bonus-Level-Streaming-as-Collaboration"><a href="#Bonus-Level-Streaming-as-Collaboration" class="headerlink" title="Bonus: Level Streaming as Collaboration"></a>Bonus: Level Streaming as Collaboration</h4><ul>
<li>Level Streaming is also the primary way for level artists to work together</li>
<li>Different aspects are separated into different levels<ul>
<li>Not just different physical zones<h4 id="World-Composition"><a href="#World-Composition" class="headerlink" title="World Composition"></a>World Composition</h4></li>
</ul>
</li>
<li>Specialized streaming system designed for large worlds</li>
<li>Will not work with old-school level streaming volimes</li>
<li>But WILL work with Blueprint streaming<ul>
<li>Pro Tips: You can very easily make a Blueprint that functions just like a Level Streaming volume and does exactly the same thing, only better.</li>
</ul>
</li>
</ul>
<h1 id="UE4中的各种特性的优化"><a href="#UE4中的各种特性的优化" class="headerlink" title="UE4中的各种特性的优化"></a>UE4中的各种特性的优化</h1><h2 id="Collision-Optimization"><a href="#Collision-Optimization" class="headerlink" title="Collision Optimization"></a>Collision Optimization</h2><p>关于碰撞体的优化，第一印象都是去掉碰撞体，就像我之前操作的那样，去</p>
<ul>
<li>ViewMode -&gt; Visbility Collision</li>
</ul>
<p>中找到可以看见到的但是没有用到的碰撞体。</p>
<p>然而我偶然看见一个工具，叫CollisionAnalyzer，貌似很有用处。</p>
<h3 id="Collision-Analyzer"><a href="#Collision-Analyzer" class="headerlink" title="Collision Analyzer"></a>Collision Analyzer</h3><p>位置位于</p>
<ul>
<li>Window -&gt; Developer Tools -&gt; Collision Analyzer</li>
</ul>
<ul>
<li><a href="http://historia.co.jp/archives/594/" target="_blank" rel="noopener">[UE4] コリジョンのデバッグ―Collision Analyzerを使おう！</a></li>
</ul>
<p>我突然意识到对于碰撞体的优化，应该是对CPU的处理的优化吧，毕竟碰撞处理的话都是逻辑一样的计算，但是我也不太确定啊。</p>
<h2 id="Profile-Data-Visualizer"><a href="#Profile-Data-Visualizer" class="headerlink" title="Profile Data Visualizer"></a>Profile Data Visualizer</h2><p>这篇文章真的是太长了，尽管我有在排版上面下了功夫，但还是显得很乱。在渲染的各个阶段我应该也有写出这个<strong>GPUProfile</strong>的一些部分的内容，但是这个Profile中的一些内容我并不知道该怎么分类，于是我便想把这些内容总结到一起。首先是这个Profile的整体结构。</p>
<ul>
<li>ProfileDataVisualizer(FRAME)<ul>
<li>Scene<ul>
<li>UpdateSceneObjectData</li>
<li>UpdateGlobalDistanceVolume</li>
</ul>
</li>
<li>SlateUI</li>
<li>FRAME Leaf Evnets</li>
</ul>
</li>
</ul>
<p>上面是这个视图的结构，因为是VR，有些内容会连续重复出现两次，应该就是里面的View0和View1的区别吧，两个镜片，即摄影机的话有些操作就必须做两次。有些内容我应该有在这篇文章的其他部分有展开就直接省略。</p>
<p>下面就对其中总是耗费很多时间的项目进行一些调查。</p>
<h3 id="Update-Global-Distance-Volume"><a href="#Update-Global-Distance-Volume" class="headerlink" title="Update Global Distance Volume"></a>Update Global Distance Volume</h3><p>参考了这个问题<a href="https://answers.unrealengine.com/questions/467114/update-global-distance-field-volume-taking-longer.html" target="_blank" rel="noopener">Update Global Distance Field Volume taking longer than usual</a></p>
<blockquote>
<p>The global distance field is updated if any of the features using it are enabled:</p>
<ul>
<li><p>Distance field particle collision</p>
</li>
<li><p>DistanceToNearestSurface material node</p>
</li>
<li><p>Shadow casting movable skylight</p>
</li>
</ul>
<p>It also updates if Ray Traced Distance field shadows are enabled, but that’s a bug. You can workaround it by forcing global distance fields off with ‘r.AOGlobalDistanceField 0’.</p>
<p>I’ll assume you are actually using a feature that requires it. The global distance field is a cache around the camera that has to update if the camera moves a lot, or if you have a moving static mesh which has bAffectDistanceFieldLighting enabled. The bigger the static mesh, the more expensive the update will be. Use ‘r.AOGlobalDistanceFieldLogModifiedPrimitives 1’ to track down which objects it is and disable bAffectDistanceFieldLighting on them.</p>
</blockquote>
<p>在视图中仔细观察它的结构：</p>
<ul>
<li>UpdateGlobalDistanceFieldVolume<ul>
<li>CacheType MostlyStaic Clipmap0</li>
<li>CacheType MostlyStaic Clipmap1</li>
<li>CacheType MostlyStaic Clipmap2</li>
<li>CacheType MostlyStaic Clipmap3</li>
<li>CacheType Movable Clipmap0<ul>
<li>GridCull</li>
<li>TileCullAndComposite 128x128x128</li>
<li>CompositeHeightfelds</li>
</ul>
</li>
<li>CacheType Movable Clipmap1</li>
<li>CacheType Movable Clipmap2</li>
<li>CacheType Movable Clipmap3</li>
</ul>
</li>
</ul>
<p>在上面的回答的追加内容中：</p>
<blockquote>
<p>So I put a skylight back in, set it from moveable to stationary and it has solved the performance issue. Could this potentially be a but as you told me Shadow Casting Moving Skylights cause it to be updated, however it appears that any moving skylight causes the update to the global distance field. Thanks for the hint that lead to the answer :)</p>
</blockquote>
<p>有提到SkyLight的光是Stationary类型的话，会缓解一下这个处理的时间。</p>
<p>于是我试着找会影响这个操作的几个概念都是什么意思，算是拓展。</p>
<h4 id="Distance-field-particle-collision"><a href="#Distance-field-particle-collision" class="headerlink" title="Distance field particle collision"></a>Distance field particle collision</h4><p>参考了<a href="https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/MeshDistanceFields/HowTo/DFHT_3/index.html" target="_blank" rel="noopener">Using Particle Collision Mode for Distance Fields</a></p>
<p>感觉很有用。</p>
<h4 id="RayTraced-Distance-Field-Soft-Shadows"><a href="#RayTraced-Distance-Field-Soft-Shadows" class="headerlink" title="RayTraced Distance Field Soft Shadows"></a>RayTraced Distance Field Soft Shadows</h4><p>参考了<a href="https://docs.unrealengine.com/ja/Engine/Rendering/LightingAndShadows/RayTracedDistanceFieldShadowing/index.html" target="_blank" rel="noopener">RayTraced Distance Field Soft Shadows</a></p>
<h1 id="LOD-Optimization-未整理"><a href="#LOD-Optimization-未整理" class="headerlink" title="LOD Optimization (未整理)"></a>LOD Optimization (未整理)</h1><ul>
<li><a href="https://www.slideshare.net/com044/lods-for-optimization-beginner" target="_blank" rel="noopener">UE4 LODs for Optimization -Beginner-</a></li>
</ul>
<h1 id="GPU-Performance-for-Game-Artists"><a href="#GPU-Performance-for-Game-Artists" class="headerlink" title="GPU Performance for Game Artists"></a>GPU Performance for Game Artists</h1><p>这是上面的视频里大力推荐的一篇文章。有时间我也得看一下，去理解一下整理一下。</p>
<ul>
<li><a href="www.fragmentbuffer.com/gpu-performance-for-game-artists/">GPU Performance for Game Artists</a></li>
</ul>
<h1 id="Tech-Art-Aid-videos-on-Youtube"><a href="#Tech-Art-Aid-videos-on-Youtube" class="headerlink" title="Tech Art Aid videos on Youtube"></a>Tech Art Aid videos on Youtube</h1><p>这个在油管上的视频我一直在看了，在这儿记录一下网址：</p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLF8ktr3i-U4A7vuQ6TXPr3f-bhmy6xM3S" target="_blank" rel="noopener">UE4 Graphics Profiling</a></li>
</ul>
<h1 id="Optimization需要之后整理"><a href="#Optimization需要之后整理" class="headerlink" title="Optimization需要之后整理"></a>Optimization需要之后整理</h1><p>关于Fortnite的一些优化方法，我觉得应该能学到一些什么：</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=KHWquMYtji0" target="_blank" rel="noopener">Optimizing UE4 for Fortnite: Battle Royale - Part 1 | GDC 2018 | Unreal Engine</a></li>
</ul>
<p>几篇感觉很不错的关于优化的知乎文章:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/33881861" target="_blank" rel="noopener">[GDC16] Optimizing the Graphics Pipeline with Compute</a></li>
</ul>
<p>上面文章里的PDF我已经下载下来了。老地方找。</p>
<ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/33881505" target="_blank" rel="noopener">[Siggraph15] GPU-Driven Rendering Pipelines</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/36434616" target="_blank" rel="noopener">Performance and Profiling（UE4优化）</a></p>
</li>
</ul>
<p>我感觉下面的知识我至少应该了解，这里贴上一些链接，以便自己找：</p>
<ul>
<li><p><a href="https://docs.unrealengine.com/en-us/Engine/Rendering/VisibilityCulling/PrecomputedVisibilityVolume" target="_blank" rel="noopener">Precomputed Visibility Volume</a></p>
</li>
<li><p><a href="https://docs.unrealengine.com/en-US/Engine/Proxy-Geometry-Tool/Proxy-Geometry-Overview" target="_blank" rel="noopener">Proxy Geometry Overview</a></p>
</li>
<li><p><a href="http://timhobsonue4.snappages.com/culling-precomputed-visibility-volumes" target="_blank" rel="noopener">PRECOMPUTED VISIBILITY VOLUMES</a></p>
</li>
<li><p><a href="https://software.intel.com/en-us/articles/software-occlusion-culling" target="_blank" rel="noopener">Software Occlusion Culling</a></p>
</li>
</ul>
<p>这个带有中文的教程我觉得非常好有时间把这个整理成一个系列吧:</p>
<ul>
<li><p><a href="https://software.intel.com/zh-cn/articles/unreal-engine-4-optimization-tutorial-part-3" target="_blank" rel="noopener">Unreal Engine 4 优化教程第三部分</a></p>
</li>
<li><p><a href="https://software.intel.com/zh-cn/articles/cpu-performance-optimization-and-differentiation-for-unreal-engine-4-vr-application-part1" target="_blank" rel="noopener">Unreal* Engine 4 VR应用的CPU性能优化和差异化：第一部分</a></p>
</li>
<li><p><a href="https://software.intel.com/zh-cn/articles/intel-software-engineers-assist-with-unreal-engine-419-optimizations" target="_blank" rel="noopener">英特尔软件工程师帮助实施 Unreal Engine* 4.19 优化</a></p>
</li>
</ul>
<ul>
<li><a href="https://80.lv/articles/epic-landscape-production/" target="_blank" rel="noopener">Epic Landscape Production</a></li>
</ul>
<p>这篇我应该有记录但是为了以防万一再记录一次。</p>
<ul>
<li><a href="https://unrealartoptimization.github.io/book/profiling/passes-base/" target="_blank" rel="noopener">BasePass</a></li>
</ul>
<p>一篇关于VR的优化文章：</p>
<ul>
<li><a href="https://framesynthesis.jp/tech/unrealengine/performance/" target="_blank" rel="noopener">UE4での描画最適化について</a></li>
</ul>
<p>比较详细的分解UE4的渲染Pass的内容的文章：</p>
<ul>
<li><a href="http://monsho.hatenablog.com/entry/2017/12/16/012502" target="_blank" rel="noopener">UE4の描画パスについて Ver 4.18.1</a></li>
</ul>
<p>UE4的的官方视频关于Profiling和Optimization的，由于是2019年年末的视频，我觉得有必要学习一下</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=EbXakIuZPFo" target="_blank" rel="noopener">Profiling and Optimization in UE4 | Unreal Indie Dev Days 2019 | Unreal Engine</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Performance</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4光照学习调查笔记</title>
    <url>/UE4%E5%85%89%E7%85%A7%E5%AD%A6%E4%B9%A0%E8%B0%83%E6%9F%A5%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>提高VR帧数的工作，需要对各个流程有所了解。光照，渲染等等，这篇文章就是用来记录我在试图理解光照流程中遇到的知识点。</p>
<a id="more"></a>
<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><p>在UE4的官方文档中有很多说明，我只记录一些我可能会忘记的。</p>
<p>我在别的优化文章里面多少有提到关于光照的内容。</p>
<h2 id="Light-Mobility"><a href="#Light-Mobility" class="headerlink" title="Light Mobility"></a>Light Mobility</h2><ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/Rendering/LightingAndShadows/LightMobility" target="_blank" rel="noopener">Light Mobility</a><h3 id="Stationary-lights"><a href="#Stationary-lights" class="headerlink" title="Stationary lights"></a>Stationary lights</h3>这种光源是位置不变但是它的brightness和color等想要变化的那种光源。</li>
</ul>
<blockquote>
<p>However,it should be noted that runtime changes to brightness only affect the direct lighting.Indirect (bounced) lighting, since it is pre-calculated by lightmass, will not change.</p>
</blockquote>
<p>这里有三个需要我理解的地方。</p>
<ul>
<li>Direct Lighting ( √ )</li>
<li>Indirect (bounced) Light</li>
<li>Lightmass</li>
</ul>
<p>所有来自于Stationary Light的indirect lighting (应该是间接光照吧) 和间接阴影(indirect shadowing)会存储在Lightmap（光照贴图）中。直接光照阴影会存储在阴影贴图中(Shadowmap)。</p>
<blockquote>
<p>All of the indirect lighting and shadowing from Stationary Lights is stored within the lightmap.Direct shadows are stored within the Shadowmap.These lights make use of Distance Field Shadows, meaning that their shadows can remain crisp even fairly low Lightmap Resolution on lit objects.</p>
</blockquote>
<p>当使用了低质量lightmap解决方案的时候，因为Stationary lights直射光产生的直接阴影是存储在Shadowmap中的，所以仍然还可以产生比较清晰的阴影。</p>
<p>这里需要深入理解的是：</p>
<ul>
<li>Shadowmap</li>
<li>Lightmap</li>
</ul>
<h4 id="Direct-Lighting"><a href="#Direct-Lighting" class="headerlink" title="Direct Lighting"></a>Direct Lighting</h4><blockquote>
<p>The direct lighting of stationary lights is rendered dynamically using deferred shading.This allows the brightness and color tobe changeable at runtime, along with a light function or IES profile.</p>
</blockquote>
<p>应该就是直接光源，stationary light的直接光照是使用延迟渲染。</p>
<p>这里我应该理解的是</p>
<ul>
<li>Deferred shading(该回忆了)</li>
<li>IES profile</li>
</ul>
<h4 id="Direct-Shadowing"><a href="#Direct-Shadowing" class="headerlink" title="Direct Shadowing"></a>Direct Shadowing</h4><blockquote>
<p>Realtime shadowing of light sources has a major performance cost. A fully dynamic light with shadows will often cost twenty times(20x) as much to render than a dynamic light without shadows. For this reason, stationary light have the ability to have static shadowing on static object, but with some limitations.</p>
</blockquote>
<p>关于阴影，光照的实时阴影是影响性能的一个主要参数。stationary light能产生静态阴影，在静态物体上。但是有限制。</p>
<h5 id="Static-Shadowing"><a href="#Static-Shadowing" class="headerlink" title="Static Shadowing"></a>Static Shadowing</h5><p><strong>On Opaque</strong></p>
<blockquote>
<p>Lightmass generate distance field shadow maps for stationary lights on static objects during the lighting rebuild. Distance field shadow maps provide very accurate shadow transition even at low resolution, and with very little runtime cost. Like lightmaps, distance field shadow maps require uniquely unwrapped UVs on all <em>StaticMeshes</em> using static lighting.</p>
</blockquote>
<p>当stationary light对不透明静态物体生成阴影的时候，在lighting rebuild阶段生成distance field shadow maps 。</p>
<blockquote>
<p>Lighting must be built to display distance field shadows, otherwise whole scene dynamic shadows will be used for previewing.</p>
</blockquote>
<p>这里我并没有找到有能够显示<strong>distance field shadow</strong>的编译选项。</p>
<blockquote>
<p>Only 4 or fewer overlaping stationary lights can have static shadowing, because the lights must be assigned to different channels of a shadowmap texture. This is a graph coloring problem, so there are often fewer than 4 overlapping allowed due to topology. </p>
</blockquote>
<blockquote>
<p>Shadowing cannot affect the overlap test, so <strong>the sunlight typically requires a channel from the entire level it is in, even the underground areas.</strong><br>这一句话应该是说阴影不会影响overlap测试，所以即使是在地下世界里的场景，有sunlight的情况下都要给sunlight预留一个channel。</p>
</blockquote>
<p>就像上面所说的，尽量避免stationary lighting的overlapping。在<strong>StationaryLightOverlap</strong>视图中，可以查看stationary lighting的重合程度。如果光源的图标变成了红色的X就表明它不能容纳更多的channel了。</p>
<p><strong>On Translucency</strong></p>
<blockquote>
<p>Translucency also receives shadowing very cheaply with Stationary lights - Lightmass precomputes a shadow depth map from static geometry which is applied to transluency at runtime. This form of shadowing is fairly coarse only captures shadowing on the scale of metres.</p>
</blockquote>
<p>不透明的物体也可以接收来自Stationary Light的光照阴影，代价也不是很高。但是这种阴影很粗糙。</p>
<ul>
<li>Shadow depth map</li>
</ul>
<blockquote>
<p>The resolution of the static shadow depth map is controlled by StaticShadowDepthMapTransitionSampleDistanceX and StaticShadowDepthMapTransitionSampleDistanceY in BaseLightmass.ini, with a default setting of 100 meaning one texel every meter.</p>
</blockquote>
<h5 id="Dynamic-Shadowing"><a href="#Dynamic-Shadowing" class="headerlink" title="Dynamic Shadowing"></a>Dynamic Shadowing</h5><blockquote>
<p>Dynamic objects(like StaticMeshComponents and SkeletalMeshComponement with Mobility set to Movable) must integrate into the static shadowing of the world from distance field shadowmaps. This is accomplished with <em>Per Object</em> shadows. Each movable object creates two dynamic shadows from a stationary light : a shadow to handle the static world casting onto the object, and a shadow to handle the object casting onto the world.</p>
</blockquote>
<p>动态物体（movable）必须整合到来自<strong>distance field shadowmap</strong>的世界静态阴影(<strong>The static shadowing of the world</strong>) 中去,这个经由<strong>Per Object shadows</strong>来完成(每一个物体的阴影计算？)。每一个标记为movable的物体会创建两个来自StationaryLight的动态阴影，一个用来处理静态世界在该物体上的阴影，另外一个用来处理该物体在世界里面的阴影。</p>
<p>这意味着当动态物体的数量很多的时候，使用动态光是更好的选择。</p>
<blockquote>
<p><em>Per Object</em> shadows used by movable components apply a shadowmap to the object’s bounds, therefore the bounds must be accurate. For Skeletal meshes this means they should have a physics assets. For partial systems, any fixed bounding box must be large enough to contain all particles.</p>
</blockquote>
<p><strong>Direction light dynamic shadowing</strong></p>
<p><strong>Directiong Stationary Lights</strong>比较特殊，因为它通过<em>Cascaded Shadow Maps</em>(级联阴影贴图)和<em>static shadowing</em>支持整个场景的阴影的生成。当场景中存在许多<em>animating foliage</em>会很有用；当在player的周围存在许多动态的阴影，但是并不想花费太大的代价去使用许多cascades覆盖很大的视野范围。动态阴影将会随着距离的提升一点点渐隐到静态阴影中，这样的过度通常难以区分。</p>
<p>可以改变 <em>DirectionalLightStationary</em> 的<strong>Dynamic Shadow Distance StationaryLight</strong> 的范围来控制过渡的距离范围。</p>
<p>这里我不理解的概念：</p>
<ul>
<li>Cascaded Shadow Maps</li>
<li>Animating foliage</li>
</ul>
<blockquote>
<p>Movable components will still create PerObjects shadows even when using Cascaded Shadow Maps on a directional light.This behavior is useful with small Dynamic Shadow Distance, but incurs unnecessary cost with larger distance. To disable PerObject shadows and save performance, disable <em>Use Inset Shadows For Movable Objects</em> on the light.</p>
</blockquote>
<h4 id="Indirect-Lighting"><a href="#Indirect-Lighting" class="headerlink" title="Indirect Lighting"></a>Indirect Lighting</h4><p>和静态光照一样，StationaryLight将间接光照存储在光照贴图内（lightmap）。间接光照不能像直接光照那样运行中改变光照的brightness和color。这意味着即使在<strong>light build</strong>中将<strong>Visible</strong>取消，间接光照还是会被存储在光照贴图当中。</p>
<p><strong>IndirectLightingIntensity</strong>的光照属性可以被用来控制大小和开关，在光照的编译阶段。</p>
<blockquote>
<p>However there is a post process volumn setting called <strong>IndirectLightingIntensity</strong> which lets you scale the contribution of the lightmap for all light, which can be changed at runtime from a blueprint.</p>
</blockquote>
<p>上面的很好理解就不解释了。</p>
<h4 id="Use-Area-Shadows-for-Stationary-Lights"><a href="#Use-Area-Shadows-for-Stationary-Lights" class="headerlink" title="Use Area Shadows for Stationary Lights"></a>Use Area Shadows for Stationary Lights</h4><p><strong>Directional Light</strong>可以打开这个属性，但是要保证这个直射光照的<strong>Mobility</strong>是<strong>Stationary</strong>。</p>
<blockquote>
<p>When the <em>Use Area Shadows for Stationary Lights</em> option is enabled,the Stationary Light will use area shadows for the precomputed shadow maps. Area shadows are shadows that get softer the further they are from caster.</p>
</blockquote>
<blockquote>
<p>Note that Area Shadows will only work on Stationary Lights and you might have to increase some objects lightmap resolution to get the same shadow quality and sharpness.</p>
</blockquote>
<p>总的来说就是这个属性会让阴影变得比较柔软，更贴近现实一些。</p>
<h3 id="Movable-Lights"><a href="#Movable-Lights" class="headerlink" title="Movable Lights"></a>Movable Lights</h3><p>动态光照不会把数据烘焙到光照贴图里，并且没有任何间接关照（currently）。</p>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>阴影是动态光照里最昂贵的花销之一，光照内的mesh的图元数量和三角形数量是影响性能的指标。</p>
<blockquote>
<p>Movable lights setup to cast shadows use whole scene dynamic shadows, which have a significant performance cost.The performance cost comes primarily from the number meshes affected by the light,and the triangle count of those meshes.</p>
</blockquote>
<h4 id="Shadow-Map-Caching"><a href="#Shadow-Map-Caching" class="headerlink" title="Shadow Map Caching"></a>Shadow Map Caching</h4><ol>
<li>选中所有产生动态阴影的动态光</li>
<li>确保<strong>Mobility</strong>是<strong>Movable</strong>，并且<strong>Cast Shadows</strong>属性选中</li>
<li><strong>Backtick( ` )</strong> 打开console输入 <em><span style="color:green">Stat Shadowrendering</span></em> 查看实时动态阴影的花销</li>
<li>再次打开console，键入 <em><span style="color:green">Sr.Shadow.CacheWholeSceneShadow 0</span></em>关掉<strong>dynamic shadow caching</strong></li>
<li>注意<strong>CallCount</strong> 和 <strong>InclusiveAug</strong></li>
<li>再打开console，键入 <em><span style="color:green">r.Shadow.CacheWholeSceneShadow 1</span></em> 打开<strong>dynamic shadow caching</strong></li>
</ol>
<ul>
<li>you can control the maximum amount memory used by the Shadow Map Cache using <strong><span style="color:green">r.Shadow.WholeScenceShadowCacheMb</span></strong></li>
</ul>
<h5 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h5><p>关于使用限制：</p>
<ul>
<li>By default,caching can only happen when an object meets the following requirements:<ul>
<li>Primitives have their mobility <strong>Mobility</strong> set <strong>Static</strong> or <strong>Stationary</strong>.</li>
<li>Materials used in the level do not use <strong>World Position Offset</strong>.</li>
<li>Light need to be either a <strong>Point</strong> or <strong>Spot</strong> light, have its <strong>Mobility</strong> set to <strong>Movable</strong>, and have <strong>Shadow Casting</strong> enabled.</li>
<li>Lights have to remain at one location.</li>
<li>Material that use animated <strong>Tessellation</strong> or <strong>Pixel Depth Offset</strong> can cause artifacts as their shadow depths are cached.</li>
</ul>
</li>
</ul>
<p>最后一条不太理解，需要继续调查：</p>
<ul>
<li>Tessellation</li>
<li>Pixel Depth Offset</li>
</ul>
<h2 id="Actor-Mobility"><a href="#Actor-Mobility" class="headerlink" title="Actor Mobility"></a>Actor Mobility</h2><p>这里插一条概念，关于Actor的Mobility属性。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/Actors/Mobility" target="_blank" rel="noopener">Actor Mobility</a></li>
</ul>
<p>文档上有写，所以我就少写一点。</p>
<p>当我知道了StationaryLight的属性的影响的时候，主要会让我产生混乱的是当StaticMesh的mobility属性是Stationary的话怎么办</p>
<blockquote>
<p>For Static Mesh Actors,this means that they can be changed but not moved.They do not contribute to pre-calculated lightmaps using Lightmass and are lit like Movable Actor when lit by a Static or Stationary Light.However,when lit by a Movable Light, they will use a Cached Shadow Map to reuse for the next frame when the lighting is not moving.</p>
</blockquote>
<p>大体上就是StationaryLight下的StationaryMobility的StaticMeshActor,没什么太大的意义。</p>
<h2 id="Lightmass"><a href="#Lightmass" class="headerlink" title="Lightmass"></a>Lightmass</h2><ul>
<li><a href="https://docs.unrealengine.com/en-us/Engine/Rendering/LightingAndShadows/Lightmass" target="_blank" rel="noopener">Lightmass Global Illumination</a></li>
</ul>
<p>Lightmass生成像区域阴影，漫反射交互等等的复杂光照交互的光照贴图。通常被用来预计算一部分的静态光照和StationaryLight的光照。</p>
<h2 id="Feature-for-Static-and-Stationary-lights"><a href="#Feature-for-Static-and-Stationary-lights" class="headerlink" title="Feature for Static and Stationary lights"></a>Feature for Static and Stationary lights</h2><h3 id="Diffuse-Interreflection"><a href="#Diffuse-Interreflection" class="headerlink" title="Diffuse Interreflection"></a>Diffuse Interreflection</h3><p><strong>Diffuse interreflection</strong> is by far the most visually important global illumination lighting effect.Light bounces by default with Lightmass,and the BaseColor term of your material controls how much light(and what color)bounces in all directions. This effect is sometimes called Color Bleeding.Diffse Interreflection is incoming light reflecting equally in all directions,which means  that it is not affected by the viewing direction or position.</p>
<h3 id="Indirect-Lighting-Cache"><a href="#Indirect-Lighting-Cache" class="headerlink" title="Indirect Lighting Cache"></a>Indirect Lighting Cache</h3><p>Lightmass为静态物体生成间接光照的光照贴图，动态物体也同样需要，解决方案是使用<strong>Indirect Lighting Cache</strong>。但是从UE4 4.18版本之后默认实现就被<strong>Volumetric Lightmap</strong> 取代了。</p>
<h3 id="Volumetic-Lightmaps"><a href="#Volumetic-Lightmaps" class="headerlink" title="Volumetic Lightmaps"></a>Volumetic Lightmaps</h3><ul>
<li><a href="https://docs.unrealengine.com/en-US/Engine/Rendering/LightingAndShadows/VolumetricLightmaps" target="_blank" rel="noopener">Volumetric Lightmaps</a></li>
</ul>
<p>在光照的编译阶段所有的点预计算的光照会被存储在Volumetric Lightmap中，之后在实时运算中被用来dynamic objects的间接光照插值运算。</p>
<p>工作方式：</p>
<ul>
<li>在光照的编译阶段，Lightmass会在整个场景中放置<strong>lighting samples</strong> 并且计算它们的间接光照。</li>
<li>当开始渲染动态物体的时候，<strong>Volumetric Lightmap</strong>会以插值的方式为每一个被渲染的像素提供预先计算好的间接光照。</li>
<li>if no built lighting is available(meaning the object is new or has moved too much), lighting is interpolated to each pixel from the Vloumetric Lightmap for <strong>Static</strong> objects until lighting is rebuild.</li>
</ul>
<p>上面的那句话我不太理解就直接抄了英文。</p>
<h4 id="Enabling-Volumetric-Lightmap-Visualization"><a href="#Enabling-Volumetric-Lightmap-Visualization" class="headerlink" title="Enabling Volumetric Lightmap Visualization"></a>Enabling Volumetric Lightmap Visualization</h4><p>在view视图中找到：</p>
<p><strong>Show &gt; Visualize &gt; Volumetric Lightmap</strong></p>
<p>可以查看，貌似必须是编译好光照之后才能看的见。</p>
<p>有着越远离几何体密度越低的特点。</p>
<p>这里提到了<strong>Lightmass Important Volume</strong>这个蛮重要的东西。</p>
<h2 id="Stationary-Light的阴影"><a href="#Stationary-Light的阴影" class="headerlink" title="Stationary Light的阴影"></a>Stationary Light的阴影</h2><ul>
<li><a href="http://darakemonodarake.hatenablog.jp/entry/2015/12/16/UE4/Stationary" target="_blank" rel="noopener">Stationary Light の影について</a></li>
</ul>
<p>参照上面的文章进行的一些总结。</p>
<h3 id="Static-Mesh-Shadow"><a href="#Static-Mesh-Shadow" class="headerlink" title="Static Mesh Shadow"></a>Static Mesh Shadow</h3><ul>
<li><p><strong>Stationary Light的阴影贴图是由各自的StaticMesh保持的</strong></p>
<ul>
<li>这个可以在Stat的NumSM/TextureSM条目里查看</li>
<li>ULightComponent::ReassignStationaryLightChannels</li>
</ul>
</li>
<li><p><strong>Stationary Light的ShadowMap是经由G-Buffer之后的光照计算阶段生成的</strong></p>
<ul>
<li>再稍微具体一点来说就是：StaticMesh在LightBuilt之后，有了StationaryLight阴影贴图，然后在BasePass阶段，把这个ShadowMaps的值拷贝到G-Buffer中的一个PrecomputedShadowFactors的float4类型的值中去，在写进G-Buffer中之后，在光照计算阶段，光照通过读取自己持有的Index对应的PrecomputedShadowFactor的值来计算像素的阴影。</li>
</ul>
</li>
</ul>
<h3 id="Movable-Object"><a href="#Movable-Object" class="headerlink" title="Movable Object"></a>Movable Object</h3><p>动态物体在StationaryLight的阴影又是什么样子的？</p>
<p>先是以点光源为例，DirectionalLight使用的是CascadeShadow，有一些不同。</p>
<ul>
<li>StationaryLight为每一个MovableMesh计算阴影贴图，并把ShadowMap的数据存储到一张巨大的阴影贴图中。</li>
<li>之后逐个对其所有的Mesh的渲染进行阴影的计算。（实际的渲染阶段的阴影计算？）</li>
</ul>
<p>总结为：</p>
<p><strong>Movable Mesh的Stationary Light阴影的计算Cost = 光照范围内的Movable Mesh数 * 每一个物体阴影的生成和渲染cost（PerObject？之前貌似在哪里见过）</strong></p>
<p>Stationary Light的阴影，每一个Movable Mesh都会被计算。</p>
<p>像是废话。</p>
<p>Stationary Light的阴影，对于Movable Mesh而言，它会一个一个的进行阴影贴图的计算，然后一个一个的进行渲染。</p>
<p>用实际的数据来展现就是：</p>
<p>在<span style="color:green">ProfileGPU</span>命令打开的Profiler中的这一项：</p>
<ul>
<li><strong>ShadowDepthFromOpaqueProjected</strong></li>
</ul>
<p>可以看到Movable Mesh在Stationary Light下的每一个阴影贴图计算的时间，一般都是0.01我感觉。</p>
<p>终于知道这个是什么意思了。</p>
<p>还有这一项：</p>
<ul>
<li><strong>ShadowProjectionOnOpaque</strong></li>
</ul>
<p>可以看到对于每一个Movable Mesh，Stationary Light的实际的阴影计算所消耗的时间。</p>
<p>（我觉得我应该去复习一下渲染流程了。）</p>
<p>这就会在StationaryLight的光照范围内加入大量的动态物体会使得处理时间变长的原因。</p>
<p><strong>而另一方面，Movable Light对于Movable Mesh阴影的处理不是以每一个动态物体为单位而是以光照为单位，对这个光照范围内的所有物体打包计算。</strong></p>
<p>因此当Movable物体很多的时候，动态光照的方案要优于StationaryLight方案。</p>
<h3 id="Directional-Light的阴影"><a href="#Directional-Light的阴影" class="headerlink" title="Directional Light的阴影"></a>Directional Light的阴影</h3><p>上面的都是对点光源和聚光灯的光源来说的不包含直射光。</p>
<p>Directional Light基本上是用Cascade Shadow Map进行的。级联阴影贴图。</p>
<p>在ProfileGPU中的具体项目是：</p>
<ul>
<li>ShadowDepthFromOpaqueProjected<ul>
<li>WholeScene split1</li>
<li>WholeScene split2</li>
<li>WholeScene split3</li>
<li>..(maybe)</li>
</ul>
</li>
</ul>
<p>有一个让处在Cascade Shadow以外的Object以点光源一样进行阴影计算的方式：</p>
<ul>
<li>Cascade Shadow Map &gt; Inset Shadow For Movable Objects</li>
</ul>
<p>这意思是CascadeShadow是有范围的？</p>
<p>通过调整 <em>Dynamic Shadow Distance Stationary Light</em> 的距离可以让物体不使用Cascade Shadow。</p>
<p>总结：</p>
<ul>
<li><p><strong>Static Mesh：Stationary Light事先计算阴影，由各静态mesh保持，当开始渲染的时候直接读取值处理负荷很小。</strong></p>
</li>
<li><p><strong>Movable Mesh：Stationary Light对每一个动态Mesh计算阴影，当动态物体很多的时候，优先选择Movable Light。</strong></p>
</li>
</ul>
<h2 id="Lighting-needs-to-be-rebuilt"><a href="#Lighting-needs-to-be-rebuilt" class="headerlink" title="Lighting needs to be rebuilt"></a>Lighting needs to be rebuilt</h2><p>光照烘焙，一般的情况下这个提示是要烘焙光照，但是我遇到了烘焙光照之后还有这个提示的问题。是在我删除掉场景里的所有FoliageStaticMesh之后。</p>
<h3 id="DumpUnbuildLightInteractions"><a href="#DumpUnbuildLightInteractions" class="headerlink" title="DumpUnbuildLightInteractions"></a>DumpUnbuildLightInteractions</h3><p>在Command Line中输入上述的命令，可以在OutputMessage里面输出需要烘焙的对象信息。</p>
<h1 id="Light-Map"><a href="#Light-Map" class="headerlink" title="Light Map"></a>Light Map</h1><p>光照贴图这个部分能说的东西实在时候太多了，要理解的东西也非常多，<strong>LightMap</strong>具体是个什么东西，用来存储什么数据？搜LightMap的时候又会出现其他的概念，<strong>LightMass</strong>又是什么？</p>
<p>LightMass在上面也有提到一点。</p>
<h2 id="Unwrapping-UVs-for-Lightmaps"><a href="#Unwrapping-UVs-for-Lightmaps" class="headerlink" title="Unwrapping UVs for Lightmaps"></a>Unwrapping UVs for Lightmaps</h2><p>当试着搜LightMap的时候，就会出现这篇官方文档<br>-<a href="https://docs.unrealengine.com/en-US/Engine/Content/Types/StaticMeshes/LightmapUnwrapping" target="_blank" rel="noopener">Unwrapping UVs for Lightmaps</a></p>
<h2 id="Lightmass-1"><a href="#Lightmass-1" class="headerlink" title="Lightmass"></a>Lightmass</h2><p>这个有我下载的PDF，有时间总结一下。</p>
<ul>
<li><a href>Lightmassの仕組み ~Lightmap編~ (Epic Games Japan- 篠山範明)</a></li>
</ul>
<p>这篇文章提到的：</p>
<p><strong>LightMap和ShadowMap是以Actor为单位各自保持的。</strong></p>
<p>可以在Statistics中的StaticMeshLighting info中看到Actor的各自持有的<strong>TextureLM</strong>和<strong>TextureSM</strong>。</p>
<h1 id="LightingTroubleshootingGuide"><a href="#LightingTroubleshootingGuide" class="headerlink" title="LightingTroubleshootingGuide"></a>LightingTroubleshootingGuide</h1><ul>
<li><a href="https://wiki.unrealengine.com/LightingTroubleshootingGuide#Lightmap_Resolution_.2F_Shadow_Quality" target="_blank" rel="noopener">LightTroubleshootingGuide</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的各种文件操作</title>
    <url>/C++%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>说到LOG的制作那么文件读写就肯定有大费周折了，当然不是我大费周折，我用的人家现成的东西。但是读起来其实挺费劲的，谁让我这么菜呢。</p>
<a id="more"></a>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><h3 id="sopen-s-wsopen-s"><a href="#sopen-s-wsopen-s" class="headerlink" title="_sopen_s, _wsopen_s"></a>_sopen_s, _wsopen_s</h3><p>打开文件以供共享。</p>
<p>参考官方文档：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/sopen-s-wsopen-s?view=vs-2017" target="_blank" rel="noopener">_sopen_s,_wsopen_s</a></li>
</ul>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><h3 id="lseek"><a href="#lseek" class="headerlink" title="_lseek"></a>_lseek</h3><p>将文件指针移动到指定位置</p>
<p>官方文档：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/lseek-lseeki64?view=vs-2017" target="_blank" rel="noopener">_lseek, _lseeki64</a></li>
</ul>
<h3 id="write"><a href="#write" class="headerlink" title="_write"></a>_write</h3><p>将数据写入文件</p>
<p>官方文档：</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/cpp/c-runtime-library/reference/write?view=vs-2017" target="_blank" rel="noopener">_write</a></li>
</ul>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><h3 id="close"><a href="#close" class="headerlink" title="_close"></a>_close</h3><p>关闭文件。</p>
<p>关于这些函数的用法在我最近读的plog里面都有，有空再仔细整理一下吧。</p>
<p>还有一些其他的用法调查一下就知道了，想了想花时间写一下也好但是收益不大，暂时先记下吧。</p>
<h2 id="errno"><a href="#errno" class="headerlink" title="errno"></a>errno</h2>]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要用size_t</title>
    <url>/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8size-t/</url>
    <content><![CDATA[<p>总的来说就是为了提高代码的可移植性，有效性或者可读性。</p>
<a id="more"></a>
<ul>
<li><a href="http://web.archive.org/web/20101209143037/http://www.eetimes.com/discussion/programming-pointers/4026076/Why-size-t-matters?" target="_blank" rel="noopener">Why size_t matters</a></li>
</ul>
<p>之后整理一下这篇文章的内容。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>new与malloc的区别</title>
    <url>/new%E4%B8%8Emalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>new/delete与malloc/free显而易见的区别是，前者会调用对象的构造/析构函数，而后者不会。</p>
<a id="more"></a>
<p>再仔细说明就是new的操作是新建<em>对象</em> ，而malloc只是分配一块内存而已。</p>
<p>在Stack Overflow上有更为详尽的说明，有时间的话好好整理一下。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/240212/what-is-the-difference-between-new-delete-and-malloc-free" target="_blank" rel="noopener">What is the difference between new/delete and malloc/free?</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的运算符重载</title>
    <url>/C++%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>运算符重载(operator overloading)只是一种”语法上的方便“（syntactic sugar).也就是说它只是另一种函数调用的方式。</p>
<a id="more"></a>
<h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>运算符重载有成员运算符和非成员运算符之分，那么这个之间有什么区别呢，应该选择哪一种呢？</p>
<blockquote>
<p>总的来说，如果没有什么差异，它们应该是成员运算符。这样做强调了运算符和类的结合。当左操作数是当前类的对象时，运算符会工作的很好。</p>
</blockquote>
<blockquote>
<p>但有的时候左侧操作数是别的类对象。这种情况通常出现在输入输出流重载<strong>operator&lt;&lt;</strong>和<strong>&gt;&gt;</strong> 时。因为输入输出流是一个基本C++库。</p>
</blockquote>
<p>这里就说到了关键了。为了应付各种数据类型的输出，输入输出流的重载就很重要了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码之后贴</span></span><br></pre></td></tr></table></figure>
<p>这里我先暂停一下，说一说为什么要认识运算符重载这个问题。</p>
<p>举例来说，<code>cout</code>这个类是我学C++最早接触的对象了之一了，但是却很不是理解。其实即就是<code>cout</code>对<code>&lt;&lt;</code>运算符进行了重载。</p>
<p>我自己创建了一个Record类，希望这个类能对接在<code>&lt;&lt;</code>后面的数据进行一些操作，比如说接收数据什么的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Record &lt;&lt; <span class="number">2</span>;</span><br><span class="line">Record &lt;&lt; <span class="string">"str string"</span>;</span><br></pre></td></tr></table></figure></p>
<p>想这样把后面的数据接收保存在类内变量中。就这样我遇见了下面的代码:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Record类内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Record&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> T&amp; data)</span><br><span class="line">&#123;</span><br><span class="line">    m_message &lt;&lt; data;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代表着混沌势力的模板登场了（对我来说)。这里就涉及到了函数模板的问题。我看到上面的代码的时候第一反应是，这段代码能直接用？</p>
<p>答案是肯定的，像类模板的使用那样，指定明确的模板参数类型来特化函数模板使用是可行的，也就是我觉得应该这样做的，但是<strong>让编译器从函数的参数中推断出它们的类型将会更方便。</strong></p>
<p>后面的内容就更多了，在别的模板章节中展开更好。</p>
<p>回到上面的代码，<code>m_message &lt;&lt; data</code> 的m_message是什么类型合适呢？是<code>ostringstream</code>。是C++标准库的东西，这样就省得自己一个一个重载数据类型了。方法是个好方法，但是最后我没用上。因为要处理宽字符的问题，涉及到宽窄字符互相转换的问题，试来试去总是出问题，我就Pass掉了，全部交给UE4里的FString类型和TEXT（）来处理了。</p>
<h1 id="运算符重载时的friend关键字"><a href="#运算符重载时的friend关键字" class="headerlink" title="运算符重载时的friend关键字"></a>运算符重载时的friend关键字</h1><p>当我们在类(class)的定义外使用操作符(operator)的时候，操作符两边的参数都可以进行类型的隐式转换(implicit type conversions)。但是在类内定义操作符的时候，只有右手边的参数可以执行类型的隐式转换。</p>
<p>比如说我们声明一个这样的类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">    std::string content;</span><br><span class="line">public:</span><br><span class="line">    Message(const std::string&amp; str);</span><br><span class="line">    bool operator==(const std::string&amp; rhs) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种方式对运算符的重载，允许我们这样操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Message message(&quot;Test&quot;);</span><br><span class="line">std::string msg(&quot;Test&quot;);</span><br><span class="line">if (message == msg) &#123;   // Message类可以和std::string类型的字符串比较</span><br><span class="line">    // do stuff...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是当我们把比较顺序换一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (msg == message) &#123; // this won&apos;t compile</span><br></pre></td></tr></table></figure></p>
<p>就会编译出错，原因很明显，在类内定义操作符的时候只有右手边的参数可以执行隐式转换，上面明显没有匹配的类型。<br>解决方案就是增加一个匹配类型：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">    std::string content;</span><br><span class="line">public:</span><br><span class="line">    Message(const std::string&amp; str);</span><br><span class="line">    bool operator==(const std::string&amp; rhs) const;</span><br><span class="line">    friend bool operator==(const std::string&amp; lhs, const Message&amp; rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者声明一个隐式转换操作符转到我们想要的类型(嘛这里不是很熟悉，我也没完全明白)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Message &#123;</span><br><span class="line">    std::string content;</span><br><span class="line">public:</span><br><span class="line">    Message(const std::string&amp; str);</span><br><span class="line">    bool operator==(const std::string&amp; rhs) const;</span><br><span class="line">    operator std::string() const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，还有一个需要注意的是，当我们重载操作符需要参照到类的私有成员的时候也必须使用friend限定。</p>
<p>至于操作符重载最好是以内联函数的形式这种结论我没有依据，还是要注意一些为好。</p>
<p>参考资料</p>
<ul>
<li><a href="https://stackoverflow.com/questions/6255825/what-operators-should-be-declared-as-friends/6255899" target="_blank" rel="noopener">What operators should be declared as friends?</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++-制作一个静态的单一实例</title>
    <url>/C++-%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AA%E9%9D%99%E6%80%81%E7%9A%84%E5%8D%95%E4%B8%80%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>制作单一实例，就会想到Singleton，单例模式。在C++里面如何制作一个唯一的一个实例，我只是有一个想法，然后付诸实践。也许这个想法或许是错的。但是重要的是我将这个想法付诸实践的过程，这个过程中我明白了许多知识点，只是不想忘记而已。</p>
<a id="more"></a>
<h2 id="指定需要单例化的类"><a href="#指定需要单例化的类" class="headerlink" title="指定需要单例化的类"></a>指定需要单例化的类</h2><p>首先要选一个适合的类进行单一实例化。举例来说我现在正在制作一个日志系统，故而我希望有一个唯一的实例<strong>Logger</strong>来管理关于日志的一切。所以我声明了以下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Logger.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Logger();</span><br><span class="line">    ~Logger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Logger.h"</span></span></span><br><span class="line"></span><br><span class="line">Logger::Logger()&#123;&#125;</span><br><span class="line"></span><br><span class="line">Logger::~Logger()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>像这样子。</p>
<h2 id="制作一个单例模板"><a href="#制作一个单例模板" class="headerlink" title="制作一个单例模板"></a>制作一个单例模板</h2><p>关于这个单例模板其实我也不太清楚具体是为什么而制作的，只是我在学习<a href>plog</a>这个日志库的时候看到就学了。首先它是一个模板，怎么用为什么要这么用，需要我理解模板的使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Singleton</span> :</span>NonCopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        m_instance = <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Singleton()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_instance != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_instance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> T* m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Singleton</span>&lt;T&gt;:</span>:m_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>先把出现的<code>NonCopyable</code>类的出现放在一边，讨论一下这个模板。</p>
<p>这个模板有一个私有静态属性，类型为<strong>T</strong>，而且在构造函数里面进行了像下类型转换，使用`static_cast，这个算是骚操作么，我也不太清楚。还有注意取得这个属性的指针函数是静态的，也就是有准备把这个单一实例声明为静态的。</p>
<p>总结一句话来说就是我们得到使用了这个模板并实例化成功的静态实例的指针引用。</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>这里让我有些不舒服的是<strong>引用</strong>这个词，按照我所理解的，引用和指针并不是一样的：</p>
<p><strong>引用（reference）（&amp;）就像能自动的被编译器间接引用的常量型指针。</strong></p>
<p>关于这一部分我应该是需要用大量的时间去理解的。在<em>C++编程思想第一卷第十一章的-引用和拷贝构造函数</em>里面有较为详细的说明。之后也会有提到。</p>
<h3 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h3><p>关于静态类成员，<a href="https://www.tutorialspoint.com/cplusplus/cpp_static_members.htm" target="_blank" rel="noopener">Static Members of a C++ Class</a> 里面的说明应该很详细了。</p>
<p>要点在于:</p>
<ul>
<li>静态类成员只有一份拷贝，无论类被实例化了多少次。</li>
<li>静态类函数只能调用静态类成员。</li>
<li>可以使用类公开的静态成员和静态函数，甚至类没有被实例化。</li>
<li>类静态成员没有this指针，可以用&lt;类名&gt;::&lt;静态成员&gt;来获取。</li>
<li>静态类成员必须在类外初始化</li>
</ul>
<p>这个是我制作的单例模式的关键理解部分。</p>
<h2 id="关于NonCopyable类"><a href="#关于NonCopyable类" class="headerlink" title="关于NonCopyable类"></a>关于NonCopyable类</h2><p>这个类可谓是突然出现在我的面前，一查却发现大有来历。就是一个防止类被复制的类。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonCopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    NonCopyable()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NonCopyable(<span class="keyword">const</span> NonCopyable&amp;);</span><br><span class="line">    NonCopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> NonCopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个地方涉及了许多拷贝构造函数相关的东西，<em>C++编程思想第一卷第十一章-引用和拷贝构造函数</em>的内容，之后需要好好理解。</p>
<h2 id="静态实例实装"><a href="#静态实例实装" class="headerlink" title="静态实例实装"></a>静态实例实装</h2><p>经过上面的洗礼，我试着写成下面这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> :</span> <span class="keyword">public</span> Singleton&lt;Logger&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Logger logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Logger();</span><br><span class="line">    Logger(<span class="keyword">const</span> Logger&amp;);</span><br><span class="line">    ~Logger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger Logger::logger = Logger();</span><br></pre></td></tr></table></figure></p>
<p>我在类里面声明了一个自身类的静态实例。加上继承来的静态方法可以取到这个静态实例。然后定义了它。</p>
<p>这里有一个问题就是，当我在类外面定义logger的时候，<code>Logger Logger::logger = Logger();</code>,编译报错了，因为当时我没有加上<code>Logger(const Logger&amp;);</code>这句话。</p>
<p>这句话是什么呢，貌似就是所谓的<strong>拷贝构造函数</strong>。并且被设置成了私有的。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想-第16章-模板介绍</title>
    <url>/C++%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E7%AC%AC16%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>记下关于模板的知识与理解。</p>
<p><em>继承和组合提供了重用对象代码的方法，而C++的模板特征提供了重用源代码的方法。</em></p>
<a id="more"></a>
<p>截止到最近为止我对模板的理解也就之停留在表面:作为一种类型的容器。比如说实现一个可以存储任类型的Stack，有一些共同的操作，当你想使用的时候放入具体的类型进行实例化(instanation)。容器，貌似很好理解的样子。</p>
<p>这也是文章开头所提的到的部分，最最简单且易为理解的部分。</p>
<p>小tips：</p>
<ul>
<li><code>staic int a[100];</code>这样的写法，编译器会将这个static数组初始化为0.</li>
</ul>
<h1 id="模板介绍-第十六章"><a href="#模板介绍-第十六章" class="headerlink" title="模板介绍(第十六章)"></a>模板介绍(第十六章)</h1><h2 id="16-3模板语法"><a href="#16-3模板语法" class="headerlink" title="16.3模板语法"></a>16.3模板语法</h2><p><strong>template</strong>这个关键字会告诉编译器，随后的类定义将操作一个或更多未指明的类型。当由这个模板产生实际类代码的时，必须指定这些类型以使编译器能够替换他们。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; size = <span class="number">100</span>; &#125;;</span><br><span class="line">    T A[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[]（<span class="keyword">int</span> index)&#123;</span><br><span class="line">        require（index &gt;= <span class="number">0</span> &amp;&amp; index &lt; size, <span class="string">"Index out of range"</span>);</span><br><span class="line">        <span class="keyword">return</span> A[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array&lt;<span class="keyword">int</span>&gt; ia;</span><br><span class="line">    Array&lt;<span class="keyword">float</span>&gt; fa;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这时，编译器两次扩展了Array模板【这被称为实例化(instantiation)】，创建两个新的生成类（generated class），可以把它们看做<strong>Arrray_int</strong>和<strong>Array_float</strong>（不同的编译器对名称有不同的修饰方法）。这些类就像是手工创建的一样，只是这里是当定义了对象ia和fa后由编译器来创建这些类。我们还会注意到，编译器避免了或者连接器合并了类的重复定义。</p>
</blockquote>
<h3 id="16-3-1非内联函数定义"><a href="#16-3-1非内联函数定义" class="headerlink" title="16.3.1非内联函数定义"></a>16.3.1非内联函数定义</h3><p>希望有非内联函数定义的时候，这时编译器需要在成员函数定义之前看到<strong>template</strong>声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; size = <span class="number">100</span>; &#125;</span><br><span class="line">    T A[size];</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="function">T &amp;<span class="title">operator</span><span class="params">(<span class="keyword">int</span>  index)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>&amp; <span class="title">Array</span>&lt;T&gt; :</span>:<span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">    require（index &gt;=<span class="number">0</span> &amp;&amp; index &lt; size), <span class="string">"Index out of range"</span>;</span><br><span class="line">    <span class="keyword">return</span> A[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于内联函数和非内联函数的定义在别的章节会有提到。在此不赘述。</p>
<p>在引用模板的类名的地方，必须伴有该模板的参数列表，这样在按照模板生成实例的时候，因为模板参数中的参数修饰类名，以便为每一个模板实例产生唯一的类名标识符。</p>
<ul>
<li>因此模板的参数列表在引用模板类名的时候，也要有一席之地。</li>
<li>模板的非内联函数定义之前一定要加上<strong>template</strong>声明。</li>
</ul>
<h4 id="16-3-1-1头文件"><a href="#16-3-1-1头文件" class="headerlink" title="16.3.1.1头文件"></a>16.3.1.1头文件</h4><blockquote>
<p>即使是在创建非内联函数定义时，我们还是把模板的所有声明和定义都放入一个头文件中。这似乎违背了通常的头文件规则：<strong>“不要放置分配存储空间的任何东西”</strong>（这条规则是为了防止在连接期间的多重定义错误），但模板定义很特殊。在<strong>template&lt;…&gt;</strong> 之后的任何东西都意味着编译器在当时不为他分配存储空间，而是一直处于等待状态直到被一个模板示例告知。在编译器和连接器中有机制能去掉统一模板的多重定义。所以为了使用方便，几乎总是在头文件中防止全部的模板声明和定义。</p>
</blockquote>
<h3 id="16-3-3模板中的常量"><a href="#16-3-3模板中的常量" class="headerlink" title="16.3.3模板中的常量"></a>16.3.3模板中的常量</h3><blockquote>
<p> 模板参数并不局限于类定义的类型，可以使用编译器内置类型。这些参数值在编译期间变成模板的特定示例的常量。我们甚至可以对这些参数使用默认值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span> = 100&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span>&#123;</span></span><br><span class="line">    T <span class="built_in">array</span>[size];</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index)&#123;</span><br><span class="line">        require(index &gt;=<span class="number">0</span> &amp;&amp; index &lt; size, <span class="string">"Index out of rande"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Number(<span class="keyword">float</span> ff = <span class="number">0.0f</span>) : f（ff) &#123;&#125;</span><br><span class="line">    Number&amp; <span class="keyword">operator</span>=（<span class="keyword">const</span> Number&amp; n)&#123;</span><br><span class="line">        f = n.f;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> f; &#125;    <span class="comment">// ????</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Number&amp; x)&#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; x.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">size</span> = 20&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Holder</span>&#123;</span></span><br><span class="line">    Array&lt;T, size&gt;* np;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    Holder() : np(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">        require(<span class="number">0</span> &lt;=i &amp;&amp; i &lt; size);</span><br><span class="line">        <span class="keyword">if</span>(!np) np = <span class="keyword">new</span> Array&lt;T, size&gt;;</span><br><span class="line">        <span class="keyword">return</span> np-&gt;<span class="keyword">operator</span>[](i）；</span><br><span class="line">    &#125;</span><br><span class="line">    intlength() <span class="keyword">const</span>&#123; returnsize； &#125;</span><br><span class="line">    ~Holder() &#123;<span class="keyword">delete</span> np;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    Holder&lt;Number&gt; h;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中的size的值没有房放在类中，但是对他的使用就如同是成员函数中的数据成员。</p>
<p>我记录下来上面这段代码的原因还有一个就是<em>懒惰初始化(lazy initialization)</em>.上面的Holder中有一个指向Array的指针，而不是指向类型Array的嵌入对象。该指针在构造函数中不被初始化，而是被推迟到了第一次访问的时候。还有等等的稀有的用法。</p>
<p>这个章节还有许多其他内容，但是貌似跟我现在急需要理解的内容相差甚远，暂时保留。</p>
<h1 id="第二卷第五章-深入理解模板"><a href="#第二卷第五章-深入理解模板" class="headerlink" title="第二卷第五章 深入理解模板"></a>第二卷第五章 深入理解模板</h1><p>关于模板的使用问题，在真正的使用模板之前一定要先让编译器看到模板的声明和定义，比如说在同一个文件里写一个类继承一个模板的时候，模板的声明和定义不能在类的下方，应该先写模板再用。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的强制类型转换-cast</title>
    <url>/C++%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-cast/</url>
    <content><![CDATA[<p>实在是遇见太多次了，遇见了还看不懂，再不整理就过分了。关于C++中的强制类型转换问题。这次的主角是:<code>stati_cast</code>,<code>dynamic_cast</code>,<code>const_cast</code>,<code>reinterpret_cast</code>。</p>
<a id="more"></a>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>提笔要写，先看别人的总结</p>
<ul>
<li><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used" target="_blank" rel="noopener">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></li>
</ul>
<p>这里我遇见的情况就是static_cast的重要的用法。继承类型的向下类型转换。下面来看看我遇见的神仙代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Singleton</span> :</span> NonCopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Singleton()</span><br><span class="line">	&#123;</span><br><span class="line">		assert(!m_instance);</span><br><span class="line">		m_instance = <span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~Singleton()</span><br><span class="line">	&#123;</span><br><span class="line">		assert(m_instance);</span><br><span class="line">		m_instance = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> T* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">static</span> T* m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Singleton</span>&lt;T&gt;:</span>:m_instance = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>一个单例模板类，读代码的时候，按照这个模板被实例化的是他的子类，顺便这个子类所具有的instance的引用就变成它自己了。我什么时候也能写出这么优秀的代码。</p>
<p>还有其他的强制类型转换，遇见的时候具体分析吧。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>在做各种数据类型匹配的时候，遇到了这样的问题：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UE4 C++</span></span><br><span class="line">FString text = <span class="string">"111"</span>;</span><br><span class="line">TCHAR* t_text = *text;</span><br></pre></td></tr></table></figure></p>
<p>上面是想把FString类型转化为TCHAR*类型的数据。</p>
<p>但是上面的会报错，原因是无法将<code>const THCAR*</code>转化为<code>TCHAR*</code>。那就直接加上关键字const就解决了。但是问题是这个<code>t_text</code>是我设置的即将要传入另外一个函数的参数，它要是设置为常量类型的话就没法传参了。</p>
<p>把常量指针变成普通的指针，就是我接触到<code>const_cast</code>的起因。但是关于它的使用，可不是一句话就能总结的。</p>
<blockquote>
<p>const_cast实现的原因在于C++对于指针的转换是任意的，它不会检查类型，任何指针之间都可以进行互相转换。</p>
</blockquote>
<h3 id="去const限定"><a href="#去const限定" class="headerlink" title="去const限定"></a>去const限定</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TCHAR* t_text = <span class="string">"1234"</span>;</span><br><span class="line">TCHAR* text = <span class="keyword">const_cast</span>&lt;TCHAR*&gt;(t_text);</span><br></pre></td></tr></table></figure>
<p>将常量指针转化为了正常指针，但是正常情况下不会做这种弱智操作。正常声明就行了，但是有的时候要传参的情况传的不是常量怎么办，那只好强制转换了。</p>
<p><strong>去const限定的操作绝对不是为了修改它的内容</strong>，既然声明了常量还要修改那为什么还要声明为常量。既然声明了常量就要贯彻到底。<strong>绝对不对const数据进行重新赋值</strong>。</p>
<p>根据别人的文章内容，强行修改常量的值会产生<em>未定义行为（Undefined Behavior）</em>,这种行为由编译器决定如何处理。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的文字编码与文字存储类型</title>
    <url>/C++%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97%E7%BC%96%E7%A0%81%E4%B8%8E%E6%96%87%E5%AD%97%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>在准备把函数名字输出的时候遇到了输出乱码的问题。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCHAR* text = <span class="string">"DLL内容テスト。"</span>;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"TEXT: %s"</span>), text);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在我写这段代码之前我连<code>TCHAR</code>是什么类型都不知道，经过一番的调查，关于文字编码和文字的数据存储类型，了解到了很多。</p>
<h2 id="源码的存储格式"><a href="#源码的存储格式" class="headerlink" title="源码的存储格式"></a>源码的存储格式</h2><p>关于源码的存储格式，在我现在的地方，使用的大多是日语系统因此在什么都不动的情况下使用的是日语的默认 <strong>Japanese(Shift-JIS)</strong> 格式。至于怎么确认存储格式的话，在一些编辑器中应该就可以查看。</p>
<ul>
<li>在Visual Studio 2017中改变文件存储格式<ul>
<li>File -&gt; Save as -&gt; 下面Save旁边的箭头 -&gt; save with encoding -&gt; replace -&gt; Encoding</li>
</ul>
</li>
</ul>
<p>一般比较喜欢的就是<strong>Unicode(UTF-8)</strong> 就是了，毕竟兼容了英文字母之外的字符。</p>
<p>比如最前面把函数名字输出却遇到了乱码的的方，如果将源码存储为UTF-8格式，就不会出现乱码了。</p>
<h2 id="C-中的字符存储类型"><a href="#C-中的字符存储类型" class="headerlink" title="C++中的字符存储类型"></a>C++中的字符存储类型</h2><p>关于字符的存储问题，首先要分清楚各种字符的存储类型。</p>
<h4 id="char"><a href="#char" class="headerlink" title="char"></a>char</h4><p>普通的8位字节类型。</p>
<h4 id="wchar-t"><a href="#wchar-t" class="headerlink" title="wchar_t"></a>wchar_t</h4><p>宽字符类型，表示范围要远大于char类型，表示类型有16位与32位，具体环境具体判断。Unicode编码字符一般以wchar_t类型存储。</p>
<p>为了让编译器识别Unicode字符串，必须在前面加一个<strong>L</strong> :<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wchar_t</span> * text = <span class="string">L"这是中文字符"</span>;</span><br></pre></td></tr></table></figure></p>
<p>看到这个<code>L</code>，让我想起了现在看的一个日志开源库里的一段糟心的代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _PLOG_NSTR(x) L##x</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PLOG_NSTR(x)  _PLOG_NSTR(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> PLOG_NSTR(x)  x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line">PLOG_NSTR(<span class="string">"context"</span>);</span><br></pre></td></tr></table></figure></p>
<p>简单来说就是一个把字符串添加L的宏，刚开始看到的时候糟心的不行。这段内容使用Unicode编码的意思，但是这里有一个问题：</p>
<ul>
<li>添加了L也就是说是使用Unicode编码，使用wchar_t数据类型存储。接着上述例子，<code>PLOG_NSTR</code>宏接收的如果不是简单的英文字母而是汉字或者日语，简单地输出会正确的输出吗？</li>
<li><p>此时源码的存储格式是否支持Unicode编码会产生影响吗？</p>
<ul>
<li><p>Shift-JIS格式的源码配合英文字母是能够正确输出的(源码是DLL)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PLOG_NSTR(<span class="string">"line@"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">line@</span><br></pre></td></tr></table></figure>
</li>
<li><p>Shift-JIS格式的源码配合日文内容也是能够正确输出的(源码是DLL)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PLOG_NSTR(<span class="string">"line内容テスト@"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">line内容テスト@</span><br></pre></td></tr></table></figure>
</li>
<li><p>当在UEEditor中实验的时候，Shift-JIS的格式源码没有正确输出。</p>
</li>
</ul>
</li>
</ul>
<p>结论：源码的存储格式应该存储为Unicode格式。在字符编码想要支持Unicode和ANSI两种格式的时候应该添加类似以下的宏<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _UNICODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __T(x)    L##x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _T(x)     __T(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _T(x)     x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>关于为什么不直接使用添加L的宏的原因是：防止数据变量声明和定义时的类型冲突。使用宏避免char与L的宽字符存储类型冲突。</p>
<p>在tchar.h文件中可以找到关于__T(x)宏的定义，貌似不包含这个文件的时候，自己定义也可以。</p>
<h4 id="TCHAR"><a href="#TCHAR" class="headerlink" title="TCHAR"></a>TCHAR</h4><p>THAR是对上述两种字符存储类型的统一，参考以下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> UNICODE</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">wchar_t</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TCHAR;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>当程序定义了UNICODE的时候TCHAR就是宽字符存储类型即wchar_t，当未定义的时候就是普通的char数据类型。</p>
<h2 id="UE4中的字符类型转换"><a href="#UE4中的字符类型转换" class="headerlink" title="UE4中的字符类型转换"></a>UE4中的字符类型转换</h2><p>当对字符的存储类型有了一些了解，就来看看他们之间的转换吧。先列出一些参考文章：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/StringHandling/CharacterEncoding" target="_blank" rel="noopener">Charactor Encoding</a></li>
</ul>
<h2 id="C-宽字符"><a href="#C-宽字符" class="headerlink" title="C++宽字符"></a>C++宽字符</h2><p>当我觉得我能理解并分别和使用C++中的宽字符的时候，现实告诉我还是太天真了。</p>
<p>先看看这篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/daliang126/article/details/53584395" target="_blank" rel="noopener">彻底解密C++宽字符</a></li>
</ul>
<p>写了很多我看不懂的，就是很复杂。我有照着别的示例程序试着写了一下宽窄字符转换，但是英文还好，没看出来什么变化，但是把日语从<code>const char*</code> 变成<code>const wchar_t*</code>的时候乱码还是乱码。</p>
<p>我使用的是<code>mbstowcs</code>函数来实现的，微软的官网文档也有介绍。官方推荐的是使用<code>mbstowcs_s</code>这个函数。有机会的话可以再试试。</p>
<p>应该有更深层次的原因，只不过我放弃了。借用4的<code>FString</code>和<code>TEXT()</code>宏来解决了。</p>
<p>我在plog中看到的宽窄字符转换跟下面的很像说不定好用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unicode字符集下可用</span></span><br><span class="line"><span class="comment">//--------------------------------------------------------宽字符串转换到窄字符串</span></span><br><span class="line"><span class="keyword">char</span>* pC = <span class="literal">NULL</span>;   </span><br><span class="line"><span class="keyword">wchar_t</span> wStr[<span class="number">20</span>] = <span class="string">L"宽字符串"</span>;  </span><br><span class="line"><span class="keyword">int</span> iLen = WideCharToMultiByte( CP_ACP,<span class="number">0</span>,wStr,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); </span><br><span class="line"><span class="keyword">if</span>( iLen &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    pC = ( <span class="keyword">char</span>* )HeapAlloc( GetProcessHeap() ,<span class="number">0</span> ,iLen );</span><br><span class="line">    <span class="keyword">if</span>( !pC ) <span class="keyword">return</span>;</span><br><span class="line">    WideCharToMultiByte( CP_ACP ,<span class="number">0</span> ,wStr ,<span class="number">-1</span> ,pC ,iLen ,<span class="literal">NULL</span> ,<span class="literal">NULL</span> );  </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"%s \n"</span>, pC );</span><br><span class="line">    HeapFree( GetProcessHeap() ,<span class="number">0</span> ,pC );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//--------------------------------------------------------窄字符串转换到宽字符串</span></span><br><span class="line"><span class="keyword">char</span> cStr[<span class="number">20</span>] = <span class="string">"这是窄字符串"</span>;</span><br><span class="line"><span class="keyword">wchar_t</span>* pWideString = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> iLenWide = MultiByteToWideChar( CP_ACP ,<span class="number">0</span> ,cStr ,<span class="number">-1</span> ,<span class="literal">NULL</span> ,<span class="number">0</span> ); </span><br><span class="line"><span class="keyword">if</span> ( iLenWide &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    pWideString = ( <span class="keyword">wchar_t</span>* )<span class="built_in">malloc</span>( iLenWide * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) );</span><br><span class="line">    <span class="keyword">if</span>( !pWideString ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    MultiByteToWideChar( CP_ACP ,<span class="number">0</span> ,cStr ,<span class="number">-1</span> ,pWideString ,iLenWide ); </span><br><span class="line">    MessageBox( <span class="literal">NULL</span>, pWideString , <span class="number">0</span> , <span class="number">0</span> );  </span><br><span class="line">    <span class="built_in">free</span>( pWideString ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>初识DLL-在UE4与Unity中使用DLL</title>
    <url>/use-dll-in-ue4-unity/</url>
    <content><![CDATA[<p>记录自己逐步认识和掌握DLL的过程。包含了创建DLL，在UE4中使用DLL，在Unity中使用DLL。</p>
<a id="more"></a>
<h1 id="新建DLL工程"><a href="#新建DLL工程" class="headerlink" title="新建DLL工程"></a>新建DLL工程</h1><p>先新建一个简单的DLL工程，然后在里面添加内容，方法可以参照：</p>
<ul>
<li><a href="https://wiki.unrealengine.com/Linking_Dlls" target="_blank" rel="noopener">Linking Dlls</a></li>
</ul>
<p>上面的链接已经失效了，UE4的Wiki一升级就完蛋。还好能搜到文章的映像，好心人还是有的。</p>
<ul>
<li><a href="https://nerivec.github.io/old-ue4-wiki/pages/linking-dlls.html" target="_blank" rel="noopener">Linking Dlls</a></li>
</ul>
<p>我觉得我还是好好的记录一下为好…</p>
<p>使用VS新建一个动态链接库的解决方案，就是工程<br><img src="CreateDLL_Setp1.jpg" alt="创建动态链接库"></p>
<p>至于它默认的建立的几个文件说实话我也不是特别了解，反正只是按照教程我自己新建了一个新的文件<code>LogFuncExport</code>的 .h .cpp文件。<br><img src="CreateDLL_Setp2.jpg" alt="新建一个我们用来导出函数的类文件"></p>
<p>然后我们复制粘贴测试代码，然后用<code>Release</code>和<code>X64</code>模式编译项目，在我们的项目文件夹下的<strong>x64/Release</strong>下找到我们用来测试用的dll文件。</p>
<p>至于测试代码就顺带贴一下，顺带一提我用的是VS2019，UE4的版本是4.25。头文件别忘了根据场景替换。</p>
<details><br>  <summary>点击展开测试用的代码</summary><br>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// .h文件</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> once  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)  <span class="comment">//shortens __declspec(dllexport) to DLL_EXPORT</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus    <span class="comment">//if C++ is used convert it to C to prevent C++'s name mangling of method names</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> DLL_EXPORT <span class="title">getInvertedBool</span><span class="params">(<span class="keyword">bool</span> boolState)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">getIntPlusPlus</span><span class="params">(<span class="keyword">int</span> lastInt)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">float</span> DLL_EXPORT <span class="title">getCircleArea</span><span class="params">(<span class="keyword">float</span> radius)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> DLL_EXPORT *<span class="title">getCharArray</span><span class="params">(<span class="keyword">char</span>* parameterText)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">float</span> DLL_EXPORT *<span class="title">getVector4</span><span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> w)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><br>  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// .cpp文件</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CreateAndLinkDLLFile.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Exported method that invertes a given boolean.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getInvertedBool</span><span class="params">(<span class="keyword">bool</span> boolState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">bool</span>(!boolState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exported method that iterates a given int value.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIntPlusPlus</span><span class="params">(<span class="keyword">int</span> lastInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">int</span>(++lastInt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exported method that calculates the are of a circle by a given radius.</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getCircleArea</span><span class="params">(<span class="keyword">float</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">float</span>(<span class="number">3.1416f</span> * (radius * radius));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exported method that adds a parameter text to an additional text and returns them combined.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getCharArray</span><span class="params">(<span class="keyword">char</span>* parameterText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* additionalText = <span class="string">" world!"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strlen</span>(parameterText) + <span class="built_in">strlen</span>(additionalText) + <span class="number">1</span> &gt; <span class="number">256</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)<span class="string">"Error: Maximum size of the char array is 256 chars."</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> combinedText[<span class="number">256</span>] = <span class="string">""</span>;</span><br><span class="line">  </span><br><span class="line">  strcpy_s( combinedText, <span class="number">256</span>, parameterText);</span><br><span class="line">  strcat_s( combinedText, <span class="number">256</span>, additionalText);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> ( <span class="keyword">char</span>* )combinedText;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exported method that adds a vector4 to a given vector4 and returns the sum.</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> *<span class="title">getVector4</span><span class="params">( <span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z, <span class="keyword">float</span> w )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">float</span>* modifiedVector4 = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">4</span>];</span><br><span class="line">  </span><br><span class="line">  modifiedVector4[<span class="number">0</span>] = x + <span class="number">1.0F</span>;</span><br><span class="line">  modifiedVector4[<span class="number">1</span>] = y + <span class="number">2.0F</span>;</span><br><span class="line">  modifiedVector4[<span class="number">2</span>] = z + <span class="number">3.0F</span>;</span><br><span class="line">  modifiedVector4[<span class="number">3</span>] = w + <span class="number">4.0F</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ( <span class="keyword">float</span>* )modifiedVector4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>


<h1 id="导出函数"><a href="#导出函数" class="headerlink" title="导出函数"></a>导出函数</h1><p>添加了具体的库的功能之后，需要将函数导出供外部使用。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT __declspec(dllexport)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> DLL_EXPORT <span class="title">ExportFuncName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>像这样，上述的函数就被导出，能够被外部调用了。</p>
<h2 id="导出函数的时候遇到的问题"><a href="#导出函数的时候遇到的问题" class="headerlink" title="导出函数的时候遇到的问题"></a>导出函数的时候遇到的问题</h2><p>当我在UE4中使用inline这个关键字的时候，给我报错了。</p>
<p>我在DLL导出函数的时候，导出的函数前面加了<strong>inline</strong>关键字，所以把导出函数的定义跟声明都写在了头文件里。发生了什么呢？</p>
<ul>
<li>在UE4中我获取到了<strong>DLL Plugin</strong>中的dll库，得到了DLL的Handle，但是准备使用这个Handel取出里面的函数的时候，取出来的是空。函数名什么的都是正确的情况下。</li>
</ul>
<p>发生上述的情况下我试着去掉DLL中的导出函数的<code>inline</code>声明，声明和定义分开在头文件和cpp文件，就解决了。</p>
<p>回归第一句的事实，貌似UE4C++中对于inline关键字是不支持的。哪怕是动态库中导出来的函数。</p>
<h1 id="UE4Editor中调用DLL"><a href="#UE4Editor中调用DLL" class="headerlink" title="UE4Editor中调用DLL"></a>UE4Editor中调用DLL</h1><p>在文章最开始的地方提到的链接已经说明的很清楚了。</p>
<p>要点在于:</p>
<ul>
<li>把制作好的DLL放到特定的文件夹中，一般是Plugin文件夹里面建立一个Plugin。</li>
<li>创建一个类继承<code>BlueprintFunctionLibrary</code>这样蓝图也能使用</li>
<li>声明的函数要是静态的（static）</li>
<li>调用DLL中的函数的步骤是:<ul>
<li>定义一个函数指针用来接收DLL中导出的函数(Use <code>typedef</code> to declare a method to store the DLL method)</li>
<li>声明一个Handle来保持与DLL的连接（<code>void* v_dllHandle</code>)</li>
<li>都不为空的时候调用导出来的函数。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*_getFunc)</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">_getFunc m_getFuncFromDll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> * v_dllHandle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ULOGBlueprintFunctionLibrary::DLLFunc(<span class="keyword">int</span> a, <span class="keyword">int</span> b）</span><br><span class="line">&#123;</span><br><span class="line">    FString dllfilepath = FPaths::Combine(*FPaths::ProjectPluginsDir(), TEXT(<span class="string">"DLLLibrary"</span>), TEXT(<span class="string">"DLLName.dll"</span>));</span><br><span class="line">    <span class="keyword">if</span>(FPaths::FileExists(dllfilepath))</span><br><span class="line">    &#123;</span><br><span class="line">        v_dllHandle = FPlatformProcess::GetDllHandle(*dllfilepath);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v_dllHandle != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            FString procName = <span class="string">"FunctionName"</span>;</span><br><span class="line">            m_getFuncFromDll = (_getFunc)FPlatformProcess::GetDllExport(v_dllHandle, *procName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m_getFuncFromDll != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m_getFuncFromDll(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的方法就像上述。</p>
<h1 id="DEBUG-DLL"><a href="#DEBUG-DLL" class="headerlink" title="DEBUG DLL"></a>DEBUG DLL</h1><p>关于DLL的DEBUG的问题，直接在工程里面DEBUG的方法我没有头绪。目前的方法是：</p>
<p>选中Build的模式为<code>Release，x64</code>然后编译。在工程文件夹中找到编译完毕的dll文件导入到调用的工程里面进行调用测试。</p>
<h1 id="UE4中打包第三方库"><a href="#UE4中打包第三方库" class="headerlink" title="UE4中打包第三方库"></a>UE4中打包第三方库</h1><p>你看上面使用动态链接库的方法多么简单啊，只要找到<em>dll</em>就可以对这个库进行使用了。按照上面的方法，无论在UE4Editor上运行几次，你都会满意的没有话说。</p>
<p>是的，在UE4的Editor上运行的话。</p>
<p>当你觉得差不多了咱们打包一下游戏吧。</p>
<p><em>File -&gt; Package Project -&gt; Windows -&gt;Windows(64-bit)</em></p>
<p>打完包了都不知道发什么了什么，知道发现dll的内容根本没法调用。是的，上面的一顿操作，当你打包整个工程之后会发现，准备好的dll并没有被一起打包进工程里。</p>
<p>原因就在于UE4并没有提供自动打包第三方库的功能，需要手动打包。敢情上面的dll的一顿操作只是针对Editor模式好用，当你准备打包应用程序的时候就不行了。算了，不生气。</p>
<h2 id="UE4的编译工具-Build-Tools"><a href="#UE4的编译工具-Build-Tools" class="headerlink" title="UE4的编译工具(Build Tools)"></a>UE4的编译工具(Build Tools)</h2><ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/BuildTools/index.html" target="_blank" rel="noopener">Build Tools</a></li>
</ul>
<p>为什么UE4不能把第三方库内容自动打包呢？这就要从UE4引擎的编译模式来说起了。</p>
<p>从官网的内容来看的话，BuildTools分为三个Topics</p>
<h3 id="1-UnrealBuildTool"><a href="#1-UnrealBuildTool" class="headerlink" title="1.UnrealBuildTool"></a>1.UnrealBuildTool</h3><blockquote>
<p>UnrealBuildTool (UBT) is a custom tool that manages the process of building Unreal Engine 4 (UE4) source code across a variety of build configurations. Read  BuildConfiguration.cs to explore various user-configurable build options.</p>
</blockquote>
<p>这个应该非常重要的概念了，也经常见到这个工具，但是具体的内容日后再挖。</p>
<ul>
<li><a href="https://ericlemes.com/2018/11/23/understanding-unreal-build-tool/" target="_blank" rel="noopener">Understanding Unreal Build Tool</a><h4 id="Topics1：-Targets"><a href="#Topics1：-Targets" class="headerlink" title="Topics1： Targets"></a>Topics1： Targets</h4></li>
<li><a href="https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/TargetFiles/index.html" target="_blank" rel="noopener">Targets</a></li>
</ul>
<p>UnrealBuildTool(以后简称UBT)</p>
<h4 id="Topics2-Modules"><a href="#Topics2-Modules" class="headerlink" title="Topics2: Modules"></a>Topics2: Modules</h4><ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/BuildTools/UnrealBuildTool/ModuleFiles/index.html" target="_blank" rel="noopener">Modules</a></li>
<li><a href="http://historia.co.jp/archives/3097/" target="_blank" rel="noopener">UE4 モジュールについて</a></li>
<li><a href="http://papersloth.hatenablog.com/entry/2018/03/05/221735" target="_blank" rel="noopener">UE4 Moduleについて</a></li>
<li><a href="https://qiita.com/go_astrayer/items/5d001a9cde182488f9f3" target="_blank" rel="noopener">一つの UE4 プロジェクトで複数のゲームモジュールを扱う</a></li>
<li><a href="https://www.romsuke.com/entry/2019/01/10/212704" target="_blank" rel="noopener">【UE4】モジュール追加</a></li>
<li><a href="https://qiita.com/takayashiki2/items/db995c558024c3db8223" target="_blank" rel="noopener">ModuleRules(XXX.build.csファイル)について</a></li>
</ul>
<h4 id="Topics3-Build-Configuration"><a href="#Topics3-Build-Configuration" class="headerlink" title="Topics3: Build Configuration"></a>Topics3: Build Configuration</h4><h4 id="Topics4-IWYU"><a href="#Topics4-IWYU" class="headerlink" title="Topics4: IWYU"></a>Topics4: IWYU</h4><h4 id="Topics5-Project-Files-for-IDEs"><a href="#Topics5-Project-Files-for-IDEs" class="headerlink" title="Topics5: Project Files for IDEs"></a>Topics5: Project Files for IDEs</h4><h4 id="Topics6-Versioning-of-Binaries"><a href="#Topics6-Versioning-of-Binaries" class="headerlink" title="Topics6: Versioning of Binaries"></a>Topics6: Versioning of Binaries</h4><h3 id="2-UnrealHeadTool"><a href="#2-UnrealHeadTool" class="headerlink" title="2.UnrealHeadTool"></a>2.UnrealHeadTool</h3><h3 id="3-AutomationTool"><a href="#3-AutomationTool" class="headerlink" title="3.AutomationTool"></a>3.AutomationTool</h3><h2 id="打包第三方库"><a href="#打包第三方库" class="headerlink" title="打包第三方库"></a>打包第三方库</h2><p>上面的是对于UE4编译系统的理解，而真正需要做的是具体是什么呢?</p>
<p>针对之前的内容我大致的总结了一下，慢慢补充:</p>
<p><strong>将DLL（第三方库）和项目一起打包</strong></p>
<ol>
<li><code>.uplugin</code>中的<code>&quot;Modules&quot;</code>模块的<code>&quot;Type&quot;</code>从<code>&quot;Developer&quot;</code>更改为<code>&quot;Runtime&quot;</code><ol>
<li>就我自己的观察结果来看，这个属性不更改的话，打包之后（Package化）连Plugin的尸体都不会给留，在打包后的工程中找不到想要的DLL</li>
</ol>
</li>
<li><p>指定平台编译（不是必要条件但是要是用错了平台的话肯定是要吃苦头的）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// uplugin文件</span><br><span class="line">&quot;Modules&quot;: [</span><br><span class="line">&#123;</span><br><span class="line">&quot;Name&quot;: &quot;USBCamDirectShow&quot;,</span><br><span class="line">&quot;Type&quot;: &quot;Runtime&quot;,</span><br><span class="line">&quot;LoadingPhase&quot;: &quot;Default&quot;,</span><br><span class="line">&quot;WhitelistPlatforms&quot;: [&quot;Win64&quot;, &quot;Win32&quot;]　←これを追加</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>工程文件结构补充(Module分布),Win64平台</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Project</span><br><span class="line">   |- Binaries</span><br><span class="line">        |- ...</span><br><span class="line">   |- Plugins</span><br><span class="line">        |- PluginNameA</span><br><span class="line">               |- Binaries</span><br><span class="line">                   |- ThirdParty</span><br><span class="line">                       |- PluginNameALibrary</span><br><span class="line">                   |- Win64</span><br><span class="line">               |- Source</span><br><span class="line">                  |- PluginNameA</span><br><span class="line">                        |- Private</span><br><span class="line">                        |- Public</span><br><span class="line">                        |- PluginNameA.Build.cs</span><br><span class="line">                  |- ThirdParty</span><br><span class="line">                       |- PluginNameALibrary</span><br><span class="line">                            |- PluginNameALibrary.Build.cs</span><br><span class="line">                            |- PluginNameALibrary.tps</span><br><span class="line">                            |- LibrarySource</span><br><span class="line">               |- PluginNameA.uplugin</span><br><span class="line">               |- ...</span><br><span class="line">   |- Source</span><br><span class="line">       |- Project</span><br><span class="line">           |- Project.h</span><br><span class="line">           |- Project.cpp</span><br><span class="line">           |- ProjectBuild.cs</span><br><span class="line">           |- ...</span><br><span class="line">       |- Project.Target.cs</span><br><span class="line">       |- ProjectEditor.Target.cs</span><br><span class="line">   |- Project.sln</span><br><span class="line">   |- Project.uproject</span><br><span class="line">   |- ...</span><br></pre></td></tr></table></figure>
<p> 我只列出了比较重要的内容，对于理解打包第三方库来说的。相比于默认的（创建工程的时候）文件结构来说，唯一不同的地方是在<code>Plugins</code>的文件夹下面的插件中的<code>Binaries</code>和<code>Source</code>文件夹出现了<code>ThirdParty</code>文件夹。当然这个文件夹也不是我创建的。那么我也不是凭空就知道正确的结构。要点就在于UE4提供了第三方库的插件使用模板。</p>
<ol>
<li>有效使用UE4提供的第三方库的插件使用模板。可以参考下面的第二个链接。<code>Edit -&gt; Plugins -&gt; NewPlugin</code>打开创建新的插件窗口。拉到最下边有一个<strong>Third Party Library</strong>的模板，创建使用。当然这还只是开始。不过这个时候已经有了雏形，大体的插件文件结构已经构建完成，不需要再去额外的创建文件，只要适当的修改文件就好了。</li>
<li>使用这个方法创建了第三方库之后你会发现，在你的Plugin的<em>Source/ThirdParty/PluginNameLibrary</em>下面就有了一个Solution，完全可以直接在这个Solution中制作想要的第三方库。</li>
<li>但是由于生成的Solution的名字固定，我选择删除了这个Solution，把上面自己新建的Solution给复制进去了。</li>
</ol>
</li>
<li><p>确保第三方库（DLL）的路径。下面是第三方库的编译设置文件(Build.cs)中的内容</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 位于上述目录结构中的PluginAnameLibrary.Build.cs</span><br><span class="line">// Fill out your copyright notice in the Description page of Project Settings.</span><br><span class="line"></span><br><span class="line">using System.IO;</span><br><span class="line">using UnrealBuildTool;</span><br><span class="line"></span><br><span class="line">public class test1Library : ModuleRules</span><br><span class="line">&#123;</span><br><span class="line">    Type = ModuleType.External;</span><br><span class="line"></span><br><span class="line">    if (Target.Platform == UnrealTargetPlatform.Win64)</span><br><span class="line">    &#123;</span><br><span class="line">        // Add the import library</span><br><span class="line">        PublicLibraryPaths.Add(Path.Combine(ModuleDirectory, &quot;x64&quot;, &quot;Release&quot;));</span><br><span class="line">        PublicAdditionalLibraries.Add(&quot;ExampleLibrary.lib&quot;);</span><br><span class="line"></span><br><span class="line">        // Delay-load the DLL, so we can load it from the right place first</span><br><span class="line">        PublicDelayLoadDLLs.Add(&quot;ExampleLibrary.dll&quot;);</span><br><span class="line">        // RuntimeDependencies.Add(new RuntimeDependency(Path.Combine(ModuleDirectory,  &quot;x64&quot;, &quot;Release&quot;, &quot;ExampleLibrary.dll&quot;)));</span><br><span class="line">        // RuntimeDependencies.Add(dll_path);</span><br><span class="line">        string dll_runtimePath = Path.Combine(ModuleDirectory, &quot;..&quot;, &quot;..&quot;, &quot;..&quot;, &quot;Binaries&quot;, &quot;ThirdParty&quot;, &quot;test1Library&quot;, &quot;Win64&quot;, &quot;ExampleLibrary.dll&quot;);</span><br><span class="line">        RuntimeDependencies.Add(dll_runtimePath);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(Target.Platform == UnrealTargetPlatform.Mac)</span><br><span class="line">    &#123;</span><br><span class="line">        PublicDelayLoadDLLs.Add(Path.Combine(ModuleDirectory, &quot;Mac&quot;, &quot;Release&quot;, &quot;libExampleLibrary.dylib&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 第一眼看上去全是懵的，这都是啥？直到现在我也没有能全理解。但是大体的内容我猜的就是保证第三方库的位置。按照代码中的路径依次填充准备好的dll文件，虽然lib文件也设置了，但是估计也不会用到，用的时候再说，此次首要目的是打包dll文件。至于其他的平台的设置，根据要求把。这里重要的是加入了<code>RuntimeDependencies</code>这个依赖项。</p>
<ol>
<li>这个依赖项的内容或许会在上面的<strong>UnrealBuildTool</strong>章节中详细展开，或者下面的<strong>各种验证</strong>章节中展开。</li>
<li>这一部分主要是对dll进行配置，添加依赖项，保证dll在打包过后依然存在，同时也可以在这个<strong>Module</strong>(Module的概念参考上面，我的理解就是<strong>每一个Module都需要一个Build.cs文件</strong>)里加入dll的源码或者dll的源文件，但是如果加了源文件并且使用了源码的话，那么使用dll的意义应该也不存在了吧。</li>
</ol>
</li>
<li><p>插件源码配置。这个部分是对dll的内容进行调用的，或者说为dll的调用提供接口。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文件结构</span><br><span class="line">Source</span><br><span class="line">   |- PluginModule</span><br><span class="line">         |- Private</span><br><span class="line">         |- Public</span><br><span class="line">         |- PluginModule.Build.cs</span><br><span class="line">   |- ThirdParty</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何制作一个扩展插件。这个需求我不知道要如何来描述为好，总之就是上面的插件Module为我们提供了调用接口后，我要如何在另外一个Module中调用这个接口。即如何在工程的主Module中使用扩展的插件Module中的接口。</p>
<ul>
<li><p><a href="https://wiki.unrealengine.com/An_Introduction_to_UE4_Plugins" target="_blank" rel="noopener">An Introduction to UE4 Plugins</a></p>
<p>这个是一个神一样的Wiki，手把手教你制作一个plugin或者说是扩展的Module。跟这篇我完全不知道在讲什么的<a href="https://wiki.unrealengine.com/Linking_Static_Libraries_Using_The_Build_System" target="_blank" rel="noopener">Linking Static Libraries Using The Build System</a>的这篇Wiki比起来真是一个天上一个地上。不少老外都在diss这篇。</p>
</li>
</ul>
</li>
</ol>
<p>当我差不多理解了上面的内容，也成功的让我的dll在打包后也成功输出了。但我还是想吐槽一句，UE4 的编译系统（UBT）这个东西让我这个初学者感觉到了恶心。为什么，为什么我找不到这个东西具体的Manual？还要去看各种UE4引擎的源码去猜呢？</p>
<ul>
<li><a href="https://tubezgames.com/2017/01/ue4-plugin-build/" target="_blank" rel="noopener">【UE4】プラグインのTypeをRuntimeにしたのにShippingでパッケージ化するとロードされないとき</a></li>
<li><a href="http://historia.co.jp/archives/6717/" target="_blank" rel="noopener">［UE4］プラグインをパッケージ化しよう！</a></li>
</ul>
<h3 id="各种验证，各种现象"><a href="#各种验证，各种现象" class="headerlink" title="各种验证，各种现象"></a>各种验证，各种现象</h3><h4 id="RunTimeDependencies-Add-String-path"><a href="#RunTimeDependencies-Add-String-path" class="headerlink" title="RunTimeDependencies.Add(String path)"></a>RunTimeDependencies.Add(String path)</h4><p>这个东西加进去的，首先要保证路径正确由函数名字就可以明白这个是为dll库添加运行时依赖的，也就是确保运行时按照这个路径下能找到dll文件。但是这里有需要注意的问题。这个依赖项的作用，据我简单实验观察得到的结果是</p>
<ul>
<li><strong>被路径指定的文件在打包后会被一起打包</strong></li>
</ul>
<p>这非常重要。因为非常头疼的事情就是在打包的时候，dll并没有被带上。自己copy进去？我没有实验过不知道好不好用，但是肯定是会被打的。</p>
<p>比如说上面的例子中按照该路径添加了这个依赖，那么在打包后，这个路径就会被保存下来，当然文件也会存在，而之后的代码中按照原本的路径来取得dll也是没有问题的。</p>
<p>那么这里就有了路径留哪个文件夹的问题。<strong>Binaries？Source？</strong></p>
<p>个人倾向于Binaries文件夹，毕竟dll算是2进制文件，放到这个文件夹里不会产生歧义。但是第三方库的生成往往不是UE4的工作，而是VS中编译好（参考上面）生成。我只好在binaries文件夹的相应路径中复制一份。（Source里更倾向于放置源码，放进去源码的话貌似也可以使用，毕竟都一样嘛）</p>
<p><strong>这个依赖非常关键，它让你的dll在工程打包的时候能够一起被打包。</strong></p>
<p>在我写下这么多文字的时候，就隐隐约约的察觉到了一个问题。我是因为写好的插件直接就放在了一个叫<code>Plugins</code>的文件夹里面了，与这个插件相对的Build.cs文件是一点都没有写。上面提到的又是扩展插件又是Module的，在一个Module里面提供dll的调用接口，为什么我现在工作的Module里不能提供？</p>
<p>肯定是可以的。原因应该就是我没有给自己的Plugin文件写任何的编译依赖，导致没有没打包。若是被打包进工程，能找到dll的话肯定能使用了啊。</p>
<p>关键就是上面的这个依赖项的添加。</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/1364966-packaging-plugin-with-third-party-dll" target="_blank" rel="noopener">Packaging Plugin with third party Dll</a></li>
<li><a href="https://answers.unrealengine.com/questions/218616/how-do-i-add-thirdparty-library.html" target="_blank" rel="noopener">How do I add thirdparty library?</a></li>
<li><a href="https://answers.unrealengine.com/questions/197667/how-do-you-statically-link-an-external-dlldylib-to.html" target="_blank" rel="noopener">How do you statically link an external DLL/dylib to your project?</a></li>
<li><a href="http://www.valentinkraft.de/including-the-point-cloud-library-into-unreal-tutorial/" target="_blank" rel="noopener">UNREAL ENGINE: INCLUDING A THIRD-PARTY LIBRARY (ON THE EXAMPLE OF THE POINT CLOUD LIBRARY AND BOOST) [TUTORIAL] [DOWNLOAD]</a></li>
<li><a href="https://answers.unrealengine.com/questions/427772/adding-dll-path-for-plugin.html?sort=oldest" target="_blank" rel="noopener">Adding third party DLL path for plugin</a></li>
</ul>
<p>为了搞懂如何打包第三方库，以及做了各种的实验所参考的文章。</p>
<ul>
<li><a href="https://usagi.hatenablog.jp/entry/2018/03/14/082509" target="_blank" rel="noopener">UE4: バイナリー配布や実行時リンク向けのライブラリーを UE4 プロジェクトへ組み入れる方法を mecab で解説</a></li>
<li><a href="https://www.parallelcube.com/2018/03/01/using-thirdparty-libraries-in-our-ue4-mobile-project/" target="_blank" rel="noopener">Using thirdparty libraries in our UE4 mobile/desktop project</a></li>
<li><a href="https://qiita.com/T_Sumisaki/items/b5f01fc7c61330c0a38f" target="_blank" rel="noopener">UE4のカスタムプラグイン作成時におけるThirdPartyライブラリの取り込み方</a></li>
<li><a href="https://www.slideshare.net/GerkeMaxPreussner/plugins-thirdparty-sdks-in-ue4" target="_blank" rel="noopener">Plug-ins &amp; Third-Party SDKs in UE4</a></li>
<li><a href="https://qiita.com/BlackMa9/items/38701d6b4122b966975c" target="_blank" rel="noopener">UE4でのPlugin開発記録メモ(FMessageDialogでダイアログ表示編)</a></li>
</ul>
<p>还有就是感谢UE4的源码了，我翻了许多源码内的各种插件的使用，终于脑海里有了大概的印象。</p>
<h4 id="IpluginManager-Get"><a href="#IpluginManager-Get" class="headerlink" title="IpluginManager::Get()"></a>IpluginManager::Get()</h4><p>这个类是干什么的以后补上，我见到的是用它来取得Plugins的路径：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString BaseDir = IPluginManager::Get().FindPlugin(<span class="string">"PluginName"</span>)-&gt;GetBaseDir();</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是使用这个类的时候除了要补上头文件<code>#include IPluginManager.h</code>之外，还要把依赖加进Module里面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrivateDependencyModuleNames.AddRange(new string[] &#123; &quot;Projects&quot; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>要不然项目编译不会通过。</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/745481/ipluginmanagerget-linker-error-not-finding-impleme.html" target="_blank" rel="noopener">IPluginManager::Get() Linker error - Not finding implementation</a></li>
</ul>
<h4 id="C-SYstem-IO-SetAttributes"><a href="#C-SYstem-IO-SetAttributes" class="headerlink" title="C# SYstem.IO.SetAttributes"></a>C# SYstem.IO.SetAttributes</h4><ul>
<li><a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.file.setattributes?view=netframework-4.8" target="_blank" rel="noopener">File.SetAttributes(String, FileAttributes) Method</a></li>
</ul>
<h4 id="Json数据解析"><a href="#Json数据解析" class="headerlink" title="Json数据解析"></a>Json数据解析</h4><ul>
<li><a href="https://orfeasel.com/parsing-json-files/" target="_blank" rel="noopener">Parsing Json files</a></li>
</ul>
<h4 id="各种路径获取"><a href="#各种路径获取" class="headerlink" title="各种路径获取"></a>各种路径获取</h4><ul>
<li><a href="https://wiki.unrealengine.com/Packaged_Game_Paths,_Obtain_Directories_Based_on_Executable_Location" target="_blank" rel="noopener">Packaged Game Paths, Obtain Directories Based on Executable Location</a></li>
</ul>
<h5 id="获取绝对路径"><a href="#获取绝对路径" class="headerlink" title="获取绝对路径"></a>获取绝对路径</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString RelativePath = FPaths::GameContentDir();</span><br><span class="line"> </span><br><span class="line"> FString FullPath = IFileManager::Get().ConvertToAbsolutePathForExternalAppForRead(*RelativePath);</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://answers.unrealengine.com/questions/580005/getting-full-path-of-project-directory.html" target="_blank" rel="noopener">Getting full path of project directory</a></li>
</ul>
<h4 id="文件夹创建"><a href="#文件夹创建" class="headerlink" title="文件夹创建"></a>文件夹创建</h4><ul>
<li><a href="https://wiki.unrealengine.com/File_Management,_Create_Folders,_Delete_Files,_and_More" target="_blank" rel="noopener">File Management, Create Folders, Delete Files, and More</a></li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="DLL中头文件的引入"><a href="#DLL中头文件的引入" class="headerlink" title="DLL中头文件的引入"></a>DLL中头文件的引入</h2><p>在使用<strong>plog</strong> 源码的时候尝试引入头文件的地方：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;plog/Util.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面的引入会出错，而把尖括号换成双引号后就好了。</p>
<p>关于这两者的区别：</p>
<ul>
<li>用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，要视具体的情况而定。</li>
<li>用双引号来指定文件时，预处理器是以“由实现定义的的方式”来寻找文件。它通常是从当前的目录开始寻找，如果没有找到，那么include命令就按与尖括号同样的方式开始寻找。</li>
</ul>
<p>要说DLL不支持尖括号的查找也不是，内置的一些库还是可以使用尖括号来include的，难不成自己添加的文件就要使用双引号吗？</p>
<p>另外关于头文件返回上一级路径的写法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../Util.h"</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="函数名字前面加上-amp"><a href="#函数名字前面加上-amp" class="headerlink" title="函数名字前面加上&amp;"></a>函数名字前面加上&amp;</h2><blockquote>
<p>In C++, when the ref-sign(&amp;) is used before the function name in the declaration of a function it is associated with the return value of the function and means that the function will return by reference.</p>
</blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/23776784/use-of-operator-before-a-function-name-in-c" target="_blank" rel="noopener">Use of ‘&amp;’ operator before a function name in C++</a></li>
</ul>
<h2 id="C-类构造函数初始化列表"><a href="#C-类构造函数初始化列表" class="headerlink" title="C++类构造函数初始化列表"></a>C++类构造函数初始化列表</h2><ul>
<li><a href="https://www.learncpp.com/cpp-tutorial/8-5a-constructor-member-initializer-lists/" target="_blank" rel="noopener">Constructor member initializer lists</a></li>
</ul>
<p>可以参照以上的文章，主要是可以在声明的同时初始化，在构造函数里面的知只是赋值操作，不是所谓的初始化。</p>
<p>比如说类中想要拥有const类型的变量的话，可以利用构造函数的初始化函数列表来给类中常量赋初值。</p>
<h2 id="C-中的函数指针"><a href="#C-中的函数指针" class="headerlink" title="C++中的函数指针"></a>C++中的函数指针</h2><h2 id="C-运算符重载"><a href="#C-运算符重载" class="headerlink" title="C++运算符重载"></a>C++运算符重载</h2><h2 id="C-中的流"><a href="#C-中的流" class="headerlink" title="C++中的流"></a>C++中的流</h2><p>要把流与字符串分开来看，流是对象，可以用来处理字符串。</p>
<h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><h3 id="st-c-str-函数"><a href="#st-c-str-函数" class="headerlink" title="st(), c_str()函数"></a>st(), c_str()函数</h3><h2 id="深入理解char-与char-的差别"><a href="#深入理解char-与char-的差别" class="headerlink" title="深入理解char*与char[]的差别"></a>深入理解char*与char[]的差别</h2><h2 id="关于类中静态成员的理解"><a href="#关于类中静态成员的理解" class="headerlink" title="关于类中静态成员的理解"></a>关于类中静态成员的理解</h2><p>这里需要强调理解的是，类中静态成员的存储位置是静态存储区，只有一个拷贝，无论类被实例化了多少个，静态成员只有一个，还有一些其他的重要的使用方式，之后整理。</p>
<h2 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h2><ul>
<li><a href="https://hakobe932.hatenablog.com/entry/20090104/1231073299" target="_blank" rel="noopener">よくみる extern “C” {} と __cplusplus - はこべにっき</a></li>
</ul>
<h2 id="mutex-lock"><a href="#mutex-lock" class="headerlink" title="mutex::lock"></a>mutex::lock</h2><ul>
<li><a href="https://cpprefjp.github.io/reference/mutex/mutex/lock.html" target="_blank" rel="noopener">mutex::lock - cpprefjp C++日本語リファレンス</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中得到函数名字</title>
    <url>/C++%E4%B8%AD%E5%BE%97%E5%88%B0%E5%87%BD%E6%95%B0%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<p>应某个要求，需要在运行过程中打印出运行的信息，即所谓的LOG收集，此时希望一起打印出来的内容包含调用的函数信息。</p>
<a id="more"></a>
<p>在Python中就有这种库，直接能得到函数的调信息名字全部打印出来。但是在C++中就没有现成的库。</p>
<p>自己创建一个库？对我来说还是太早了。</p>
<h2 id="在C-中得到函数名字"><a href="#在C-中得到函数名字" class="headerlink" title="在C++中得到函数名字"></a>在C++中得到函数名字</h2><ul>
<li><p><code>__func__</code>可以得到函数名字。在函数里面调用输出就好。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString fun_name = FString(UTF8_TO_CHAR(__func__));</span><br><span class="line"></span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"Function name is : %s), *fun_name);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__FUNCTION__</code>可以得到类名加函数名。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">FString func_name = FString(UTF8_TO_CHAR(__FUNCTION__));</span><br><span class="line"></span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"Function name is : %s), *func_name);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以上是在UE4引擎中输出的结果，也有试过<code>__PRETTY_FUNCTION__</code>来输出但是出现了编译错误。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://gcc.gnu.org/onlinedocs/gcc/Function-Names.html" target="_blank" rel="noopener">6.49 Function Name as Strings</a></li>
<li><a href="https://codeyarns.com/2018/08/22/how-to-get-function-name-in-c/" target="_blank" rel="noopener">How to get function name in C++</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveC++-Chapter01-Accustoming-Yourself-to-C++</title>
    <url>/EffectiveC++-Chapter01-Accustoming-Yourself-to-C++/</url>
    <content><![CDATA[<p>Effective C++的第一章内容总结。</p>
<a id="more"></a>
<h2 id="条款01：View-C-as-a-federation-of-languages-视C-为一个语言联邦"><a href="#条款01：View-C-as-a-federation-of-languages-视C-为一个语言联邦" class="headerlink" title="条款01：View C++ as a federation of languages.(视C++为一个语言联邦)"></a>条款01：View C++ as a federation of languages.(视C++为一个语言联邦)</h2><ul>
<li><strong>C</strong></li>
<li><strong>Object-Oriented C++</strong></li>
<li><strong>Templete C++</strong></li>
<li><strong>STL</strong></li>
</ul>
<blockquote>
<p>例如对内置（也就是C-like）类型而言<em>pass-by-value</em>通常比<em>pass-by-reference</em>高效，但当你从<strong>C part of C++</strong>移往<strong>Object-Oriented C++</strong>，由于用户自定义的（user-defined)构造函数和析构函数的存在，<em>pass-by-reference-to-const</em>往往更好。运用Template C++时尤其如此，因为彼时你甚至不知道所处理的对象的类型。然而一旦跨入STL你就会了解，迭代器和函数对象都是在C指针之上塑造出来的，所以对STL的迭代器和函数对象而言，旧式的<em>C pass-by-value</em>守则再次适用（参数传递方式的选择细节请见条款20）。</p>
</blockquote>
<h2 id="条款02：Prefer-consts-enums-and-inlines-to-define-尽量以const-enum-inline替换-define"><a href="#条款02：Prefer-consts-enums-and-inlines-to-define-尽量以const-enum-inline替换-define" class="headerlink" title="条款02：Prefer consts,enums,and inlines to #define.(尽量以const,enum,inline替换#define)"></a>条款02：Prefer consts,enums,and inlines to #define.(尽量以const,enum,inline替换#define)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; NumTurns = <span class="number">5</span>&#125;;  <span class="comment">// "the enum hack"补偿作法。以保证NumTurns在编译期间有正确的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];  <span class="comment">// 本是定义的地方，NumTurns未必会有初值，编译器也许会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基于数个理由enum hack值得我们认识。第一，enum hack的行为某方面说较像#define而不像const，有时候这正是你想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法而取一个#define的地址通常也不合法。</p>
<p>认识enum hack的第二个理由纯粹是为了实用主义。许多代码用了它，所以看到它是你必须认识它。事实上，“enum hack”是<em>template metaprogramming</em>(模板元编程)的基础技术。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; f(b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐的写法</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callwithmax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用template inline函数（见条款30）也可以获得类似宏带来的效率以及一般函数所有可预料行为和类型安全性（type safety）。</p>
<p>请记住：</p>
<ul>
<li>对于单纯常量，最好以const对象或enums替换#define</li>
<li>对于形似函数的宏（macs），最好改用inline函数替换#define</li>
</ul>
<h2 id="条款03：Use-const-whenever-possible-尽可能使用const"><a href="#条款03：Use-const-whenever-possible-尽可能使用const" class="headerlink" title="条款03：Use const whenever possible(尽可能使用const)"></a>条款03：Use const whenever possible(尽可能使用const)</h2>]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectC++-导读</title>
    <url>/EffectiveC++-%E5%AF%BC%E8%AF%BB/</url>
    <content><![CDATA[<p>Effective C++ 的导读章节的内容整理，知识点备忘吧。应该会将以后的章节归档到一起。</p>
<a id="more"></a>
<h2 id="术语（Terminology"><a href="#术语（Terminology" class="headerlink" title="术语（Terminology)"></a>术语（Terminology)</h2><p>关于<em>声明</em>与<em>定义</em>应该有了初步的认识，在其他的C++学习章节有提到过这之间的区分。</p>
<blockquote>
<p>定义式(definition)的任务是提供编译器一些声明式所遗漏的细节。对对象而言，定义式是编译器为此编译器拨内存的起点。</p>
</blockquote>
<p>这里有一个对于初始化(initialization)的default构造函数的认知误区：</p>
<ul>
<li>default构造函数是一个可被调用而不带任何实参</li>
<li>这样的构造函数要不没有参数，要不就是每个参数都有缺省值</li>
</ul>
<p><strong>不是说构造函数就是没有参数的。</strong></p>
<h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>应用场景：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(inx x)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在构造函数的前面加上explicit关键字可以防止被用来执行<em>隐式类型转换(implicit type conversions)</em>，但是仍可以被用来进行<em>显式类型转换(explicit type cnversions)</em>.</p>
<p>比如说传参的时候，参数应该是一个类型B的对象<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>;</span><br><span class="line"></span><br><span class="line">B bObj1;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);   <span class="comment">// 错误，int跟B之间没有隐式类型转换</span></span><br><span class="line"></span><br><span class="line">doSomething(B(<span class="number">28</span>));  <span class="comment">// 正确，有显式转型，即cast</span></span><br></pre></td></tr></table></figure></p>
<p>虽然上述的使用是我之前知道的但是不知道为什么是正确的。为了防止构造函数被隐式类型转换，把构造函数声明为explicit是一个好的选择。</p>
<h3 id="copy构造函数和copy-assignment操作符"><a href="#copy构造函数和copy-assignment操作符" class="headerlink" title="copy构造函数和copy assignment操作符"></a>copy构造函数和copy assignment操作符</h3><ul>
<li>copy构造函数被用来“以同型对象初始化自我对象”</li>
<li>copy assignment操作符被用来“从另一个同型对象中拷贝其值到自我对象”</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();                                 <span class="comment">// 默认构造函数</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget&amp; rhs);                <span class="comment">// copy构造函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs);     <span class="comment">// copy assignment操作符</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget w1;         <span class="comment">// 调用默认构造函数</span></span><br><span class="line">Widget w2 = w1;    <span class="comment">// 调用copy构造函数</span></span><br><span class="line">w1 = w2;           <span class="comment">// 调用copy assignment操作符</span></span><br></pre></td></tr></table></figure>
<p>上述的代码应该足够说明用法，但是需要注意的是看见<code>=</code>的时候要注意：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget w3 = w2;    <span class="comment">// 调用copy构造函数</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>幸运的是“copy构造函数”很容易个“copy赋值”有所区别。如果一个对象被定义（例如以上语句中的w3)，一定会有一个构造函数被调用，不可能调用赋值操作。如果没有新对象被定义（例如前述的“w1=w2”语句），就不会有构造函数被调用，那么当然是赋值操作被调用。</p>
</blockquote>
<h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><h3 id="TR1和Boost"><a href="#TR1和Boost" class="headerlink" title="TR1和Boost"></a>TR1和Boost</h3><p><a href="https://www.boost.org" target="_blank" rel="noopener">Boost</a></p>
]]></content>
      <categories>
        <category>Effective C++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程思想手抄</title>
    <url>/C++%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%89%8B%E6%8A%84/</url>
    <content><![CDATA[<p>好久没有看书了，最近重拾看书的习惯，放着一大本的全局光照技术不看，想看看C++的内容。因为最近在调查一个工具，看那个人写的源码，深入看下去发现这个人写的代码是真的很好，跟我之前所在现场的时候看见的那个架构十分相似，但是一个是C#，一个是C++。</p>
<a id="more"></a>
<p>想要把那份源码记在脑子里似的，希望能够多过几遍，之后肯定会用的上的。</p>
<p>所以言归正传，聊聊现在看的书，C++编程思想。我会记下来我觉得非常有意义的话语，多看多读，能够印在脑子里面是最好，因为有些东西知道了就想会在代码中潜移默化的表现出来。</p>
<h1 id="第一章-对象导言"><a href="#第一章-对象导言" class="headerlink" title="第一章 对象导言"></a>第一章 对象导言</h1><blockquote>
<p>在面向对象的程序设计中，答案是非常新奇的：编译器不做传统意义上的函数调用。由非OOP编译器产生的函数调用会导致与被调用代码的<em>早捆绑(early binding)</em>，对于这一术语，读者可能还没有听说过，因为从来没有想到过它。早捆绑的意思是，编译器会对特定的函数名产生调用，而连接器将这个调用解析为要执行代码的绝对地址。在OOP中直到程序运行时，编译器才能确定执行代码的地。所以，当消息被发送给一般对象时，需要采用其他的方案。</p>
<p>为了解决这一问题，面向对象语言采用<em>晚捆绑(late binding)</em> 的思想。当给对象发送消息时，在程序运行的时候才去确定调用的代码。编译器保证这个被调用的函数存在，并执行参数和返回类型的检查【其中不采用这种处理方式的语言称为<em>弱类型(weakly typed)</em> 语言】，但是它并不知道将执行的确切代码。</p>
<p>为了执行晚捆绑，C++编译器在真正调用的地方插入一段特殊的代码。通过使用存放在对象自身中的信息，这段代码在运行时计算被调用函数函数体的地址（这一过程将在15章中详细介绍）。这样每个对象就能根据这段二进制的内容有不同的行为。当一个对象接收到消息时，它根据这个消息判断应该做什么。</p>
<p>我们可以用关键字<strong>virtual</strong>声明他希望某个函数有晚捆绑的灵活性。我们并不需要懂得<strong>virtual</strong>的使用机制，但是没有它，我们就不能用C++进行面向对象的程序设计。在C++中，必须记住添加<strong>virtual</strong>关键字，因为根据规定，默认情况下成员函数不能动态捆绑。virtual函数（虚函数）可用来表示出现在相同家族中的类具有不同的行为。这些不同是产生多态行为的原因。</p>
</blockquote>
<p>上面的话对我从新理解C++的面向对象的程序的理解是有帮助的。</p>
<p>比如说这段话对于<em>virtual</em>的理解，不是说遇到这种情况的话需要使用<code>virtual</code>关键字，而是清楚地描述了这种情况下，<code>virtual</code>关键字可以帮助我们来实现。以前只是知道这个关键字是用来声明虚函数，但是为什么要声明虚函数呢，什么情况下声明虚函数却不清楚。 </p>
<h1 id="第二章-对象的创建与使用"><a href="#第二章-对象的创建与使用" class="headerlink" title="第二章 对象的创建与使用"></a>第二章 对象的创建与使用</h1><p>这一章虽然都是大白话，但是对于底层的描述说到底还是不是完全理解的，所以需要细致的去理解。</p>
<h2 id="2-1-语言的翻译过程"><a href="#2-1-语言的翻译过程" class="headerlink" title="2.1 语言的翻译过程"></a>2.1 语言的翻译过程</h2><p>计算机语言转化为机器指令需要翻译器</p>
<blockquote>
<p>通常，翻译器分为两类：<em>解释器（interpreter）</em>和<em>编译器（compiler）</em>。</p>
</blockquote>
<p>为什么要录下这段话是因为我以为翻译器只有编译器一种呢。Python使用的就是解释器。而C++使用的就是编译器。虽然解释器与编译器之间的界限也很模糊（听说的）。</p>
<p>但是C++的重点在与编译器的理解上。我也有一个独立写一个编译器的梦想……</p>
<h3 id="2-1-3-编译过程"><a href="#2-1-3-编译过程" class="headerlink" title="2.1.3 编译过程"></a>2.1.3 编译过程</h3><p>关于编译的过程我看的是云里雾，所以详细了调查了一些文章。</p>
<ul>
<li><a href="http://nethack4.org/blog/building-c.html" target="_blank" rel="noopener">Building C Projects - Alex Smith</a>关于编译过程的详细说明<ul>
<li>1.Configuration（配置）<ul>
<li>用户系统环境配置的详细参数信息。以便编译器适应不同的用户环境配置。</li>
</ul>
</li>
<li>2.Standard dircetor detection（确定标准库位置）</li>
<li>3.Source file dependency calculation（确定依赖关系）</li>
<li>4.Header file location（确定头文件位置）</li>
<li>5.Header precompilation（头文件的预编译）</li>
<li>6.Preprocessing（预处理）</li>
<li>7.Compilation and assembly（编译）</li>
<li>8.Object file dependency calculation</li>
<li>9.Linking（连接）<ul>
<li>编译器把外部函数的代码添加到可执行文件中。<em>静态连接</em> 与 <em>动态连接</em>。</li>
</ul>
</li>
<li>10.Installing（安装）</li>
<li>11.Resource linking</li>
<li>12.Package generation（生成安装包）</li>
<li>13.Dynamic linking（动态连接）</li>
</ul>
</li>
</ul>
<p>时间关系就直接把编译过程的大概列出来吧。</p>
<blockquote>
<p>某些语言（特别是C/C++）编译时，首先要对源代码进行预处理，<em>预处理器（preprocesser）</em> 是一个简单的程序，它用程序员（利用预处理器指令）定义好的模式代替源代码中的模式。预处理指令用来节省输入，增加代码的可读性。（C++程序设计并不鼓励多使用预处理指令，因为他可能引起一些不易发现的错误，这些将在本书的后面分析。）预处理过的代码通常放在一个中间文件中。</p>
<p>编译一般分两遍进行。首先，对预处理过的代码进行语法分析。编译器把源代码分解成小的单元，并把它们按树形结构组织起来。表达式“A+B”中的“A”，“+”和“B”就是语法分析树的叶子节点。</p>
<p>有时会在编译的第一遍和第二遍之间使用<em>全局优化器（global optimizer）</em> 来生成更短，更快的代码。</p>
<p>编译的第二遍，由<em>代码生成器（code generator）</em> 遍历语法分析树，把树的每个节点转化成汇编语言或机器代码。如果代码生成器生成的是汇编语言，那么还必须用汇编器对其汇编。两种情况的最终结果都是生成目标模块（通常是一个以<code>.o</code>或<code>.obj</code>为扩展名的文件）。有时也会在第二遍中使用<em>窥孔优化器（peephole optimizer）</em> 从相邻一段代码中查找冗余语句。</p>
</blockquote>
<p>上述内容大致描述了编译过程，应该还涉及到了许多之前尚未完全理解的内容吧。</p>
<h2 id="2-2-分段编译工具"><a href="#2-2-分段编译工具" class="headerlink" title="2.2 分段编译工具"></a>2.2 分段编译工具</h2><blockquote>
<p>程序可由多个文件构成，一个文件中的函数可能要访问另一个文件中的函数和数据。编译一个文件时，C或C++编译器需要知道在另一个文件中的函数和数据，特别是它的名字和基本用法，编译器就是要确保函数和数据被正确的使用。”告知编译器“外部函数和数据的名称及它们的模样，这一过程就是<em>声明（declaration）</em> 。一旦声明了一个函数或变量，编译器知道怎样检查对它们的引用，以确保引用正确。</p>
</blockquote>
<p>这一段话告知了声明这一概念，为什么需要声明，声明用来做什么的。声明就是像编译器告知外部自己的存在以及如何使用自己。</p>
<h3 id="2-2-1-声明与定义"><a href="#2-2-1-声明与定义" class="headerlink" title="2.2.1 声明与定义"></a>2.2.1 声明与定义</h3><p>之前从未对这两个概念进行细致的区分，或者说根本没有去注意。理解这两个概念会发现，这两个概念，还蛮重要的…</p>
<blockquote>
<p><em>声明（declaration）</em> 是向编译器介绍名字-标识符。它告诉编译器“这个函数或这个变量在某处可以找到，它的模样像什么”。而<em>定义（definition）</em> 是说：“在这里建立变量”或“在这里建立函数”。它为名字分配存储空间。无论定义的函数还是变量，编译器都要为它们在定义点分配存储空间。对于变量，编译器确定变量的大小。，然后在内存中开辟空间来保存量的数据。对于函数，编译器会产生代码，这些代码最终也要占用一些内存。</p>
</blockquote>
<p>上面的内容说明了声明跟定义的区别。声明就好比开店之前的宣传，编译器拿着传单知道了这家店的信息，使用情报，而定义就是真正的开店开业，是在上述传单的描述中真实存在的一家店。</p>
<blockquote>
<p>在C/C++中，可以在不同的地方声明相同的变量和函数，但是只能有一个定义【有时这称为<em>ODR（one-defifition rule,单一定义规则）</em>】。当连接器连接所有的目标模块时，如果发现一个函数或变量有多个定义，连接器将报告出错。</p>
</blockquote>
<p>相同的变量或函数可以多次声明，但是定义只能有一次。</p>
<blockquote>
<p>定义也可以是声明。如果定义<code>int x;</code>之前，编译器没有发现标识X，编译器则把这一标识符看成是声明并立即为它分配存储空间。</p>
</blockquote>
<h4 id="2-2-1-4变量声明的语法"><a href="#2-2-1-4变量声明的语法" class="headerlink" title="2.2.1.4变量声明的语法"></a>2.2.1.4变量声明的语法</h4><p>关于变量的声明，由于文章的说明有些多，直接写下自己的理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p>这只是一个非常常见的变量声明，这是声明？还是定义？</p>
<blockquote>
<p>这段代码有足够的信息让编译器为整数a分配空间，而且编译器也确实给整数a分配了空间。要解决这个矛盾，对于C/C++需要一个关键字来说明“这只是一个声明，它的定义在别的地方”。这个关键字就是<code>extern</code>，它表示变量是在文件以外定义的，或在文件后面部分才定义。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;  <span class="comment">//声明一个变量但是不定义它</span></span><br></pre></td></tr></table></figure>
<p>结果就是，对于变量来说简单的声明所提供的情报足以让编译器为其定义。想要停止这种编译器自动的行为就需要使用<code>extern</code>关键字来告诉编译器说我要晚一点再定义这个变量，你先知道有这么个变量就行了。</p>
<p>对于函数来说又是什么样子的呢？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span></span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> length, <span class="keyword">int</span> width)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两种声明方式有区别吗？</p>
<blockquote>
<p>因为没有函数体，编译器必定把它作为声明而不是函数定义。<code>extern</code>关键字对函数来说是多余的，可选的。C语言的程序设计者并不要求函数声明使用extern，这可能有些令人遗憾；</p>
</blockquote>
<p>无论加还是不加，编译器都认为这种定义方式都没有足够的信息去定义一个函数，因此都会被视为声明。通过理解<em>声明</em>与<em>定义</em>的区别，应该可以灵活运用函数与变量的出现位置。</p>
<p>关于extern关键字使用的拓展，目的是加深理解这个关键字的作用。参看文章</p>
<ul>
<li><a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html" target="_blank" rel="noopener">C/C++中的extern关键字详解</a></li>
</ul>
<p><strong>extern</strong>除了告诉编译器这只是一个声明之外，还有一个作用是跟<code>&quot;C&quot;</code>一起连用的时候，是告诉编译器按照C的规则来办事。比如说下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;  <span class="comment">//出于上述的文章中的描述</span></span><br></pre></td></tr></table></figure>
<p>按照C的规则来翻译这个声明的函数，貌似按照C++的翻译规则，编译器会将函数名变得跟<code>fun</code>不一样，要看编译器的”脾气”。这个跟C++的函数重载特性有关。<br>下面的内容全是选自上面的文章：</p>
<ul>
<li><p>extern变量</p>
<ul>
<li><p>在一个源文件里定义了一个数组:<code>char a[6];</code>在另一个文件里声明<code>extern char *a;</code>  这种声明可以吗？</p>
<ul>
<li><p>答案是不可以。程序运行会告诉你非法访问。原因是类型不同，<em>指向类型T的指针并不等价于类型T的数组</em>，不难发现，这是指针与数组使用中经常出现的盲区知识，若是对于指针的理解只有半吊子的水平还喜欢炫耀的话就会在此栽跟头。正确的声明应该是:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> a[];</span><br></pre></td></tr></table></figure>
<p>在使用<strong>extern</strong>的时候应该严格对应声明的格式。</p>
</li>
</ul>
</li>
<li>extern常常被用作全局变量来使用，利用其这种特性，在<code>.h</code>文件中使用extern来声明。</li>
</ul>
</li>
<li><p>extern “C”</p>
<ul>
<li>C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用`extern “C进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。</li>
<li>这应该是在C++环境中使用C函数的时候应该注意的问题。</li>
</ul>
</li>
<li><p>extern函数声明</p>
<ul>
<li>原文中举了一个例子，总的来说就是extern对于函数来说就像上文提到的可加可不加，没有明显的区别，仅仅就是一个暗示，可能这个函数会在别的源文件里面定义。</li>
<li>当把全局变量的声明跟定义放在一起的时候，会因为<code>#include</code>的存在而产生重复定义的链接错误。所以：<strong>只在头文件中做声明，真理就是这么简单</strong>。当然不使用<code>#include</code>语句，将想要提供给外部接口的函数和变量全部使用<code>extern</code>来修饰也是一种方法。你用么，反正我不用。</li>
</ul>
</li>
<li><p>extern和static</p>
<ul>
<li>（1）extern表明该变量在别的地方已经定义过了，这里要使用那个变量。</li>
<li>（2）static表示静态的变量，分配内存的时候，存储在静态区，不存储在栈上面。</li>
<li><p>stati作用范围是内部连接的关系，跟extern一样，修饰的部分是跟对象分开存储的，但是却不能被其他对象引用，而extern可以。static修饰的变量只允许对象本身使用。具体差别首先：static跟extern是一对”水火不容”的家伙，也就是说，<strong>extern和static不能同时修饰一个变量</strong>；其次，<strong>static修饰的全局变量声明与定义同时进行</strong>，也就是说你在头文件中使用static声明了全局变量之后，它同时被定义了；最后，<strong>static修饰的全局变量的作用域只能是本事的编译单元</strong>，也就是说它的全局只对本编译单元有效，其他编译单元则看不到它。如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test1.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> g_str[] = <span class="string">"123456"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;g_str&lt;&lt;<span class="built_in">endl</span>;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;g_str&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>以上的两个编译单元可以连接成功，你可以在各自的<code>.obj</code>文件中找到字符串<code>&quot;123456&quot;</code>的存在。<strong>虽然它们有相同的内容，但是存储的物理地址并不一样</strong>，就像是两个不同的变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。</p>
</li>
<li><strong>一般定义static全局变量的时候，都把它放在原文件中而不是头文件</strong>，这样就不会给其他模块造成不必要的信息污染。</li>
</ul>
</li>
<li><p>extern和const</p>
<ul>
<li>C++中的const修饰的全局常量有跟static相同的特性，即它只能作用于本编译模块中，但是<strong>const可以和extern连用来声明该常量可以作用于其他编译模块中</strong>，如<code>extern const char g_str[];</code>,然后在原文件中别忘了定义：<code>const char g_str[] = &quot;123456&quot;;</code></li>
<li>所以当单独使用的时候它就与static相同，而当与extern一起合作的时候，它的特性就跟extern一样了。最后是该作者的提醒：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* g_str = <span class="string">"123456"</span>;    <span class="comment">// const修饰的是char*而不是g_str</span></span><br><span class="line"><span class="comment">// 与下面的写法</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> g_str[] = <span class="string">"123456"</span>;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> g_str = <span class="string">"123456"</span>;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>上面算是对extern关联的一些拓展内容吧。</p>
<h4 id="2-2-1-5包含头文件"><a href="#2-2-1-5包含头文件" class="headerlink" title="2.2.1.5包含头文件"></a>2.2.1.5包含头文件</h4><blockquote>
<p><strong>#include</strong>预处理指令有两种方式来指定文件：尖括号（&lt; &gt;）或双引号。</p>
<p><code>#include &lt;header&gt;</code>用尖括号来指定文件时，预处理器是以特定的方式来寻找文件，一般是环境中或编译器命令行指定的某种寻找路径。这种设置寻找路径的机制随机器，操作系统，C++实现的不同而不同，视具体的情况而定。</p>
<p><code>#include &quot;local.h&quot;</code>用双引号时，预处理器以”由实现定义的方式“来寻找文件。它通常是从当前目录开始寻找，如果文件没有找到，那么include命令就按与尖括号同样的方式重新开始寻找。</p>
<p>包含iostream头文件要用如下语句</p>
<p><code>#include &lt;iostream&gt;</code></p>
</blockquote>
<p>包含头文件的两种方式的区别。</p>
<h3 id="2-2-2-连接"><a href="#2-2-2-连接" class="headerlink" title="2.2.2 连接"></a>2.2.2 连接</h3><blockquote>
<p>连接器把由编译器生成的目标模块（一般是带<code>.o</code>或<code>.obj</code>扩展名的文件）连接成为操作系统可以加载和执行的程序。它是编译过程的最后阶段。</p>
</blockquote>
<h3 id="2-2-3-使用库文件"><a href="#2-2-3-使用库文件" class="headerlink" title="2.2.3 使用库文件"></a>2.2.3 使用库文件</h3><h4 id="2-2-3-1连接器如何查找库"><a href="#2-2-3-1连接器如何查找库" class="headerlink" title="2.2.3.1连接器如何查找库"></a>2.2.3.1连接器如何查找库</h4><p>当C或者C++要对函数或变量进行外部引用时，根据引用的情况会选择两种处理方式。</p>
<p>一是如果未遇到过这个函数或者这个变量的定义，就把它的标识符加到<strong>未解析的引用</strong>列表中，如果连接器遇到过他们的定义，就是已解决的引用。</p>
<p>二是如果连接器没有在<em>目标模块</em>中找到它们的定义，就去查找库。</p>
<p>库有某种索引方式，连接器不会去浏览库中的所有目标模块，而是浏览索引。如果找到了就把函数或变量定义所在的目标模块连接到可执行程序。</p>
<p>这里需要注意的是连接的是目标模块而不是整个库，因此在构造自己的库的时候，一个源码文件只有一个函数，可以减少程序包的大小。</p>
<h4 id="2-2-3-2秘密的附加模块"><a href="#2-2-3-2秘密的附加模块" class="headerlink" title="2.2.3.2秘密的附加模块"></a>2.2.3.2秘密的附加模块</h4><blockquote>
<p>当创建一个C/C++的可执行程序的时候，连接器会秘密连接某些模块。其中之一是启动模块，它包含了对程序的初始化例程。初始化例程是开始执行C/C++程序时必须首先执行一段程序。<em>初始化例程建立堆栈，并初始化程序中的某变量</em>。</p>
<p>连接器总是从标准库中查找程序中调用的经过编译的标准函数。由于标准库总可以被找到，所以只要在程序中包含所需的头文件，就可以使用库中的任何模块，并且不必告诉连接器去找标准库。</p>
<p>如果使用附加的库，必须把该库文件名添加到由连接器处理的文件列表中。</p>
</blockquote>
<p>上面的内容给我揭示了一个盲区，貌似我之前的水平都没有接触到，标准库以外的内容。如果有一天我发现标准库的内容满足不了，我需要别的库的实现，除了在代码中引用之外，我还应该修改连接器维护的一个文件列表，把库的名字加进去。至于应该怎么做，不太清楚了。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的Casting</title>
    <url>/UE4%E4%B8%AD%E7%9A%84Casting/</url>
    <content><![CDATA[<p>关于<strong>Cast To</strong>节点在Blueprint中能够做什么的问题。下面是官方文档中的说明。</p>
<a id="more"></a>
<ul>
<li><a href="api.unrealengine.com/INT/Engine/Blueprints/UserGuide/CastNodes/index.html">Casting in Blueprint</a></li>
</ul>
<p>其中的一句话：</p>
<blockquote>
<p>By using the Get Player Charactor node, then using a Cast To MyCharactor node(the special Charactor Blueprint), you can say if the Player Charactor is MyCharactor, let me access the Variables, Functions, Events or any other special functionality contained within that Blueprint.</p>
</blockquote>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title>git-rebases使用方法</title>
    <url>/git-rebases%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>git rebase的使用简介</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4:Error_Message整理</title>
    <url>/UE4-Error-Message%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>整理在学习UE4的过程中遇到的一些BUG。</p>
<a id="more"></a>
<h1 id="UE4中遇见的报错"><a href="#UE4中遇见的报错" class="headerlink" title="UE4中遇见的报错"></a>UE4中遇见的报错</h1><p>旨在记录UE4学习过程中遇见的各种报错。</p>
<h2 id="class关键字的使用"><a href="#class关键字的使用" class="headerlink" title="class关键字的使用"></a>class关键字的使用</h2><p><code>syntax error:missing &#39;;&#39; before &#39;*&#39;</code> 这样完全不知到为什么的报错。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/701590/syntax-error-missing-before-first-person-shooter-c.html" target="_blank" rel="noopener">syntax error: missing ‘;’ before ‘*’ (First Person Shooter C++ Tutorial)</a></li>
</ul>
<p>加了一个关键字<code>class</code>就解决了。虽然不知道是为什么。</p>
<h2 id="bUsedWithInstancedStaticMeshes"><a href="#bUsedWithInstancedStaticMeshes" class="headerlink" title="bUsedWithInstancedStaticMeshes"></a>bUsedWithInstancedStaticMeshes</h2><p>时间太过于久远再加上自己的懒惰，这个错误到底是在说什么我也不清楚了。</p>
<p><code>LogMaterial: Warning: Material /Game/MagicCircle/Materials/MT_Smoke.MT_Smoke missing bUsedWithInstancedStaticMeshes=True! Default Material will be used in game.</code></p>
<h2 id="包含头文件的问题"><a href="#包含头文件的问题" class="headerlink" title="包含头文件的问题"></a>包含头文件的问题</h2><p>就像下面的信息描述的，我使用了一个<code>TWeakObjectPtr</code>来进行值的初始化，于是便报错了，各种调查结果显示，是赋值的值的类型的头文件没有好好的包含进去，以至于找不到该类型。</p>
<p><code>error C2664: &#39;FWeakObjectPtr &amp;FWeakObjectPtr::operator =(const FWeakObjectPtr &amp;)&#39;: cannot convert argument 1 from &#39;T *&#39; to &#39;const UObject *&#39;</code></p>
<p><img src="Annotation 2020-07-16 181212.jpg" alt="Error description"></p>
<p>参考的链接：<a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/42246-tweakobjectptr-with-custom-character-class" target="_blank" rel="noopener">TWeakObjectPtr with Custom Character Class</a></p>
<p><code>error C2440: &#39;initializing&#39; : cannot convert from &#39;initializer-list&#39;</code></p>
<p>关于这个错误类型，涉及到一些初始化操作，但我的情况下还是头文件没有包含进去的问题，真是头大。</p>
<h2 id="unresolved-eternal-symbol类型"><a href="#unresolved-eternal-symbol类型" class="headerlink" title="unresolved eternal symbol类型"></a>unresolved eternal symbol类型</h2><p>有的时候会在错误信息中包含上述关键词的错误</p>
<p><code>error Link2019: unresolved external symbol 函数名</code> 这样的错误是找到了函数的声明但是却找不到函数的定义。</p>
<p>一般需要检查Build.cs文件中的依赖项是否添加。</p>
<p>亦或者出现在利用另一个<strong>Module</strong>中的函数的时候，找不到函数的实现，出现上面的错误编译不通过。实际上调用的函数是虚函数的话就没有问题，关键是不是虚函数的情况。</p>
<p>所以问我怎么办我也不太清楚，这一部分好好参考如何添加Module或者ActionRPG的LoadScreen部分的源码好好实现应该就没有问题了。</p>
<p>另外贴一个别人整理的一些报错的文章</p>
<ul>
<li><a href="https://finap.hateblo.jp/entry/2019/12/06/000000" target="_blank" rel="noopener">UE4 C++ビルドエラー対応覚書</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>UE4Error</tag>
      </tags>
  </entry>
  <entry>
    <title>为Actor添加Input事件</title>
    <url>/%E4%B8%BAActor%E6%B7%BB%E5%8A%A0Input%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>在自己编写Actor的Component的时候想要加上input的事件，但是在UE4中加入这种事件不是那么简单的。这需要对Actor的层级关系有一些了解。</p>
<a id="more"></a>
<p>参考链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/181782/c-is-there-a-way-to-get-input-from-actor-that-isn.html" target="_blank" rel="noopener">C++Is there a way to get input from actor that isn a pawn/character ?</a></li>
<li><a href="https://answers.unrealengine.com/questions/166084/check-keyboard-events-in-code.html" target="_blank" rel="noopener">Check Keyboard Event in code</a></li>
<li><a href="sirokuma.cc/?p=567">UE4-学习笔记之二</a><ul>
<li>这篇文章感觉好厉害</li>
</ul>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/23321666" target="_blank" rel="noopener">&lt;<insideue4>&gt;GamePlay架构(四)Pawn</insideue4></a><ul>
<li>知乎文章，可以一看</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4-ConstructorHelpers::FObjectFinder</title>
    <url>/UE4-ConstructorHelpers-FObjectFinder/</url>
    <content><![CDATA[<p>先来说一说这个问题的起源吧。最近想做一个类似于火焰的特效，是由大量的烟雾粒子组成的那种类似于烟雾的火焰。在制作大量烟雾粒子之前首先要制作出第一个粒子。</p>
<a id="more"></a>
<p>制作一个粒子表现的话首先要先实例化一个Instance，这个实例首先依附在一个Acor上。当然，像Unity的脚本函数一样，在Scene中制作一个Actor然后把脚本当做一个ActorComponent的方案是可行的。然后在脚本中使用<code>this-&gt;GetOwner()</code>即可以获取到这个Actor。可以使用<code>this-&gt;GetOwner()-&gt;GetName()</code>来获取到Actor的名字。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/300035/get-actor-from-component-in-c.html" target="_blank" rel="noopener">Get actor from component in c++?</a></li>
</ul>
<p>在这里遇见了一个问题。就是在使用UE的<code>UE_LOG</code>打印输出的时候发生了类型错误。</p>
<ul>
<li>在<code>UE_LOG</code>中使用的都是基础类型，<code>%d,%s</code>等等。</li>
<li><code>GetName()</code>函数返回的变量类型则是UE的<code>FString</code>类型</li>
</ul>
<p>解决例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Actor component .cpp file</span></span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"show value: : %s"</span>, *(<span class="keyword">this</span>-&gt;GetOwner()-&gt;GetName()));</span><br></pre></td></tr></table></figure></p>
<p>解决案参考：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/1903/log-issue-passing-a-fstring.html" target="_blank" rel="noopener">Log issue (passing a FString)</a></li>
<li><a href="https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime#Log_an_FString.2CInt.2CFloat" target="_blank" rel="noopener">Logs, Printing Messages To Yourself During Runtime</a></li>
</ul>
<p>能够获取到Parent的Actor就可以根据自身的Actor来制作InstanceStaticMeshComponent了。</p>
<h2 id="InstanceStaticMeshComponent"><a href="#InstanceStaticMeshComponent" class="headerlink" title="InstanceStaticMeshComponent"></a>InstanceStaticMeshComponent</h2><p>使用方法参照：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/464719/using-instanced-static-meshes-in-c.html" target="_blank" rel="noopener">Using Instanced Static Meshes in C++?</a></li>
</ul>
<p>下一步就是发生问题的地方，为制作好的InstanceStaticMeshComponent添加StaticMesh。</p>
<p>上网查查资料就有，这篇文章就行</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/13555/question-apply-static-mesh-to-staticmesh-component.html" target="_blank" rel="noopener">QUESTION Apply Static Mesh to StaticMesh component</a></li>
</ul>
<p>照着做本来不会出错的但是我一运行，UE4肯定Crash。</p>
<p>原因就在于题目所提到的关于<code>ContructorHelpers::FObjectFinder</code>的使用上。<strong>总结来说就是这个函数只能运行在类的构造函数中，或者构造函数里调用的函数中。</strong></p>
<p>解决文章：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/246199/how-to-use-constructorhelpersfobjectfinder.html" target="_blank" rel="noopener">How to use ConstructorHelpers::FObjectFinder?</a></li>
</ul>
<p>这个回答中有提到。之后再整理。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH原理知识普及</title>
    <url>/SSH%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%99%AE%E5%8F%8A/</url>
    <content><![CDATA[<p>SSH的原理与运用。</p>
<a id="more"></a>
<p>参考链接：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH原理与运用（一）：远程登录</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么？</a></li>
<li><a href="http://www.youdzone.com/signature.html" target="_blank" rel="noopener">What is a Digital Signature?</a></li>
</ul>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中读取Texture2D的像素值</title>
    <url>/UE4%E4%B8%AD%E8%AF%BB%E5%8F%96Texture2D%E7%9A%84%E5%83%8F%E7%B4%A0%E5%80%BC/</url>
    <content><![CDATA[<p>目的是在UE中获取到一张Texture2D图片的所有像素值，并将这些像素值进行某些处理并保存到另外一个Texture中。</p>
<a id="more"></a>
<h1 id="第一步：获取到Texture2D资源"><a href="#第一步：获取到Texture2D资源" class="headerlink" title="第一步：获取到Texture2D资源"></a>第一步：获取到Texture2D资源</h1><p>Unreal Engine 4 Documentation</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/Programming/Assets/ReferencingAssets/index.html" target="_blank" rel="noopener">Referencing Assets</a></li>
</ul>
<p>对于高速化来说异步加载资源也是好的解决方案</p>
<p>Ureal Engine 4 Documentation</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Programming/Assets/AsyncLoading" target="_blank" rel="noopener">Asynchronous Asset Loading</a></li>
</ul>
<h1 id="参考的文章"><a href="#参考的文章" class="headerlink" title="参考的文章"></a>参考的文章</h1><ul>
<li><a href="https://answers.unrealengine.com/questions/25594/accessing-pixel-values-of-texture2d.html" target="_blank" rel="noopener">Accessing pixel values of Texture2D</a><ul>
<li><blockquote>
<p>First you need to understand that a texture is normally, a sum of multiple images called MipMaps. MipMaps are down-scaled versions of your images, always in steps of power of 2, so the original image, is, say, 512x512 - this would be the MipMap “0”, then the engine generates the MipMap “1” which is 256x256 and then MipMap “2” which is 128x128, this continues on down to 16x16 I think. The farther away the texture is rendered, the smaller version of the image is used. This means that you need to access the mipmap 0 of your texture.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="对上面的答案进行了非常好的总结的文章"><a href="#对上面的答案进行了非常好的总结的文章" class="headerlink" title="对上面的答案进行了非常好的总结的文章"></a>对上面的答案进行了非常好的总结的文章</h1><ul>
<li><p><a href="http://isaratech.com/ue4-reading-the-pixels-from-a-utexture2d/" target="_blank" rel="noopener">UE4 – Reading the pixels from a UTexture2D</a></p>
</li>
<li><p><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/84701-reading-data-from-utexture2d" target="_blank" rel="noopener">Reading data from UTexture2D</a></p>
</li>
</ul>
<h1 id="之后附上完整的代码"><a href="#之后附上完整的代码" class="headerlink" title="之后附上完整的代码"></a>之后附上完整的代码</h1><h1 id="UE4中的资源管理"><a href="#UE4中的资源管理" class="headerlink" title="UE4中的资源管理"></a>UE4中的资源管理</h1><ul>
<li><a href="https://api.unrealengine.com/INT/Engine/Basics/AssetsAndPackages/AssetManagement/index.html" target="_blank" rel="noopener">Asset Management</a></li>
</ul>
<h1 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h1><p>在代码中看到了<code>static_cast</code>这个语句，竟然不知道是做什么的。查了一下</p>
<ul>
<li><a href="https://blog.csdn.net/bzhxuexi/article/details/17021559" target="_blank" rel="noopener">C++中static_cast, dynamic_cast, const_cast用法/使用情况及区别解析</a></li>
</ul>
<p>之后要好好整理一下。</p>
]]></content>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4的函数库</title>
    <url>/UE4%E7%9A%84%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    <content><![CDATA[<p>在UE4中总会遇见一些不知道是做什么的函数，这篇文章的目的是整理自己遇到的UE4的函数和类，和弄清函数和类的时候遇到的一些问题的解决。</p>
<a id="more"></a>
<h1 id="UE4中的类"><a href="#UE4中的类" class="headerlink" title="UE4中的类"></a>UE4中的类</h1><h2 id="UTexture2D"><a href="#UTexture2D" class="headerlink" title="UTexture2D"></a>UTexture2D</h2><h3 id="TextureCompressionSettings"><a href="#TextureCompressionSettings" class="headerlink" title="TextureCompressionSettings"></a>TextureCompressionSettings</h3><h3 id="TextureMipGenSettings"><a href="#TextureMipGenSettings" class="headerlink" title="TextureMipGenSettings"></a>TextureMipGenSettings</h3><h3 id="UpdateResource-Functio作用"><a href="#UpdateResource-Functio作用" class="headerlink" title="UpdateResource() Functio作用"></a>UpdateResource() Functio作用</h3><h2 id="UTextureRenderTaget2D"><a href="#UTextureRenderTaget2D" class="headerlink" title="UTextureRenderTaget2D"></a>UTextureRenderTaget2D</h2><p>Ureal Engine 4 Documentation:</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/API/Runtime/Engine/Engine/UTextureRenderTarget2D/index.html" target="_blank" rel="noopener">UTextureRenderTarget2D</a></li>
</ul>
<p>可以用来存储一个2DTexture数据的类，拥有着许多的成员，文件的位置：</p>
<ul>
<li>C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Classes\Engine\TextureRenderTarget2D.h</li>
<li>C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\TextureRenderTarget2D.cpp</li>
</ul>
<p>关于如何实例化这个类，我在网上并没有找到类似的实现，但是在UE4的Blueprint中可以找到一个名为<code>Create Rendr Target 2D</code>的node函数。试着找了一下这个节点的实现函数</p>
<ul>
<li>C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetRendngLibrary.cpp</li>
</ul>
<p>其中有如下的实现代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UTextureRenderTarget3D* UKismetRenderingLibrary::CreateRenderTarget2D(UObject* WorldContextObject, int32 Width, int32 Height, ETextureRenderTargetFormat Format)</span><br><span class="line">&#123;</span><br><span class="line">    UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Width &gt; <span class="number">0</span> &amp;&amp; Height &gt; <span class="number">0</span> &amp;&amp; World &amp;&amp; FApp::CanEverRender())</span><br><span class="line">    &#123;</span><br><span class="line">        UTextureRenderTarget2D* NewRenderTarget2D = NewObject&lt;UTextureRenderTarget2D&gt;(WorldContextObject);</span><br><span class="line">        check(NewRenderTarget2D);</span><br><span class="line">        NewRenderTarget2D-&gt;RenderTargetFormat = Format;</span><br><span class="line">        NewRenderTarget2D-&gt;InitAutoFormat(Width, Height); </span><br><span class="line">        NewRenderTarget2D-&gt;UpdateResourceImmediate(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NewRenderTarget2D; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或许可以给与一些参照。</p>
<h2 id="UMaterialInstanceDynamic"><a href="#UMaterialInstanceDynamic" class="headerlink" title="UMaterialInstanceDynamic"></a>UMaterialInstanceDynamic</h2><p>Ureal Engine 4 Documentation:</p>
<ul>
<li><a href="https://api.unrealengine.com/INT/API/Runtime/Engine/Materials/UMaterialInstanceDynamic/index.html" target="_blank" rel="noopener">UMaterialInstanceDynamic</a></li>
</ul>
<p>这个类的作用按照字面意思来推测是用来创建一个动态的材质实例，在UE4的Blueprint中也有相应的节点函数：<code>CreateDynamicMaterialInstance</code>。函数位置</p>
<ul>
<li>C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\KismetMaterialLibrary.cpp</li>
</ul>
<p>其中的实现代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UMaterialInstanceDynamic</span>* <span class="title">UKismetMaterialLibrary</span>:</span>:CreateDynamicMaterialInstance(UObject* WorldContextObject, class UMaterialInterface* Parent)</span><br><span class="line">&#123;</span><br><span class="line">    UMaterialInstanceDynamic* NewMID = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Parent)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MIDs need to be created within a persistent object if in the construction script (or blutility) or else they will not be saved.</span></span><br><span class="line">        <span class="comment">// If this MID is created at runtime then put it in the transient package</span></span><br><span class="line">        UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull);</span><br><span class="line">        UObject* MIDOuter = (World &amp;&amp; (World-&gt;bIsRunningConstructionScript  || !World-&gt;IsGameWorld()) ? WorldContextObject : <span class="literal">nullptr</span>);</span><br><span class="line">        NewMID = UMaterialInstanceDynamic::Create(Parent, MIDOuter);</span><br><span class="line">        <span class="keyword">if</span> (MIDOuter == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NewMID-&gt;SetFlags(RF_Transient);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NewMID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以为该材质添加值的函数实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UKismetMaterialLibrary::SetScalarParameterValue(UObject* WorldContextObject, UMaterialParameterCollection* Collection, FName ParameterName, <span class="keyword">float</span> ParameterValue)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Collection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::LogAndReturnNull))</span><br><span class="line">        &#123;</span><br><span class="line">            UMaterialParameterCollectionInstance* Instance = World-&gt;GetParameterCollectionInstance(Collection);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> bFoundParameter = Instance-&gt;SetScalarParameterValue(ParameterName, ParameterValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!bFoundParameter &amp;&amp; !Instance-&gt;bLoggedMissingParameterWarning)</span><br><span class="line">            &#123;</span><br><span class="line">                FFormatNamedArguments Arguments;</span><br><span class="line">                Arguments.Add(TEXT(<span class="string">"ParamName"</span>), FText::FromName(ParameterName));</span><br><span class="line">                FMessageLog(<span class="string">"PIE"</span>).Warning()</span><br><span class="line">                    -&gt;AddToken(FTextToken::Create(LOCTEXT(<span class="string">"SetScalarParamOn"</span>, <span class="string">"SetScalarParameterValue called on"</span>)))</span><br><span class="line">                    -&gt;AddToken(FUObjectToken::Create(Collection))</span><br><span class="line">                    -&gt;AddToken(FTextToken::Create(FText::Format(LOCTEXT(<span class="string">"WithInvalidParam"</span>, <span class="string">"with invalid ParameterName '&#123;ParamName&#125;'. This is likely due to a Blueprint error."</span>), Arguments)));</span><br><span class="line">                Instance-&gt;bLoggedMissingParameterWarning = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用方法是在C++中声明一个材质<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UMaterialInstanceDynamic* mMaterial;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将mMaterial的材质实例通过Blueprint传递过来</span></span><br><span class="line"></span><br><span class="line">mMaterial-&gt;SetScalarParamaterValue(<span class="string">"TextureWidth"</span>,<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这样便可以将换递过来的Blueprint中的名为`TextureWidth`(if exist)的Parameter赋值为512了</span></span><br></pre></td></tr></table></figure></p>
<p>但还是有许多疑问。</p>
<h1 id="UE4中的函数"><a href="#UE4中的函数" class="headerlink" title="UE4中的函数"></a>UE4中的函数</h1><h2 id="check"><a href="#check" class="headerlink" title="check()"></a>check()</h2><p>参考链接：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/418935/when-should-i-use-check.html?sort=oldest" target="_blank" rel="noopener">When should I use Check()?</a></li>
</ul>
<h2 id="AddInstance"><a href="#AddInstance" class="headerlink" title="AddInstance()"></a>AddInstance()</h2><h1 id="UE4中的一些类型"><a href="#UE4中的一些类型" class="headerlink" title="UE4中的一些类型"></a>UE4中的一些类型</h1><h2 id="TextureAddress"><a href="#TextureAddress" class="headerlink" title="TextureAddress"></a>TextureAddress</h2><p>在<code>Texture.h</code>中看到了这个属性，不太清楚是什么属性，就查了一下。貌似是一种纹理寻址模式。因为有赋值为<code>T_Clamp</code>,Clamp让我有些回想起来在Unity中设置UV的时候有repeat跟clamp等等选项来着，需要调查一下。</p>
<ul>
<li><a href="https://blog.csdn.net/gggg_ggg/article/details/40374029" target="_blank" rel="noopener">D3D11_TEXTURE_ADDRESS_MODE(纹理寻址模式)</a></li>
</ul>
<h2 id="TextureFilter"><a href="#TextureFilter" class="headerlink" title="TextureFilter"></a>TextureFilter</h2><h2 id="SRGB是什么"><a href="#SRGB是什么" class="headerlink" title="SRGB是什么"></a>SRGB是什么</h2><p>参考链接：</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/content-creation/91012-frustration-black-materials-from-my-textures/page2" target="_blank" rel="noopener">sRGB - how to be?</a></li>
<li><a href="https://blog.csdn.net/candycat1992/article/details/46228771" target="_blank" rel="noopener">【图形学】我理解的伽马校正（Gamma Correction）</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的static关键字</title>
    <url>/C++%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>static 关键字可用于声明变量、函数、类数据成员和类函数。</p>
<a id="more"></a>
<p>之后需要好好整理一下，static关键字的用法。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://zheming.wang/blog/2012/06/28/18316F9F-EB98-4088-AE29-C151BAEC8E71/" target="_blank" rel="noopener">C/C++ 中的static关键字</a></li>
<li><a href="https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c" target="_blank" rel="noopener">The static keyword and its various uses in C++</a></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4的Plugin使用</title>
    <url>/UE4%E7%9A%84Plugin%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>制作UE4的插件相当于给UE4引擎添加新的功能模块。UE4的功能模块组成是由Module组成的，关于Module具体是什么，中文翻译就是模块，自己的理解中可以说是文件的单位了。</p>
<p>新建的插件代表着跟UE4本来的功能模块不是从属于一个Module，所以需要为自己制作的插件制作一个属性为Public的公开接口以供UE4引擎调用。</p>
<a id="more"></a>
<h1 id="Plugin的Public公开权限"><a href="#Plugin的Public公开权限" class="headerlink" title="Plugin的Public公开权限"></a>Plugin的Public公开权限</h1><p>一般一个Module中不想公开的源文件都会设置为Private权限，不允许外界的Module访问。要把权限公开，使得其他的模块能够访问的话需要以下两步。</p>
<h2 id="头文件的位置"><a href="#头文件的位置" class="headerlink" title="头文件的位置"></a>头文件的位置</h2><ul>
<li>头文件(.h)放到[<moduledirectory>\Source\Public]文件夹中去</moduledirectory></li>
<li>cpp实现文件放到[<moduledirectory>\Source\Private]文件夹中去</moduledirectory></li>
</ul>
<h2 id="添加Export用的宏"><a href="#添加Export用的宏" class="headerlink" title="添加Export用的宏"></a>添加Export用的宏</h2><p>在类的声明中添加一个宏：<code>&lt;大写字母的Module名字&gt;_API</code></p>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SAYHELLO_API</span> <span class="title">USayHelloFunction</span> :</span> <span class="keyword">public</span> UBlueprintFunctionLibrary&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一个名为<code>SayHello</code>的Module的class的权限就变成公开的了。</p>
<p>Tips：</p>
<ul>
<li>上述的<code>SAYHELLO_API</code>的定义文件位置在<code>Intermediate/Build/Win64/UE4Editor/Development/SayHello/Definitions.SayHello.h</code>。里面定义了<code>DLLEXPORT</code>,<code>DLLIMPORT</code>。</li>
<li>UE会按照Module的单位生成DLL，<code>&lt;ModuleName&gt;_API</code>在自身的Module中会指定DLLEXPORT，在其他的Module中会指定DLLIMPORT。（啥意思？书上就写了这么多。。。）</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/Programming/Plugins/index.html" target="_blank" rel="noopener">Unreal Engine 4 Documentation - Plugins</a></li>
<li><a href="https://blog.csdn.net/qq_20309931/article/details/53584075" target="_blank" rel="noopener">Unreal Engine 4 C++ 插件介绍</a></li>
<li><a href="https://blog.csdn.net/yangxuan0261/article/details/52098104" target="_blank" rel="noopener">ue4插件开发</a></li>
</ul>
<h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><p>顺着文章名字找过来，结果发现内容跟我想象的不太一样。那么就分为两部分，上面是介绍UE4插件的使用方式。这一部分是介绍UE4中用到的插件。</p>
<h2 id="Impostor-Bake"><a href="#Impostor-Bake" class="headerlink" title="Impostor Bake"></a>Impostor Bake</h2><ul>
<li><p><a href="https://80.lv/articles/impostor-baker-for-ue4/" target="_blank" rel="noopener">Impostor Baker for UE4</a></p>
</li>
<li><p><a href="https://shaderbits.com/blog/octahedral-impostors/" target="_blank" rel="noopener">Octahedral Impostors</a></p>
</li>
<li><a href="https://github.com/ictusbrucks/ImpostorBaker" target="_blank" rel="noopener">Github</a></li>
</ul>
<p>这个插件在工程中使用过不过不太清楚是做什么的，不是我使用的部分，只是看到了。（需要整理）</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Plugins</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的const修饰符</title>
    <url>/c++-const-modifier/</url>
    <content><![CDATA[<p>C++中经常会看到const关键字来修饰很多东西，在这里把自己遇到的一些情况收集并整理一下。</p>
<a id="more"></a>
<p>参考链接</p>
<ul>
<li><a href="https://stackoverflow.com/questions/5598703/c-const-usage-explanation" target="_blank" rel="noopener">C++ Const Usage Explanation</a></li>
<li><a href="https://blog.csdn.net/Eric_Jo/article/details/4138548" target="_blank" rel="noopener">关于C++ const 的全面总结</a></li>
</ul>
<h2 id="C-中的mutable关键字"><a href="#C-中的mutable关键字" class="headerlink" title="C++中的mutable关键字"></a>C++中的mutable关键字</h2><ul>
<li><p><a href="https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/" target="_blank" rel="noopener">C++ 中的 mutable 关键字</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/5cb9800b6697" target="_blank" rel="noopener">C++进阶–类型转换，你看我就够了</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的静态库与动态库</title>
    <url>/UE4%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    <content><![CDATA[<p>库(Library)是什么,库是写好的现有的，成熟的，可以复用的代码。现实中每个程序都要依赖很多基础的底层库，不可能每个人的代码都从零开始，因此库的存在意义非同寻常。</p>
<p>本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。</p>
<a id="more"></a>
<p>需要知道的除了制作动态库与静态库，还要知道这两种库之间的区别。为什么要制作库。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/skynet/p/3372855.html" target="_blank" rel="noopener">C++静态库与动态库</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的异步处理</title>
    <url>/UE4%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>能够熟练的使用UE4中的异步处理应该能够很好的利用程序运行的资源，和计算。除此之外还有并行的处理。目的是要理清UE4中的线程的同步异步，并行操作和标准C++中的线程同步异步，并行操作。</p>
<a id="more"></a>
<p>时间有限，暂时记录下关键字：</p>
<ul>
<li>UE C++ ThreadPool</li>
<li><p>异步处理相关函数：</p>
<ul>
<li>Async<ul>
<li>Lambda记法</li>
</ul>
</li>
<li>AsyncTask</li>
<li>ParallelFor<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//函数的位置</span><br><span class="line">Engine/Source/Runtme/Cre/Pblic/Async/Async.h</span><br><span class="line">Engine/Source/Runtme/Cre/Pblic/Async/ParallelFor.h</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>异步辅助API</p>
<ul>
<li>FScopeLock</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的C++</title>
    <url>/UE4-C++/</url>
    <content><![CDATA[<p>UE C++拥有着自己的库，当然也可以使用C++的标准库(STL)，但是不同的地方还应该好好记载下来，同时也是对C++的一种复习。</p>
<a id="more"></a>
<h1 id="1-值类型？指针？"><a href="#1-值类型？指针？" class="headerlink" title="1.值类型？指针？"></a>1.值类型？指针？</h1><p>在标准C++中，类的声明可以<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ClassExample ObjName;</span><br><span class="line"></span><br><span class="line">/或者是</span><br><span class="line"></span><br><span class="line">ClassExample* ObjPtr;</span><br></pre></td></tr></table></figure></p>
<p>而在UE4中为了统一值类型与指针的规则，将这种类的声明全部使用指针类型，不使用值类型。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UObject* o;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-UE4生成类对象实例-Instance"><a href="#2-UE4生成类对象实例-Instance" class="headerlink" title="2.UE4生成类对象实例(Instance)"></a>2.UE4生成类对象实例(Instance)</h1><p>直接上例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line">UMyClass* MyClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成实例</span></span><br><span class="line">MyClass = NewObject&lt;UMyClass&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">MyClass = NewObject&lt;UMyClass&gt;(Owner);</span><br></pre></td></tr></table></figure></p>
<p>Tips:</p>
<ul>
<li>在构造函数中不能使用<code>NewObject&lt;T&gt;</code>生成其他的对实例。会使程序Crash。如果想生成其他的Object的话使用<code>FObjectInitializer::CreateDefaultSubobject&lt;T&gt;</code>函数  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ASomeActor::ASomeActor(<span class="keyword">const</span> FObjectInitializer &amp; ObjectInitializer) : Super(ObjectInitializer)&#123;</span><br><span class="line">   SampleActor = ObjectInitialize.CreateDefaultSubobject&lt;ASampleActor&gt;(<span class="keyword">this</span>, TEXT(<span class="string">"SampleActor"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="UE中的构造函数"><a href="#UE中的构造函数" class="headerlink" title="UE中的构造函数"></a>UE中的构造函数</h2><p>UE4中添加构造函数的话有三种方法：</p>
<ul>
<li>没有构造函数</li>
<li>声明默认的构造函数</li>
<li>带有<code>const FObjectInitializer&amp; ObjectInitializer</code>参数的构造函数</li>
</ul>
<p>使用方法的话就像这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMyActor</span>:</span> <span class="keyword">public</span> AActor</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AMyActor(onst FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">AMyActor::AMyActor(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer) </span><br><span class="line">    : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于为什么要使用<code>FobjectInitializer</code>参数的构造函数的原因我现在还不是非常清楚。</p>
<h1 id="3-Actor的实例化"><a href="#3-Actor的实例化" class="headerlink" title="3.Actor的实例化"></a>3.Actor的实例化</h1><h1 id="4-Actor的Component实例化"><a href="#4-Actor的Component实例化" class="headerlink" title="4.Actor的Component实例化"></a>4.Actor的Component实例化</h1><h2 id="1-在UE4C-中试着添加component"><a href="#1-在UE4C-中试着添加component" class="headerlink" title="1.在UE4C++中试着添加component"></a>1.在UE4C++中试着添加component</h2><h3 id="1-添加SkeletalMeshComponent"><a href="#1-添加SkeletalMeshComponent" class="headerlink" title="1.添加SkeletalMeshComponent"></a>1.添加SkeletalMeshComponent</h3><p>或许有一天我会再次遇见这个问题，就是想要用C++来写全部的东西。比如说在C++中为一个Actor添加ActorComponent（这个ActorComponent就是要写的C++本体了），这是很顺利。然后再为这个Actor添加一个SkeletalMeshComponent组件。</p>
<p>问题就出现在这里。</p>
<p>我天真的以为在这个ActorComponent中使用<code>this-&gt;GetOwner()-&gt;GetRootComponent()</code>然后创建组件就能成功了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其他的省略</span></span><br><span class="line"><span class="keyword">this</span>-&gt;GetOwner()-&gt;GetRootComponent()-&gt;CreateDefaultSubject&lt;USkeletalMeshComponent&gt;(TEXT(<span class="string">"SkeletalMeshName"</span>));</span><br></pre></td></tr></table></figure>
<p>然后UE4Editor就驾崩了。</p>
<p><code>CreateDefaultSubject</code>直接用就行，不用加前面的一串限定，我还不知原因。把前面删了之后就不会崩溃了。而且去View试图中找Actor下面也确实有生成的SkeletalMeshComponent了。</p>
<p>于是我就SetSkeletalMesh之后发现，明明SkeletalMesh上面有值，也就是正确赋值了，Mesh不显示。</p>
<p>对比了一下终于发现这种方法生成的SkeletalMeshComponent，后面带了一个<strong>inherited</strong>的标识。</p>
<p>去搜了一下<strong>inherited skeletal mesh component doesnt show mesh</strong></p>
<p>天杀的这种UE4程序级别的BUG也能被我碰到。都2019年了还没解决么。看样子是15年提的问题。</p>
<p>也许会有别的方式来为一个Actor在C++中创建SkeletalMeshComponent，但是我没有找到。想了想，还是直接用Blueprint吧，当然直接让Actor直接Add一个Component就能解决然后在C++中保留这个组件的ref就行，但是这样的话不是纯C++的话，为什么直接效率一些直接用BP吧。</p>
<p>为什么我C++中创建就是<em>inherited</em>的对象？是创建的姿势不对么…</p>
<p>我也试过用<code>NewObject&lt;USkeletalMeshComponent&gt;</code>来创建过，但可能是因为代码在构造函数里，还没运行，只是编译一下</p>
<p>UE4Editor就驾崩了。</p>
<h3 id="添加各种Component"><a href="#添加各种Component" class="headerlink" title="添加各种Component"></a>添加各种Component</h3><p>看啊，我上面提问的弱智的问题。UE4中的Component的创建自有其方式，好好学着就好了。</p>
<p>在这里我想记录一下关于Actor的<strong>RootComponent</strong>的问题。</p>
<ul>
<li><a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/15790-cannot-attach-actors-without-root-components" target="_blank" rel="noopener">Cannot attach actors without Root Components</a></li>
</ul>
<blockquote>
<p>An Actor without a root component has no position.</p>
<p>If you are building an Actor through blueprints, it has a “dummy” Scene Component by default that exists to give it a position. You can add other components below that, or replace it as the root component.</p>
<p>In the C++ case, the default Actor does not provide this root component. In your class constructor you will need to create some form of Scene Component and assign it to the RootComponent variable. The simplest form of this would be:</p>
<p>RootComponent = PCIP.CreateDefaultSubobject<uscenecomponent>(this, TEXT(“SceneComponent”));</uscenecomponent></p>
<p>If you wanted to add a Mesh component you could instead create that. Looking at StaticMeshActor.cpp should give some insight in how to do this for a more complex (and visual) component type.</p>
<p>If your goal is to build up a number of related static meshes, or what not in a hierarchy, I’d probably recommend looking at building that out in blueprints rather than C++ as it is much easier to make proper asset references and relationships in your hierarchy there.</p>
</blockquote>
<p>于是我就找了一下StaticMEshActor中的实现看看：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AStaticMeshActor::AStaticMeshActor(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">        : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">        SetCanBeDamaged(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        StaticMeshComponent = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(StaticMeshComponentName);</span><br><span class="line">        StaticMeshComponent-&gt;SetCollisionProfileName(UCollisionProfile::BlockAll_ProfileName);</span><br><span class="line">        StaticMeshComponent-&gt;Mobility = EComponentMobility::Static;</span><br><span class="line">        StaticMeshComponent-&gt;SetGenerateOverlapEvents(<span class="literal">false</span>);</span><br><span class="line">        StaticMeshComponent-&gt;bUseDefaultCollision = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BEGIN ENLIGHTEN MODS</span></span><br><span class="line">        StaticMeshComponent-&gt;EnlightenLightingModeOverride = ELM_ContributeLightmap;</span><br><span class="line"><span class="comment">// END ENLIGHTEN MODS</span></span><br><span class="line"></span><br><span class="line">        RootComponent = StaticMeshComponent;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Only actors that are literally static mesh actors can be placed in clusters, native subclasses or BP subclasses are not safe by default</span></span><br><span class="line">        bCanBeInCluster = (GetClass() == AStaticMeshActor::StaticClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于RootComponent的描述在Actor中是这样的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        <span class="comment">/** The component that defines the transform (location, rotation, scale) of this Actor in the world, all other components must be attached to this one somehow */</span></span><br><span class="line">        UPROPERTY(BlueprintGetter=K2_GetRootComponent, Category=<span class="string">"Utilities|Transformation"</span>)</span><br><span class="line">        USceneComponent* RootComponent;</span><br></pre></td></tr></table></figure></p>
<p>以下是我的猜测：</p>
<p>一般情况下都是被推荐存在一个RootComponent的，而且从Actor的源码来看已经预备好了一个直接用就可以了。但是当你不使用RootComponent的时候会把第一个创建的Component赋值给这个预备好的Rootomponent? 我也不确定，只是就发生的现象而言。</p>
<p>至于使用的话参照上面的就好了。</p>
<p>那段引用中的英文很重要，改天我多看几遍。</p>
<h1 id="5-从Content-Asset-中加载Object对象数据"><a href="#5-从Content-Asset-中加载Object对象数据" class="headerlink" title="5.从Content(Asset)中加载Object对象数据"></a>5.从Content(Asset)中加载Object对象数据</h1><h1 id="6-UE4中的容器"><a href="#6-UE4中的容器" class="headerlink" title="6.UE4中的容器"></a>6.UE4中的容器</h1><h1 id="7-UE4C-中的一些小知识点"><a href="#7-UE4C-中的一些小知识点" class="headerlink" title="7.UE4C++中的一些小知识点"></a>7.UE4C++中的一些小知识点</h1><h2 id="1-从SkeletalMeshComponent得到AnimationBlueprint"><a href="#1-从SkeletalMeshComponent得到AnimationBlueprint" class="headerlink" title="1.从SkeletalMeshComponent得到AnimationBlueprint"></a>1.从SkeletalMeshComponent得到AnimationBlueprint</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// USkeletalMeshComponent::GetAnimInstance()</span></span><br><span class="line">USkeletalMeshComponent * SkeMC = SkeMC_ptr;</span><br><span class="line">UAnimInstance* animIns = SkeMC-&gt;GetAnimInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展</span></span><br><span class="line"><span class="comment">// Copy one anim instance to another charactor</span></span><br><span class="line">ACharactor* ch = <span class="comment">/*...*/</span>;</span><br><span class="line">UAnimInstance * mi = GetMesh()-&gt;GetAnimInstance();</span><br><span class="line">ch-&gt;GetMesh()-&gt;SetAnimInstanceClass(mi-&gt;GetClass());</span><br></pre></td></tr></table></figure>
<h2 id="2-运行时取得SkeletalMesh的Bone情报"><a href="#2-运行时取得SkeletalMesh的Bone情报" class="headerlink" title="2.运行时取得SkeletalMesh的Bone情报"></a>2.运行时取得SkeletalMesh的Bone情报</h2><p>取得Bone情报能做什么呢？</p>
<h3 id="1-Get-the-name-of-all-bones"><a href="#1-Get-the-name-of-all-bones" class="headerlink" title="1.Get the name of all bones"></a>1.Get the name of all bones</h3><p>参考：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/491046/skeletal-mesh-overlap-returns-null-bone.html" target="_blank" rel="noopener">Skeletal mesh overlap returns null bone</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">USkeletalMeshComponent* SkelMeshComp = Cast&lt;USkeletalMeshComponent&gt;(GetMesh());</span><br><span class="line"><span class="keyword">if</span> (SkelMeshComp) &#123;</span><br><span class="line">    TArray&lt;FName&gt; BoneNames;</span><br><span class="line">    SkelMeshComp-&gt;GetBoneNames(BoneNames);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BoneNames.Num(); i++) &#123;</span><br><span class="line">        FBodyInstance* BodyInst = SkelMeshComp-&gt;GetBodyInstance(BoneNames[i]);</span><br><span class="line">        <span class="keyword">if</span> (BodyInst) &#123;</span><br><span class="line">            UPhysicalMaterial* PM = BodyInst-&gt;GetSimplePhysicalMaterial();</span><br><span class="line">            EPhysicalSurface SurfaceType = UPhysicalMaterial::DetermineSurfaceType(PM);</span><br><span class="line">            <span class="keyword">if</span> (SurfaceType_Default != SurfaceType) &#123;</span><br><span class="line">                PhysicBoneNames.Add(BoneNames[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Get-Socket-Location"><a href="#2-Get-Socket-Location" class="headerlink" title="2.Get Socket Location"></a>2.Get Socket Location</h3><p>搜了半天，又是Bone又是FbodyInstance什么的，结果直接获取bone的世界坐标的话有这个函数。</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/BlueprintAPI/Utilities/Transformation/GetSocketLocation/index.html" target="_blank" rel="noopener">Get Socket Location</a></li>
</ul>
<p>C++和Blueprint都能用，自己以前也有试过在Skeletal加Socket，连自己加的Socket都能直接获取，方便了。</p>
<h3 id="3-Animation切换"><a href="#3-Animation切换" class="headerlink" title="3.Animation切换"></a>3.Animation切换</h3><p>就我自己所接触的动画处理而言，将动画的主体的状态跟动画的播放是分开的，也就是说<strong>存在一帧的延迟</strong>。</p>
<p>我不知道真正的游戏开发中的情况是什么样子的，不真正的去看人家的源码我是不会明白的……</p>
<p>记录一下要点。</p>
<ul>
<li>状态的切换和真正动画的切换存在一帧的延迟</li>
<li>真正动画的切换在UE4中有一个cross-fade支持</li>
</ul>
<p>为什么要注意这个是因为动画中如果出现位移，而真正的位移跟动画应该是分开处理的，动画中有位移的话就得根据这段位移进行实际位移的调整来适应下一段动画。不然的话就会产生残留帧（产生跳帧的感觉），因此对于动画的调整就要精确到每一帧的地步，超级麻烦。</p>
<p>Unity和UE4都一样，为Animation的切换提供的过渡的功能，有的时候反而起了反作用。</p>
<p>但是吧，这种只是强行修复位移的效果终究不如使用真正流畅的动画素材要来的好，可能的话，还是制作正确的动画比较合理（拜托美工啦）。</p>
<h2 id="3-Handling-animation-in-C"><a href="#3-Handling-animation-in-C" class="headerlink" title="3.Handling animation in C++"></a>3.Handling animation in C++</h2><p>把UE4中的关于Animation的处理，交给C++来做。就结论来说就是：做个C++类的AnimInstance以供AnimationBlueprint来继承。</p>
<p>我特么…暂时没有找到非要这样的做的理由。</p>
<ul>
<li><a href="https://orfeasel.com/handling-animations-in-c/" target="_blank" rel="noopener">Handling animations in C++</a></li>
<li><a href="https://wiki.unrealengine.com/Animation_Blueprint,_Implement_Custom_C%2B%2B_Logic_Via_Tick_Updates" target="_blank" rel="noopener">Animation Blueprint, Implement Custom C++ Logic Via Tick Updates</a></li>
<li><a href="https://wiki.unrealengine.com/Animation_Blueprint,_Set_Custom_Variables_Via_C%2B%2B" target="_blank" rel="noopener">Animation Blueprint, Set Custom Variables Via C++</a></li>
</ul>
<p>上面的教程和Wiki手把手教学，教你如何使用C++操作动画，但是并不是全部C++，动画跳转还是用的AnimationBlueprint。都已经用了AnimBP了……</p>
<h2 id="1-暂停动画"><a href="#1-暂停动画" class="headerlink" title="(1) 暂停动画"></a>(1) 暂停动画</h2><p>我尝试着找到停止AnimationInstance的tick函数的方法，但是失败了，后来发现在<strong>AnimationBlueprint</strong>附着的<strong>SkeletalMesh</strong>组件上有下面两个属性</p>
<ul>
<li>Pause Anims</li>
<li>Global Anim Rate Scale</li>
</ul>
<p>控制动画播放和暂停，或者动画的播放速度。</p>
<h2 id="4-使用C-制作Blueprint的Node"><a href="#4-使用C-制作Blueprint的Node" class="headerlink" title="4.使用C++制作Blueprint的Node"></a>4.使用C++制作Blueprint的Node</h2><ul>
<li><a href="https://wiki.unrealengine.com/Blueprints,_Creating_C%2B%2B_Functions_as_new_Blueprint_Nodes" target="_blank" rel="noopener">Blueprints, Creating C++ Functions as new Blueprint Nodes</a></li>
</ul>
<p>我有试着写过全局的输出LOG的函数，应该多少有这篇文章的内容，这篇应该介绍的很多，有时间整理一下。</p>
<h2 id="5-在C-中生成BlueprintClass实例"><a href="#5-在C-中生成BlueprintClass实例" class="headerlink" title="5.在C++中生成BlueprintClass实例"></a>5.在C++中生成BlueprintClass实例</h2><p>为什么要做这么蛋疼的事情?但也是的确事出有因，用蓝图写一些组件然后赋值真的太方便了啊…C++里写的话就得各种找组件然后Load各种素材找路径，在蓝图里一拽就解决了。</p>
<p>这里主要是利用了<a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Actors/Spawning/index.html" target="_blank" rel="noopener">SpawnActor</a>这个类。</p>
<ul>
<li><a href="https://usagi.hatenablog.jp/entry/2017/10/17/123000" target="_blank" rel="noopener">UE4: C++ コード から C++ クラスまたは Blueprint のアクターを FindObject して SpawnActor する方法</a></li>
</ul>
<p>上面这篇文章写得很好了，就是风格太花里胡哨了，看着有些累眼睛。</p>
<p>为了能先得到要实例化的BlueprintClass，我没有选择使用从ContentBrower里面Load素材的方法。而是选择了最方便的方法，当然上面的文章里也有提到。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY(EditAnywhere, Category = <span class="string">"PawnBlueprintClass"</span>)</span><br><span class="line">    TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">AActor</span>&gt; <span class="title">SunDevilBPClass</span>;</span></span><br></pre></td></tr></table></figure>
<p>公开一个类模板的属性，取得类模板。（前提是BlueprintClass继承了AActor类，当然这里填上你继承的类类型就好了）公开了这个属性之后，就可以在Editor的Detail面板里把想要实例化的蓝图类选进去。</p>
<p>还有一篇文章，或许也能作参考，但是我没有试过，之后有时间的话可以试一下。</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/725873/c%E3%81%A6%E3%81%AE%E3%83%95%E3%83%AB%E3%83%BC%E3%83%95%E3%83%AA%E3%83%B3%E3%83%88%E3%82%AF%E3%83%A9%E3%82%B9%E5%8F%96%E5%BE%97%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%8D%E3%81%BE%E3%81%97%E3%81%A6.html" target="_blank" rel="noopener">C++でのブループリントクラス取得方法につきまして</a></li>
</ul>
<h3 id="FActorSpawnParameters"><a href="#FActorSpawnParameters" class="headerlink" title="FActorSpawnParameters"></a>FActorSpawnParameters</h3><h3 id="TSubclassOf"><a href="#TSubclassOf" class="headerlink" title="TSubclassOf"></a>TSubclassOf</h3><ul>
<li><a href="https://api.unrealengine.com/INT/API/Runtime/CoreUObject/Templates/TSubclassOf/index.html" target="_blank" rel="noopener">TSubclassOf</a></li>
</ul>
<p>上面用到的一个类，感觉挺重要的，需要总结一下这个类相关的东西。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>我会选择使用C++来生成蓝图类的原因除了我制作了一个C++管理类来生成蓝图类大量实例之外，还有就是对蓝图类初始化抱有疑问。</p>
<ol>
<li>蓝图类的constructor中的内容，在把蓝图拖入场景这个操作中，会执行几次？</li>
<li>假设这个蓝图类有一个C++的父类，同样是上面的操作，父类的构造函数会执行几次？</li>
</ol>
<p>我分别用输出log的方法输出一些内容，得到的结果很让人困惑。蓝图中的constructor跟真正意义上的构造函数又有不同貌似。然而让我不可思议的是，问题2中得到的结果是两次。拖到场景中生成了一个实例，但是父类的构造函数调用了两次。</p>
<p>要说不可思议问题1的constructor貌似执行了很多次（2次以上）。</p>
<h2 id="6-深入理解UE4中的UClass"><a href="#6-深入理解UE4中的UClass" class="headerlink" title="6.深入理解UE4中的UClass"></a>6.深入理解UE4中的UClass</h2><p>UE4中会经常看到<code>UCLASS()</code>宏，摘自官网的描述：</p>
<blockquote>
<p>The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type. Each UCLASS maintains one Object called the ‘Class Default Object’, or CDO for short. The CDO is essentially a default ‘template’ Object, generated by the class constructor and unmodified thereafter. Both the UCLASS and the CDO can be retrieved for a given Object instance, though they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the GetClass() function.</p>
</blockquote>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html" target="_blank" rel="noopener">Objects</a></li>
</ul>
<p>想上面描述的那样，知道UCLASS宏维护了一个CDO的东西。</p>
<h3 id="GetClass-vs-StaticClass"><a href="#GetClass-vs-StaticClass" class="headerlink" title="GetClass() vs StaticClass()"></a>GetClass() vs StaticClass()</h3><ul>
<li><a href="https://answers.unrealengine.com/questions/346164/view.html" target="_blank" rel="noopener">GetClass() vs StaticClass()</a></li>
</ul>
<h1 id="8-UE4C-中遇到的一些问题调查"><a href="#8-UE4C-中遇到的一些问题调查" class="headerlink" title="8.UE4C++中遇到的一些问题调查"></a>8.UE4C++中遇到的一些问题调查</h1><h2 id="1-Pointer-to-incomplete-class-type-is-not-allowed"><a href="#1-Pointer-to-incomplete-class-type-is-not-allowed" class="headerlink" title="1.Pointer to incomplete class type is not allowed"></a>1.Pointer to incomplete class type is not allowed</h2><p>在我使用一些组件指针的时候，想要得到组件的名称，使用<code>-&gt;</code>来调用函数的时候就出现了这个问题。</p>
<p><a href="https://stackoverflow.com/questions/12027656/pointer-to-incomplete-class-type-is-not-allowed" target="_blank" rel="noopener">Pointer to incomplete class type is not allowed</a></p>
<p>上面的链接有解释。</p>
<p><strong>An “incomplete class” is one declared but not defined.E.g.</strong></p>
<p>最终的解决是，好好的把相应的头文件包含进去。不是说可以声明指针就代表这个指针就能调用这个指针代表的类中所有公开函数了。话说，没有好好的包含人家的头文件却能在文件中没问题的声明这个类型的指针，对我来说真是邪门了。UE4真是搞不懂了。</p>
<h2 id="2-C-Cross-Reference"><a href="#2-C-Cross-Reference" class="headerlink" title="2.C++ Cross Reference"></a>2.C++ Cross Reference</h2><p>即可以解释上面我遇见的问题的原因。包含指针声明不代表编译器能找到指针指向内容的定义。</p>
<p>头文件的交叉引用，我觉得我本来是遇不见的，或者说遇见了也会不屑一顾，不会去使用的。</p>
<p>但是凡事都有例外不是。</p>
<p>基本来说，程序中出现使用交叉引用的话，就是程序设计出现了重大的问题，基本上需要重新设计了。但是我非要用这种交叉引用是有原因的…当然因为我水平不行是最大的原因。</p>
<p>要怎么解决这个问题呢？</p>
<ul>
<li><a href="https://blog.csdn.net/github_30605157/article/details/52063056" target="_blank" rel="noopener">C++交叉引用问题</a></li>
<li><a href="https://stackoverflow.com/questions/625799/resolve-build-errors-due-to-circular-dependency-amongst-classes" target="_blank" rel="noopener">Resolve build errors due to circular dependency amongst classes</a></li>
</ul>
<p>上面的两个文章链接，告诉我怎么解决交叉引用的问题。总结来说就是使用<strong>Forward Declaration</strong>。</p>
<p>我的解决方案就是对于相互引用的两个类<code>A</code>，<code>B</code>。分别置于不同文件<code>A.h</code>,<code>A.cpp</code>,<code>B.h</code>,<code>B.cpp</code>。我们的希望A中包含B的实例，但同时B中包含A的指针引用。</p>
<p>则此时对B来说，我就是在头文件中引用了A的指针，但是不实际使用A的内容（指针调用），于是就在<code>B.h</code>中添加<code>class A</code>的声明，但是不导入A的头文件。在<code>B.cpp</code>中引入A的头文件对指针加以使用。这样编译器就明白我到底在捣鼓什么了。</p>
<ul>
<li><a href="https://blog.csdn.net/yunyun1886358/article/details/5672574" target="_blank" rel="noopener">C++中前置声明的应用与陷阱</a></li>
</ul>
<p>上面的文章解释了前置声明的原理，感觉讲的非常好。</p>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的智能指针</title>
    <url>/UE4%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>对于内存使用的了解，就不得不了解指针。UE4拥有跟C++类似的智能指针，在这里对虚幻4的智能指针库的内容进行一些总结跟提炼，同时也需要对C++的智能指针进行深入的了解。</p>
<a id="more"></a>
<h1 id="UE4的智能指针"><a href="#UE4的智能指针" class="headerlink" title="UE4的智能指针"></a>UE4的智能指针</h1><p>智能指针并不能使用<code>UPROPERTY()</code>，<code>TSharedRef</code>,<code>TSharedPtr</code>,<code>TWeakPtr</code>等等。</p>
<p>上一次更新这篇文章是两年前，都两年了我还没深入了解UE4的智能指针，我也不知道我都干了些什么。</p>
<p>我应该对UE4的智能指针进行分类探讨，根据自己遇到过的情况。</p>
<h2 id="TWeakPtr"><a href="#TWeakPtr" class="headerlink" title="TWeakPtr"></a>TWeakPtr</h2><h2 id="TWeakObjectPtr"><a href="#TWeakObjectPtr" class="headerlink" title="TWeakObjectPtr"></a>TWeakObjectPtr</h2><p>关于<code>TWeakPtr</code>和<code>TweakObjectPtr</code>之间的区别：</p>
<p><strong>TWeakObjectPtr</strong>是针对<code>UObjects</code>的弱指针引用，<strong>TWeakPtr</strong>则是针对除了<code>UObjects</code>的弱指针引用。</p>
<blockquote>
<p>TWeakObjectPtr is for weak pointers to UObjects, TWeakPtr for pointers to everything else.</p>
<p>Since UObjects are garbage collected and shared pointers are reference counted, we cannot have the same weak pointer type for all, unfortunately.</p>
</blockquote>
<ul>
<li><a href="https://answers.unrealengine.com/questions/298868/difference-between-tweakptr-and-tweakobjectptr.html" target="_blank" rel="noopener">Difference between TWeakPtr and TWeakObjectPtr?</a></li>
</ul>
<p>参考链接：</p>
<ul>
<li><a href="https://api.unrealengine.com/INT/Programming/UnrealArchitecture/SmartPointerLibrary/index.html" target="_blank" rel="noopener">Unreal Smart Pointer Library</a> </li>
</ul>
<h1 id="C-的智能指针"><a href="#C-的智能指针" class="headerlink" title="C++的智能指针"></a>C++的智能指针</h1><p>指针的使用伴随着内存泄漏(memory leak)的问题，可能会发生内存泄漏的情况有：</p>
<ul>
<li>new或者malloc出来的内存因为程序员的疏忽忘记释放</li>
<li>程序运行发生错误(throw)，未能执行内存释放程序</li>
</ul>
<p>所以不是说只要程序员足够谨慎就能够避免指针造成的内存泄漏的问题。</p>
<h2 id="C-11中的智能指针"><a href="#C-11中的智能指针" class="headerlink" title="C++11中的智能指针"></a>C++11中的智能指针</h2><p>主要在用的智能指针有：unique_ptr, shared_ptr, weak_ptr。</p>
<p>这3种指针组件就是采用了boost里的智能指针方案。很多有用过boost智能指针的朋友，很容易地就能发现它们之间的关间：<br>|std|boost|功能说明|<br>|—-|—-|—-|<br>|unique_ptr|scoped_ptr|独占指针对象，并保证指针所指对象生命周期与其一致|<br>|shared_ptr|shared_ptr|可共享指针对象，可以赋值给shared_ptr或weak_ptr。<br>指针所指对象在所有的相关联的shared_ptr生命周期结束时结束，是强引用。|<br>|weak_ptr|weak_ptr|它不能决定所指对象的生命周期，引用所指对象时，需要lock()成shared_ptr才能使用。|</p>
<p>参考链接：</p>
<ul>
<li><a href="https://my.oschina.net/hevakelcj/blog/465978" target="_blank" rel="noopener">C++11中的智能指针</a></li>
</ul>
<h2 id="三种智能指针的特性用法"><a href="#三种智能指针的特性用法" class="headerlink" title="三种智能指针的特性用法"></a>三种智能指针的特性用法</h2><p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/haolexiao/article/details/56773039" target="_blank" rel="noopener">C++11及C++14标准的智能指针</a></li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p><code>std::weak_ptr</code>是一个很好的解决<strong>悬空指针</strong>问题的方式。使用原生指针（raw pointers）的话不知道现在所引用的资源是否已经被释放。而使<br>用<code>std::shared_ptr</code>来管理的话，<code>std::weak_ptr</code>只管使用，而不关心资源的使用情况，反正也不管理指向的资源。</p>
<p>因为本身<code>std::weak_ptr</code>并不能直接引用到对象，不会影响对象的自动释放，不会影响对象的引用计数，需要使用<code>lock()</code>来升级到<code>std::shared_ptr</code>来进行操作。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://my.oschina.net/u/2368952/blog/416606" target="_blank" rel="noopener">C++ weak pointer</a></li>
<li><a href="https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful" target="_blank" rel="noopener">When is std::weak_ptr useful?</a></li>
</ul>
<h2 id="比起直接使用new优先使用std-make-unique和std-make-shared"><a href="#比起直接使用new优先使用std-make-unique和std-make-shared" class="headerlink" title="比起直接使用new优先使用std::make_unique和std::make_shared"></a>比起直接使用new优先使用std::make_unique和std::make_shared</h2><p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/boydfd/p/5146432.html" target="_blank" rel="noopener">Item 21: 比起直接使用new优先使用std::make_unique和std::make_shared</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的函数回调实现</title>
    <url>/UE4%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>回调函数的含义，实际上我也不太清楚，搜回调函数得到的关键字有很多：闭包，代理，委托，Wrapper，等等。但有一点我很清楚，这些我都不太懂。</p>
<p>说是在不同的语言中有不同的叫法。其本质上就是一个函数指针，而在汇编层面，就是子程序代码的首地址。每一段编译器先放一个占位符，最后放入实际的值。</p>
<a id="more"></a>
<p>上面的话是<a href="http://sourcecodereadingofunreal.readthedocs.io/en/latest/content/programmingSkill.html" target="_blank" rel="noopener">Unreal用到一些编程技巧</a>里的内容。</p>
<h1 id="先理解什么是”函数回调”"><a href="#先理解什么是”函数回调”" class="headerlink" title="先理解什么是”函数回调”"></a>先理解什么是”函数回调”</h1><blockquote>
<p>A “callback” is any function that is called by another function whitch takes the first function as a parameter. A lot of the time, a “callback” is a function that is called when something happens. That something can be called an “event” in programmer-speak.</p>
</blockquote>
<p>摘自Stack Overflow：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/9596276/how-to-explain-callbacks-in-plain-english-how-are-they-different-from-calling-o" target="_blank" rel="noopener">How to explain callbacks in plain english? How are they different from calling one function from another function?</a></li>
</ul>
<p>实际的应用场景就类似：<strong>类A需要类B做一件事情，类B做完之后需要告知类A已经做完了这件事情，至于告知的具体方法(函数的具体实现)类A并没有事先告诉类B(编译期间)，等类B做完看一下类A留下的便条(绑定的事件)，根据信条里面的内容(函数的具体实现)来通知类A。</strong></p>
<p>用简单的代码来表示CallBack就是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"B work has done."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void B( void (A_prt) (void))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>学了C++的虚函数之后，理解起来就是快 =。=</p>
<h1 id="UE4中的函数回调-CallBack"><a href="#UE4中的函数回调-CallBack" class="headerlink" title="UE4中的函数回调(CallBack)"></a>UE4中的函数回调(CallBack)</h1><p>C++中应该有许多种方式的回调，UE C++(UnrealEngine中的C++)则是使用的<strong>DELEGATE</strong>和<strong>EVENT</strong>来实现。</p>
<p>关于UE C++的代理，存在着以下的几种方式：</p>
<ul>
<li>静态的Single-cast Delegates</li>
<li>Dynamic Single-cast Delegates</li>
<li>静态的Multi-cast Delegates</li>
<li>Dynamic Multi-cast Delegates</li>
</ul>
<p>这几种代理的实现有什么不同需要后续整理，可以参考：</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/533323/what-difference-between-delegates.html" target="_blank" rel="noopener">What difference betweens delegates?</a></li>
</ul>
<p>有的时候需要很好的利用一下UE4的<a href="https://answers.unrealengine.com/index.html" target="_blank" rel="noopener">官方论坛</a>，像是Stack Overflow一样。</p>
<h2 id="Dynamic-Multi-cast-Delegates"><a href="#Dynamic-Multi-cast-Delegates" class="headerlink" title="Dynamic Multi-cast Delegates"></a>Dynamic Multi-cast Delegates</h2><p>Dynamic Multi-cast Delegates是唯一的一种可以和UE4的Blueprint联动的代理实现方式。</p>
<p><strong>Dynamic Multi-cast Delegates的UE C++中的声明</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File: CallbackExample.h</span></span><br><span class="line"><span class="comment">//Class: ACallbackExample</span></span><br><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE(FZeroInputDelegate);    <span class="comment">//没有参数的声明方法</span></span><br><span class="line">UPROPERTY(BlueprintAssignable, Category=<span class="string">"UE C++ Book"</span>)    <span class="comment">//BlueprintAssignable属性使得这个代理在Blueprint中也取得到。 -&gt;此处在真正的工程中不应该写注释，会出编译问题</span></span><br><span class="line">FZeroInputDelegate TheZeroInputDelegate;</span><br><span class="line"></span><br><span class="line">DECLEAR_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FTwoInputsDelegate, <span class="keyword">float</span>, FloatVal, int32, IntVal);    <span class="comment">//两个参数的声明方法</span></span><br><span class="line">UPROPERTY(BlueprintAssignable, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">FTwoInputsDelegate TheTwoInputsDelegate;</span><br></pre></td></tr></table></figure></p>
<p>Tips:</p>
<ul>
<li>参数最大允许有8个。参数的声明类似上述两个参数的声明，先是类型后是参数名。</li>
<li>参数不同的代理声明只需要将上述的数字换成相应参数的英文就可以，比如说八个参数的情况声明代理的语句就会变成：<code>DELEAR_DYNAMIC_MULTICAST_DELEGATE_EightParams</code></li>
</ul>
<p>这样制作的代理，可以在UE的Blueprint中获得到这个代理（似乎是作为Event）并进行实现了。别忘了指定Event与Target。即把这个代理委托给一个类的实例(Instance)。在Blueprint中似乎是以<code>Event</code>而存在的，Blueprint中实现的操作是把这个调用的Event登录到这个代理上去。这样在UE C++中调用这个代理，也会调用Blueprint中的事件，执行这个事件的实现部分。</p>
<p><strong>调用Blueprint中的代理实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: CallbackExample.cpp</span></span><br><span class="line"><span class="comment">// Class: ACallbackExample</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ACallbackExample::ExecuteDelegate(<span class="keyword">const</span> <span class="keyword">float</span> FloatVal, <span class="keyword">const</span> int32 IntVal) -&gt; <span class="keyword">void</span> &#123;</span><br><span class="line">    TheZeroInputDelegate.Broadcast();</span><br><span class="line">    TheTwoInputsDelegate.Broadcast(FloatVal, IntVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>官方参考链接：</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates/Dynamic" target="_blank" rel="noopener">Dynamic Delegates</a></li>
<li><a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Delegates/Events" target="_blank" rel="noopener">Events</a><h2 id="Blueprint-Event与Blueprint-Function"><a href="#Blueprint-Event与Blueprint-Function" class="headerlink" title="Blueprint Event与Blueprint Function"></a>Blueprint Event与Blueprint Function</h2>关于事件与函数的区别，没有返回值的被叫做事件，有返回值的叫做函数。是否真实需要验证。在UE C++中可以登录Blueprint的事件，通过给UPROPERTY宏添加属性来完成。话说回来这个是函数，应该使用UFUNCTION宏才对，不知道为什么书上这么说。</li>
</ul>
<p>用于事件声明的属性有两种，区别的方式是是否在UE C++中有默认的实现。</p>
<ul>
<li><code>BlueprintImplementableEvent</code>:没有默认实现</li>
<li><code>BlueprintNativeEvent</code>:拥有默认实现</li>
</ul>
<p><strong>Blueprint Event,Blueprint Function在UE C++中的声明</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: CallbackExample.h</span></span><br><span class="line"><span class="comment">// Class: ACallbackExample</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BP Event</span></span><br><span class="line">UFUNCTION(BlueprintImplementableEvent, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FloatInputEvent</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> FloatVal)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintNativeEvent, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VectorInputEvent</span><span class="params">(<span class="keyword">const</span> FVector&amp; VecValue)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BP Function</span></span><br><span class="line">UFUNCTION(BlueprintImplementableEvent, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">IntInputFunction</span><span class="params">(<span class="keyword">const</span> int32 IntInput)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintNativeEvent, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">TArray&lt;<span class="keyword">float</span>&gt; VecArrayInputFuncion(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; VecValues);</span><br></pre></td></tr></table></figure></p>
<p><strong>Event的默认实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: CallbackExample.cpp</span></span><br><span class="line"><span class="comment">// Class: ACallbackExample</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static FVector TheVector事先声明的属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ACallbackExample::VectorInputEvent_Implementation(<span class="keyword">const</span> FVector&amp; VecValue)-&gt;<span class="keyword">void</span>&#123;</span><br><span class="line">    TheVector = VecValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ACallbackExample::VecArrayInputFuncion_Implementation(<span class="keyword">const</span> TArray&lt;FVector&gt;&amp; VecValues)-&gt; TArray&lt;<span class="keyword">float</span>&gt;&#123;</span><br><span class="line">    TArray&lt;<span class="keyword">float</span>&gt; Result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Val : VecValue)</span><br><span class="line">        Result.Emplace(FVector::Dist(TheVector, Val));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上的代码实装完成之后，继承了上面的<code>CallbackExample</code>类的Blueprint就可以在Blueprint Editor中对上述UE C++中的事件与函数进行重写了。</p>
<p>以上，是对UE中的代理与事件，在可用范围内的总结与实现。但是对于在什么情况下使用这一点上仍然有许多疑问。</p>
<hr>
<p>2020/06/09 更新</p>
<p>不知道我当时写下这篇文章的时候为什么没有对上面的<code>_Implementation</code>后缀产生大大的问号，定义了一个函数之后，函数的实现部分的函数名字竟然需要添加后缀，让人大呼这是什么抛瓦。</p>
<p>应为时间有限，就快速记录一下。</p>
<p>像上面那样函数的定义和实现都是在同一个文件的<code>.h</code>,<code>.cpp</code>中实现的，就是说：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SampleA.h</span></span><br><span class="line">UFUNCTION(BlueprintNativeEvent, Category=<span class="string">"Execute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SampleA.cpp</span></span><br><span class="line"><span class="keyword">void</span> SampleA::Execute_Implementation(<span class="keyword">int</span> value) <span class="keyword">const</span>&#123; &#125;</span><br><span class="line"><span class="comment">// auto SampleA::Execute_Implementation(int value) const&#123;// default Implementation &#125;   // 类型推断还能这么用的吗</span></span><br></pre></td></tr></table></figure></p>
<p>这样的是好像也没有什么太大的问题，好像也很容易理解，但是当这个类似于事件的提供移到子类的时候，就有些让人摸不到头脑了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SampleA.h</span></span><br><span class="line">UFUNCTION(BlueprintNativeEvent, Category=<span class="string">"Execute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SampleA.cpp</span></span><br><span class="line"><span class="comment">// 这里应该没有实现，但是这个函数是有默认实现的，没错，蓝图那边有默认实现，如果我们没有这个C++的_Implementation实现，那么就是蓝图的默认实现被调用，但是我们对C++的_Implementation进行了实现，那么就是C++这部分实现会被调用。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SampleB.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleB</span> :</span> <span class="keyword">public</span> SampleA</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 没有这个子类的声明会报错</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Execute_Implementation</span><span class="params">(ine value)</span> <span class="keyword">const</span> override</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SampleB.cpp</span></span><br><span class="line"><span class="keyword">void</span> SampleB::Execute_Implementation(ine value) <span class="keyword">const</span>&#123; <span class="comment">// 函数实现&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果是继承来的<code>Execute</code>就需要这样的样子，总之就是，带有</p>
<ul>
<li>UFUNCTION(BlueprintImplementableEvent, Category = “Foo”)</li>
<li>UFUNCTION(BlueprintNativeEvent, Category = “Foo”)</li>
</ul>
<p>的可能都要这么实现。</p>
<ul>
<li><a href="https://www.epicgames.com/unrealtournament/forums/unreal-tournament-development/ut-development-programming/11600-what-s-the-deal-with-appending-_implementation-to-functions" target="_blank" rel="noopener">What’s the deal with appending ‘_Implementation’ to functions?</a></li>
</ul>
<blockquote>
<p>FUNCTION_Implementation is for the UnrealEngine framework. Calling FUNCTION will also call the _Implementation part. FUNCTION is only a wrapper generated by the UHT. CPP includes the generated classes/headers.</p>
</blockquote>
<hr>
<h2 id="UE-C-的函数回调实现"><a href="#UE-C-的函数回调实现" class="headerlink" title="UE C++的函数回调实现"></a>UE C++的函数回调实现</h2><p>说实话，函数回调跟代理的概念我还是没太理清。在许多的实际应用上，有些操作你叫它代理也行，叫它函数回调也行。用自己的感受就好比是参考系不同一样。就像上面举的函数回调的例子来说：</p>
<p>函数回调就是类A想要在类B在运行中达成某种条件的时候调用类A提供的函数。这个时候类A是主参考系。</p>
<p>代理就是类B在运行中达成某种条件的时候想要通知类A，但是不知道方法，而且觉得这个方法还是由类A决定为好，于是就提供给类A一个纸条(代理)，类A要实现代理内容。这个时候类B就是主参考系了。</p>
<p>我是这样理解的，不知道是否正确。但是在UE4之中delegate的出现比较多，之后就用代理来称呼了。</p>
<p>在Blueprint和AnimationBlueprint中可以很容易的实现代理，利用Blueprint自带的<strong>Event Dispatchers</strong>就可以快速的实现。函数绑定的时候需要注意的是要Cast正确的对象。</p>
<p>在UE C++实现代理就稍微有些复杂。但还是很简单的。</p>
<h2 id="一些代理之间的区别"><a href="#一些代理之间的区别" class="headerlink" title="一些代理之间的区别"></a>一些代理之间的区别</h2><p>在对UE4的代理越来越多的使用之后，对代理这个概念有了深入的了解，或者说是开始一点点接受并认同<strong>代理(delegate)</strong>这个概念的存在了。</p>
<p>关于UE4中的各种类型的代理准备在上面逐一记录使用方法(TODO)，这里主要是用来记录我调查了某种代理之间的使用区别。</p>
<h3 id="AddDynamic-amp-AddUniqueDynamic"><a href="#AddDynamic-amp-AddUniqueDynamic" class="headerlink" title="AddDynamic &amp; AddUniqueDynamic"></a>AddDynamic &amp; AddUniqueDynamic</h3><p>据网上的资料所说，<code>AddUniqueDynamic</code>类型的代理绑定了函数之后，相同对象的相同函数被重复绑定也只会被调用一次，而<code>AddDynamic</code>则是会被调用绑定次数。</p>
<blockquote>
<p>Consider the following fabricated situations :</p>
<p>Situation 1 :<br>Tank-&gt;OnTankDeath.AddDynamic(this, &amp;ATankPlayerController::OnTankDeath);<br>Tank-&gt;OnTankDeath.AddDynamic(this, &amp;ATankPlayerController::OnTankDeath);</p>
<p>Situation 2 :<br>Tank-&gt;OnTankDeath.AddUniqueDynamic(this, &amp;ATankPlayerController::OnTankDeath);<br>Tank-&gt;OnTankDeath.AddUniqueDynamic(this, &amp;ATankPlayerController::OnTankDeath);</p>
<p>If you were to then call : OnTankDeath.Broadcast();</p>
<p>For situation 1 , ATankPlayerController::OnTankDeath would be invoked or called twice.<br>For situation 2 , ATankPlayerController::OnTankDeath would be invoked or called only once.</p>
<p>Essentially AddUniqueDynamic adds the dynamic delegate only if it isnt already present in the &gt; list of invocable dynamic delegates associated with OnTankDeath.</p>
</blockquote>
<ul>
<li><a href="https://community.gamedev.tv/t/difference-between-adddynamic-adduniquedynamic/37003" target="_blank" rel="noopener">Difference between AddDynamic &amp; AddUniqueDynamic?</a></li>
</ul>
<h1 id="为什么要使用Delegate和Event？"><a href="#为什么要使用Delegate和Event？" class="headerlink" title="为什么要使用Delegate和Event？"></a>为什么要使用Delegate和Event？</h1><p>关于代理的实现，就算明白了也需要知道需要在什么情况下使用代理，否则没有意义。</p>
<h2 id="关于Event"><a href="#关于Event" class="headerlink" title="关于Event"></a>关于Event</h2><p>在UE4中的Blueprint中应没有委托这一说，全部是以Event的名字来称呼的。</p>
<h2 id="Delegate的使用情况"><a href="#Delegate的使用情况" class="headerlink" title="Delegate的使用情况"></a>Delegate的使用情况</h2><h3 id="推测1"><a href="#推测1" class="headerlink" title="推测1"></a>推测1</h3><p>面向对象的说法只是一种理想的情况，总会有想要实现别人功能的情况。比如说ClassA想要实现一个功能，但是明显这个功能是由ClassB负责的部分，要是自己来实现的话不好，所以自己的话，声明一个Delegate，想用的时候就把这个广播出去(Broadcast)，实现了这接口的内容会被调用。</p>
<p>只言片语：</p>
<blockquote>
<p>现在我要对一系列数据进行排序，而排序算法可能比较复杂，我不会自己写，我想调用Array.Sort方法，微软为我们提供了快速排序算法。<br>但是这里有一个问题——我要实现自定义排序规则，比如对于字符串，默认的是按字母顺序，但现在我想这样排序：</p>
<p>按字符串长度排序，只有当长度不同时，再按字母排序。</p>
<p>显然，微软不可能提供这样“个性”的排序方法，那是不是说，就必须让我们自己去写快速排序算法呢？<br>不需要！<br>我们只需要使用委托，就能实现这个要求：<br>string[]strs=”I like C# very much”.Split();<br>Array.Sort(strs,Rule);<br>int void Rule(string first,string second)<br>{<br>return first.Length==second.Length?first.CompareTo(second):first.Length.CompareTo(second.Length);<br>}</p>
<p>显然，我并不需要知道快速排序算法的逻辑，我只需要告之排序规则，就实现了我的个性排序。</p>
<p>试问：如果没有委托，你如何解决这个问题？</p>
</blockquote>
<h1 id="C-中的代理实现"><a href="#C-中的代理实现" class="headerlink" title="C++中的代理实现"></a>C++中的代理实现</h1><p>代理应该涉及了许多知识，完全理解需要后续的更新整理。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://www.cppblog.com/huangwei1024/archive/2010/11/17/133870.html" target="_blank" rel="noopener">C++中实现委托（Delegate）</a></li>
<li><a href="http://aigo.iteye.com/blog/2301010" target="_blank" rel="noopener">C++实现Delegate Event实例(例子、example、sample)</a></li>
<li><a href="https://blog.csdn.net/lijun538/article/details/51277199" target="_blank" rel="noopener">C++委托实现(函数指针，function+bind，委托模式)</a></li>
<li><a href="https://blog.csdn.net/cyxisgreat/article/details/7506672" target="_blank" rel="noopener">高效C++委托的原理</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGl学习内容整理</title>
    <url>/OpenGl%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>主要是记录自己学习OpenGl内容。</p>
<a id="more"></a>
<h3 id="OpenGL学习网站"><a href="#OpenGL学习网站" class="headerlink" title="OpenGL学习网站"></a>OpenGL学习网站</h3><p>参考：</p>
<ul>
<li><a href="https://learnopengl.com" target="_blank" rel="noopener">Learn OpenGL</a></li>
<li><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">Learn OpenGL中文翻译</a></li>
</ul>
]]></content>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>UnrealEngine着色器开发整理</title>
    <url>/UnrealEngine%E7%9D%80%E8%89%B2%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>整理自己在学习Unreal Engine 4着色器过程中遇到的问题和知识点。</p>
<a id="more"></a>
<h2 id="Unreal-Engine-4设定"><a href="#Unreal-Engine-4设定" class="headerlink" title="Unreal Engine 4设定"></a>Unreal Engine 4设定</h2><h3 id="1-UE4的内置材质Shader函数库位置"><a href="#1-UE4的内置材质Shader函数库位置" class="headerlink" title="1. UE4的内置材质Shader函数库位置"></a>1. UE4的内置材质Shader函数库位置</h3><p>UE4Shader的编写入门反而相对比较容易，使用自带的各种函数库拉拉线竟然就可以完成。函数库的位置都在:</p>
<p>位置：</p>
<ul>
<li><code>C:\Program Files\Epic Games\UE_4.19\Engine\Shaders\Private</code> UE4的安装文件夹中</li>
</ul>
<h3 id="2-Material-cpp文件位置"><a href="#2-Material-cpp文件位置" class="headerlink" title="2. Material.cpp文件位置"></a>2. Material.cpp文件位置</h3><ul>
<li><code>C:\Program Files\Epic Games\UE_4.19\Engine\Source\Runtime\Engine\Private\Materials</code></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>UE4中的粒子特效</title>
    <url>/UE4%E4%B8%AD%E7%9A%84%E7%B2%92%E5%AD%90%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>主要是用来记录学习虚幻引擎4的粒子的过程</p>
<a id="more"></a>
<h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><h3 id="Particles-with-Unreal-Engine-4"><a href="#Particles-with-Unreal-Engine-4" class="headerlink" title="Particles with Unreal Engine 4"></a>Particles with Unreal Engine 4</h3><p>先是在UE4提供的官方教程中整理基础的知识点。<a href="https://www.youtube.com/playlist?list=PLZlv_N0_O1gYDLyB3LVfjYIcbBe8NqR8t" target="_blank" rel="noopener">官方Youtube视频</a>。</p>
<h4 id="Particle"><a href="#Particle" class="headerlink" title="Particle"></a>Particle</h4><ul>
<li>Particle</li>
<li>Particle System</li>
<li>Emitter Actor</li>
<li>Particle System Component</li>
<li>Cascade</li>
</ul>
<h4 id="Emitter"><a href="#Emitter" class="headerlink" title="Emitter"></a>Emitter</h4><ul>
<li>Emitter</li>
<li>Module<ul>
<li>tips:<ul>
<li>在Emitter(粒子发射器)的各个Module中，按住<code>alt</code>键拖动可以复制Module</li>
<li>按住<code>shift</code>可以共享Module，即只需要修改一个其他的都会被修改</li>
</ul>
</li>
</ul>
</li>
<li>Type Data</li>
<li>Distributions</li>
</ul>
<h2 id="GPU粒子"><a href="#GPU粒子" class="headerlink" title="GPU粒子"></a>GPU粒子</h2><h2 id="CPU粒子"><a href="#CPU粒子" class="headerlink" title="CPU粒子"></a>CPU粒子</h2><ul>
<li><a href="https://software.intel.com/zh-cn/articles/maximizing-visuals-with-cpu-particles-in-unreal-engine-4" target="_blank" rel="noopener">利用 Unreal Engine 4 的 CPU 粒子最大限度地提升视觉效果</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>UE4</tag>
        <tag>Particles</tag>
      </tags>
  </entry>
  <entry>
    <title>关于学习UE4的粒子系统过程中遇到的疑问</title>
    <url>/%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0UE4%E7%9A%84%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%96%91%E9%97%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>UE4中需要了解的基础概念</title>
    <url>/ue4-basic-knowledge/</url>
    <content><![CDATA[<p>为了记录自己在学习UE引擎过程中遇到的一些疑问点。亦或者是一些值得去记录的知识点。<br><a id="more"></a></p>
<h1 id="UE4中常见的知识点"><a href="#UE4中常见的知识点" class="headerlink" title="UE4中常见的知识点"></a>UE4中常见的知识点</h1><h2 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h2><ul>
<li>~2020/06 入社现在的公司之前<ul>
<li>在之前的公司陆陆续续更新了好多东西，有些杂乱倒也还好，今后准备更新更多UE4的内容</li>
</ul>
</li>
<li>2020/06/03 更新一些使用VisualStudio的UE4SetUp内容</li>
<li>2020/08/21 更新UE4中的修饰符(Specifiers)部分    </li>
</ul>
<h2 id="C-部分"><a href="#C-部分" class="headerlink" title="C++部分"></a>C++部分</h2><h3 id="C-与C-的不同之处"><a href="#C-与C-的不同之处" class="headerlink" title="C++与C#的不同之处"></a>C++与C#的不同之处</h3><p>时隔多年见到C++的第一个违和感是头文件，为什么需要写头文件这个问题我找了一些别人写的代码发现了一下几个规则：</p>
<ul>
<li><p>在C++的头文件中<code>SampleCode.h</code>中一般都会预先定义一些东西</p>
<ul>
<li><p>需要包含的其他头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Engine.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyAppUtilities.h"</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义需要使用的宏 预处理（<a href="www.runoob.com/cplusplus/cpp-preprocessor.html">C++的预处理器需要了解一下</a>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般常量居多？</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415926</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义类，类中包含该有的成员，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span>&#123;</span></span><br><span class="line">    <span class="comment">//Attributes or functions</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="UE4中的C-不同的地方"><a href="#UE4中的C-不同的地方" class="headerlink" title="UE4中的C++不同的地方"></a>UE4中的C++不同的地方</h3><h4 id="1-UCLASS-宏"><a href="#1-UCLASS-宏" class="headerlink" title="1.UCLASS()宏"></a>1.UCLASS()宏</h4><p>想要让类与UE4的类库联动的话，就需要这个宏。</p>
<h5 id="UCLASS-大概的使用方法"><a href="#UCLASS-大概的使用方法" class="headerlink" title="UCLASS()大概的使用方法"></a>UCLASS()大概的使用方法</h5><p>Sample Code:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Engine.h"</span>  <span class="comment">//如果需要使用UE的library的话</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyAppUtilities.h"</span></span></span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UMyClass</span> :</span> <span class="keyword">public</span> UObject&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数(公有的？)</span></span><br><span class="line">    UMyClass();</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, Category = <span class="string">"MyApp"</span>)</span><br><span class="line">    int32 IntProp;</span><br><span class="line"></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category = <span class="string">"MyApp"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">LengthOfSomething</span><span class="params">(<span class="keyword">const</span> int32 index)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    TArray&lt;<span class="keyword">int</span>&gt; IntArrayWork;</span><br><span class="line">    <span class="comment">//标准c++中的数组声明</span></span><br><span class="line">    <span class="comment">//std::vector&lt;int&gt; IntArrayWork;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>UCLASS()</code>，如果需要继承UE的类库，则都要加上这个。<strong>最好声明的类名也以<code>U</code>开头为好？</strong> 但是我觉得这种声明不是跟UE的类库搞混了吗，辨识度低我觉得应该没有这么智障的规则。好的，有这种规则好像。类似的其他的以<code>E,F,I,T,S</code>等等的字母作为变量名的开始。</p>
<p>关于在头文件中添加注释的问题，在UE4的执行中倘若添加了日语(应该中文也一样)的注释，有可能会发生问题。所以在头文件中尽可能的使用英文注释。还有应该避免在各种宏的后面直接追加注释。</p>
<p>就目前的问题来说在<code>UFUNCTION</code>宏的后面直接加入日文注释(UTF-8)的话，会有编译无法通过的问题。所以为了避免上述问题应该尽量：</p>
<ul>
<li>头文件中使用英文注释</li>
<li>不要直接在各种UE4的宏后面(例如<code>UFUNCTION</code>后)直接添加注释。</li>
</ul>
<h5 id="UCLASS-参数的含义"><a href="#UCLASS-参数的含义" class="headerlink" title="UCLASS() 参数的含义"></a>UCLASS() 参数的含义</h5><p><strong>CPPExampleActor.h</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/Actor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppExampleStruct.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppExampleEnum.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CpExampleActor.generated.h"</span></span></span><br><span class="line"></span><br><span class="line">UCLASS(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACppExampleActor</span> :</span> <span class="keyword">public</span> AActor&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EdtAnywhere, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">    FCppExampleStruct MyStructProp;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">    ECppExampleEnum Type;</span><br><span class="line"></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">MyActorFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> Input)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>通过指定<code>UNCLASS()</code>的参数，可以指定类的类型。</p>
<ul>
<li><strong>BlueprintType</strong>表示这个类可以作为Blueprint的变量来使用。<ul>
<li><code>UPROPERTY()</code>的声明，在这个Actor的Detail面板上可以看到该<code>Category</code>下有声明的<code>MyStructProp</code>和<code>Type</code>属性。</li>
<li>具体的<code>BlueprintType</code>的使用例子则仍需要调查。<code>BlueprintType</code>类型能做到的事情。</li>
</ul>
</li>
<li><p>多个参数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )</span><br></pre></td></tr></table></figure>
<p>  这个的使用含义现在还不清楚各自代表着什么意思。</p>
</li>
</ul>
<h5 id="USTRUCT-结构体"><a href="#USTRUCT-结构体" class="headerlink" title="USTRUCT()结构体"></a>USTRUCT()结构体</h5><p><strong>CppExampleStruct.h</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppExampleStruct.generated.h"</span></span></span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FCppExampleStruct</span> &#123;</span></span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">    <span class="keyword">float</span> Value;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=<span class="string">"UE C++ Book"</span>)</span><br><span class="line">    int32 Index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>构造体的声明名字最好以<code>F</code>开始。其他的基本上使用方法与类相同。</p>
<h5 id="UENUM-枚举类型"><a href="#UENUM-枚举类型" class="headerlink" title="UENUM()枚举类型"></a>UENUM()枚举类型</h5><p><strong>CppExampleEnum.h</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ECppExampleEnum</span> :</span> uint8 &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Foo,</span><br><span class="line">    Bar</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于<code>enum class ECppExampleEnum : uint8</code>这种写法有些迷惑。</p>
<ul>
<li><code>class</code>是为了使枚举类型更安全。为什么安全，参考下面的链接。之后整理。</li>
<li><code>uint8</code>是为了指定枚举器的基础类型。</li>
</ul>
<p>参考链接:</p>
<ul>
<li><a href="https://blog.csdn.net/sanoseiichirou/article/details/50180533#2-enum-class-%E5%92%8C-enum-struct" target="_blank" rel="noopener">C++11的enum class &amp; enum struct和enum</a></li>
<li><a href="https://blog.csdn.net/sanoseiichirou/article/details/50171727" target="_blank" rel="noopener">C\C++中的整形提升</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf" target="_blank" rel="noopener">C++标准文档-n2347</a></li>
</ul>
<h4 id="2-GENERAED-BODY"><a href="#2-GENERAED-BODY" class="headerlink" title="2.GENERAED_BODY()"></a>2.GENERAED_BODY()</h4><p>在阅读源码的时候会发现还有一个<code>GENERATED_UCALSS_BODY()</code>的宏，这两者之间又有区别。</p>
<p>为什么要使用这个宏呢？</p>
<blockquote>
<p>Those macro pastes code generated by UnrealHeaderTool (UHT) contained in HeaderFileName.generated.h to class or struct deceleration, it is required for UObject to properly function. It’s primerly for reflection system, UHT maps your class and generate registration code, so you don’t need to register class, properties and and functions to that system, UHT prepares that for you + it includes helpful functions like StaticClass() which you probably already meet. But it can’t alter how C++ compiler work and you need to paste the code that it prepares via that macro to your class.</p>
<p>In C++ you can’t read structure of you code after compilation, everything is turned in to numbers and addresses, so application it self it need to implement so called reflection system in order to see it’s classes, properties and functions, to see it’s own reflection, like animal having ability to recognize it self in reflection, like name suggests and this is what UE4 and UHT provides. This way for example editor see all classes, properties and nodes based from C++. You can use it in game too to create auto discovery of actor classes and there properties, create smart UI so you don’t need to make new UI for each thing.</p>
<p>The link provided by ali explains the diffrence between the too, but you should use GENERATED_BODY() as other one is old method, it’s still being keeped alive as some of engine code still didn’t switch to new macro.</p>
</blockquote>
<p>这段很长，是抄自<a href="https://answers.unrealengine.com/questions/772178/what-do-generated-body-and-generated-uclass-body-d.html?sort=oldest" target="_blank" rel="noopener">What do, GENERATED_BODY() and GENERATED_UCLASS_BODY(), do?</a></p>
<p>当我们定义了GENERATED_BODY()宏之后，构造函数（constructor）就不是必须的了。但是如果需要的话还是可以照常进行声明和定义。</p>
<blockquote>
<p>The other difference is that, in comparison to GENERATED_UCLASS_BODY(), GENERATED_BODY() doesn’t have the public specifier in it, so any class members that are declared after it are private by default (you can explicitly declare them as public). In your situation, please make sure that you have your constructor declared and defined correctly:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.h file</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    GENERATED_BODY()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AFPSGameMode(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp file</span></span><br><span class="line">AFPSGameMode::AFPSGameMode(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// constructor functionality</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-UPROPERTY-UFUNCTION"><a href="#3-UPROPERTY-UFUNCTION" class="headerlink" title="3.UPROPERTY() UFUNCTION()"></a>3.UPROPERTY() UFUNCTION()</h4><p>使用这个声明的属性跟方法UE的Blueprint可以使用。</p>
<h5 id="UPROPERTY-宏"><a href="#UPROPERTY-宏" class="headerlink" title="UPROPERTY()宏"></a>UPROPERTY()宏</h5><p><code>UPROPERTY()</code>的参数的含义</p>
<ul>
<li><p><code>UPROPERTY()</code>没有参数的情况，UE4的Blueprint和Level Editor都不能读取或者修改，但是却可以将这个变量纳入到UE4的GC对象中。比如：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY()</span><br><span class="line">AActor* OwningActor;</span><br></pre></td></tr></table></figure>
<p>  这种情况，如果<code>OwningActor</code>拥有了实例化对象，不手动释放也是没有问题的。或者说注意别手动释放了，会出问题的。</p>
</li>
<li><code>UPROPERTY(EditAnywhere, Category=&quot;UE C++ Book&quot;</code>,<code>EditAnywhere</code>属性表示在Level Editor中也可以操作这个属性。<ul>
<li>那么Blueprint与Level Editor的差别在哪里，需要调查。<ul>
<li>猜测的结果，Blueprint就是那个连来连去的蓝图，可以在那个蓝图的编辑器中取到属性。</li>
<li>Level Editor指的是操作的画面，在Level Editor中可以取到的意思应该是在Detail panel中直接设定或者读取值那样。</li>
</ul>
</li>
</ul>
</li>
<li><code>UPROPERTY(BlueprintReadWrite, Category=&quot;UE C++ Book&quot;)</code>,<code>BlueprintReadWrite</code>表示Blueprint可以读写。</li>
<li>其他的属性，还有<code>meta</code>属性可以查找下面的链接：<ul>
<li><a href="http://api.unrealengine.com/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html" target="_blank" rel="noopener">Property Specifiers</a></li>
<li><a href="http://api.unrealengine.com/INT/Programming/UnrealArchitecture/Reference/Metadata/index.html" target="_blank" rel="noopener">Metadata Specifiers</a><h5 id="UFUNCTION宏"><a href="#UFUNCTION宏" class="headerlink" title="UFUNCTION宏"></a>UFUNCTION宏</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable,Category = <span class="string">"UE C++"</span>)</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">FunctionName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">float</span> Variable)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>像上面的使用方法，在函数的前面添加<code>UNFUNCTION macro</code>宏可以制作UE4的Blueprint编辑器的函数节点以供调用。在虚幻4的Blueprint编辑器中使用此函数。</p>
<h4 id="4-TArray-UE4中的数组（重要）"><a href="#4-TArray-UE4中的数组（重要）" class="headerlink" title="4.TArray-UE4中的数组（重要）"></a>4.TArray-UE4中的数组（重要）</h4><p>先上本家，官方文档<a href="https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/TArrays" target="_blank" rel="noopener">TArray:Arrays in Unreal Engine</a>。</p>
<p>再上中文翻译<a href="https://blog.csdn.net/cartzhang/article/details/45367171" target="_blank" rel="noopener">虚幻引擎中的数组–TArry:Arrays</a></p>
<h4 id="5-C-中的静态函数static与UE-C-Unreal-Engine-C-的静态函数"><a href="#5-C-中的静态函数static与UE-C-Unreal-Engine-C-的静态函数" class="headerlink" title="5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数"></a>5.C++中的静态函数static与UE C++(Unreal Engine C++)的静态函数</h4><p>在C++中的静态函数与非静态函数的执行确实是有差别的。</p>
<p>复习一下C++中的静态函数：</p>
<ul>
<li>static修饰变量</li>
<li>static修饰函数<br>参考文章：</li>
<li><a href="http://zheming.wang/blog/2012/06/28/18316F9F-EB98-4088-AE29-C151BAEC8E71/" target="_blank" rel="noopener">C/C++ 中的static关键字</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/y5f6w579.aspx" target="_blank" rel="noopener">存储类 (C++)</a></li>
<li><a href="http://c.biancheng.net/cpp/biancheng/view/210.html" target="_blank" rel="noopener">C++静态成员函数</a></li>
<li><a href="http://c.biancheng.net/cpp/biancheng/view/209.html" target="_blank" rel="noopener">C++ static静态成员变量</a></li>
</ul>
<p>UE C++中关于静态函数的使用应该大同小异，但是也不排除有差别的可能性。</p>
<p>将来可能会派上用场的文章</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/716472/%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%AB%E3%82%B9%E3%82%BF%E3%83%86%E3%82%A3%E3%83%83%E3%82%AF%E5%A4%89%E6%95%B0%E3%82%92%E6%8C%81%E3%81%9F%E3%81%9B%E3%81%9F%E3%81%84.html" target="_blank" rel="noopener">クラスにスタティック変数を持たせたい</a></li>
</ul>
<h4 id="6-Blueprint函数node-节点-的输入与输出"><a href="#6-Blueprint函数node-节点-的输入与输出" class="headerlink" title="6.Blueprint函数node(节点)的输入与输出"></a>6.Blueprint函数node(节点)的输入与输出</h4><p>在UE C++中函数的参数对应Blueprint的node的输入pin，函数的返回值则对应着node的输出pin<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable,Category=<span class="string">"classcategory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">const</span> <span class="keyword">int</span>&amp; c,<span class="keyword">int</span>&amp; d)</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述的情况下<code>a,b,c</code>三个变量对应着node的三个输入pin，但是<code>return value,d</code>对应着node的输出pin。也就是说：<strong>没有<code>const</code>修饰的引用型参数会被分配到输出pin的阵营中。</strong></p>
<p>这里便引申出几个问题</p>
<ul>
<li>UE C++的函数参数为什么要使用<code>const</code>修饰，使用常量的必要性是什么</li>
<li>万一想要使用<code>const</code>修饰的引用型参数作为node的输入pin怎么办</li>
<li>想要增加node的输出pin的话，除此之外还有别的写法么</li>
</ul>
<h5 id="Blueprint支持的数据类型很有限"><a href="#Blueprint支持的数据类型很有限" class="headerlink" title="Blueprint支持的数据类型很有限"></a>Blueprint支持的数据类型很有限</h5><ul>
<li><code>bool</code></li>
<li><code>uint8</code></li>
<li><code>int32</code></li>
<li><code>float</code></li>
</ul>
<h4 id="7-UE4的Head-File"><a href="#7-UE4的Head-File" class="headerlink" title="7.UE4的Head File"></a>7.UE4的Head File</h4><p>UE4中的头文件有许多中，为了能够分清使用方法把遇到的头文件整理一下</p>
<h5 id="Actor-h"><a href="#Actor-h" class="headerlink" title="Actor.h"></a>Actor.h</h5><p>一般的写法是<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/Actor.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>一般是继承了UE4中的<code>Actor</code>类的话都需要包含这个头文件。</p>
<h5 id="xxx-generated-h"><a href="#xxx-generated-h" class="headerlink" title="xxx.generated.h"></a>xxx.generated.h</h5><p>比如说<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CppGate.generated.h"</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个头文件是有UE4的UnrealHeaderTool自动生成的文件。如果类继承了<code>UObject</code>类并且想要在Blueprint中使用这个类的话，就需要include这个头文件。而且需要把这个头文件放到所有的头文件的最后才行。</p>
<h4 id="8-UE4中的特殊容器"><a href="#8-UE4中的特殊容器" class="headerlink" title="8.UE4中的特殊容器"></a>8.UE4中的特殊容器</h4><h5 id="1-FVector"><a href="#1-FVector" class="headerlink" title="1.FVector"></a>1.FVector</h5><p>一个表示3D空间的向量。可以用来表示空间的一个点或者方向。</p>
<p>参考链接：</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/API/Runtime/Core/Math/FVector/" target="_blank" rel="noopener">FVector</a></li>
</ul>
<h4 id="9-类的初始值设定"><a href="#9-类的初始值设定" class="headerlink" title="9.类的初始值设定"></a>9.类的初始值设定</h4><p>基础类型变量的初始化可以在声明的同时进行，以外的数据类型(FVector等)初始化需要在构造函数中进行。静态变量的初始化则需要在类外进行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ClassExample::static_var;  //equle 0</span><br><span class="line">//or lik this</span><br><span class="line">int ClassExample::static_var = 4;</span><br></pre></td></tr></table></figure></p>
<h3 id="pragma-once-vs-include-guard"><a href="#pragma-once-vs-include-guard" class="headerlink" title="#pragma once vs include guard"></a>#pragma once vs include guard</h3><p>打开UE工程看到一些<code>.h</code>头文件的源码的时候看到了<code>#pragma once</code>有些困惑，不知道是做什么用的。于是调查了一下。</p>
<p>总体来说这两个命令都是为了避免同一个头文件被include多次</p>
<p>方式1：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SOMEFILE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOMEFILE_H_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>方式2：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h4 id="ifndef方式"><a href="#ifndef方式" class="headerlink" title="#ifndef方式"></a>#ifndef方式</h4><p>这种方式受C/C++语言标准支持，可以保证同一个文件不会被同时包含，也能保证内容完全相同的两个文件（或者代码片段）不会被同时包含。缺点是不同头文件中的宏的名字如果相同，会导致编译器找不到声明的问题。另外由于编译器每次需要打开头文件来判定是否有重复的定义，会导致编译的时间要长。</p>
<h4 id="progma-once方式"><a href="#progma-once方式" class="headerlink" title="#progma once方式"></a>#progma once方式</h4><p>这种方式是保证“物理存在上”同一个文件不会被包含多次。而不是内容相同的两个文件。而且无法对一个头文件中一段代码做<code>pragma once</code>声明，只能针对文件。当然也不会发生第一种方式的宏名碰撞引发的问题。</p>
<p>使用哪一种方式见仁见智，有好处有坏处。根据情况使用。</p>
<ul>
<li><a href="https://www.cnblogs.com/hokyhu/archive/2009/03/30/1425604.html" target="_blank" rel="noopener">附上别人的博客链接: #pragma once与#ifndef解析</a></li>
<li><a href="flast.hateblo.jp/entry/2015/12/05/000000">时间线比较新的分析: インクルードガードとpragma once</a></li>
<li><a href="https://stackoverflow.com/questions/1143936/pragma-once-vs-include-guards" target="_blank" rel="noopener">stackoverflow上关于上述两种方式的争论: #pragma once vs include guards?</a></li>
</ul>
<h3 id="C-中的类与结构体"><a href="#C-中的类与结构体" class="headerlink" title="C++中的类与结构体"></a>C++中的类与结构体</h3><p>参考链接：</p>
<ul>
<li><a href="https://blog.csdn.net/Loving_Forever_/article/details/51483828" target="_blank" rel="noopener">详解C结构体、C++结构体 和 C++类的区别</a></li>
</ul>
<h3 id="开启HSLS语法高亮"><a href="#开启HSLS语法高亮" class="headerlink" title="开启HSLS语法高亮"></a>开启HSLS语法高亮</h3><h4 id="HLSL-Tools-for-Visual-Studio"><a href="#HLSL-Tools-for-Visual-Studio" class="headerlink" title="HLSL Tools for Visual Studio"></a>HLSL Tools for Visual Studio</h4><p>应该是HLSL的语法编辑器插件，有自动补全的功能，附上下载链接。但是并没有解语法高亮的问题。</p>
<p>下载链接：</p>
<ul>
<li><a href="https://marketplace.visualstudio.com/items?itemName=TimGJones.HLSLToolsforVisualStudio" target="_blank" rel="noopener">HLSL Tools for Visual Studio</a></li>
</ul>
<h4 id="在VS2017中开启语法高亮（syntax-high-lighting）"><a href="#在VS2017中开启语法高亮（syntax-high-lighting）" class="headerlink" title="在VS2017中开启语法高亮（syntax high lighting）"></a>在VS2017中开启语法高亮（syntax high lighting）</h4><p>虽然不是针对VS2017的解决方案，但是设定之后的确解决的这个问题：</p>
<p>设定顺序：</p>
<ul>
<li>在VS2017中 Go to Tools -&gt; Options -&gt; Text Editor -&gt; Fie Extension 在这里选择编辑文件的扩展名与文法编辑器，然后添加保存。</li>
</ul>
<p>这样设定应该里面有效果了。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/21499143/how-to-get-syntax-highlighting-for-alternate-file-extension-for-visual-studio-20" target="_blank" rel="noopener">How to get syntax highlighting for alternate file extension for Visual Studio 2010 or 2013?
</a></li>
</ul>
<h2 id="UnrealEngine部分"><a href="#UnrealEngine部分" class="headerlink" title="UnrealEngine部分"></a>UnrealEngine部分</h2><h3 id="UE4中使用的一些Tip"><a href="#UE4中使用的一些Tip" class="headerlink" title="UE4中使用的一些Tip"></a>UE4中使用的一些Tip</h3><h4 id="1-快速制作封闭空间"><a href="#1-快速制作封闭空间" class="headerlink" title="1. 快速制作封闭空间"></a>1. 快速制作封闭空间</h4><p>快速挖空一个几何体的制作顺序：</p>
<ul>
<li>Modes panel -&gt; Geometry -&gt; Box -&gt; 设置尺寸</li>
<li>Details panel -&gt; Brush settings -&gt; Hollow 属性check</li>
</ul>
<h4 id="2-调整模型的模型坐标的原点"><a href="#2-调整模型的模型坐标的原点" class="headerlink" title="2.调整模型的模型坐标的原点"></a>2.调整模型的模型坐标的原点</h4><p>根据模型的大小来调整模型坐标的原点，顺序：</p>
<ul>
<li>双击UE4中导入的模型，打开材质编辑器(static mesh editor也叫Material Editor)</li>
<li>点击<code>Show Pivot</code>显示模型坐标，同时在左上角看见，模型的大小</li>
<li>在<code>Detail panel</code>中找到Transform，调整<code>Import Tansiation</code>的数值，移动坐标系</li>
<li>Tool bar -&gt; Asset -&gt; Reimport Model 之后就会发现模型坐标按照指示移动了</li>
</ul>
<h4 id="3-制作天空球-与雾"><a href="#3-制作天空球-与雾" class="headerlink" title="3.制作天空球(与雾)"></a>3.制作天空球(与雾)</h4><p>感觉要制作出天空的感觉同时还有雾的模糊的时候使用，可以看见太阳就是不知道能否模拟太阳的移动</p>
<p>顺序:</p>
<ol>
<li>选定平行光源，开启Light -&gt; Atmosphere/Sun light</li>
<li>将Visual Effects -&gt; Atmospheric Fog 拖拽至场景中</li>
<li>Content Browser panel右下的View Options中开启Show Engine Content</li>
<li>在Engine Content中找到BP_Sky_Sphere并将其拖拽至场景中</li>
<li>在BP_Sky_Sphere的Details面板中的Directional Light Actor选定上面的平行光</li>
</ol>
<h4 id="4-UE4中的Volume应用"><a href="#4-UE4中的Volume应用" class="headerlink" title="4.UE4中的Volume应用"></a>4.UE4中的Volume应用</h4><p>在UE中使用Volume执行不同的任务可以解决很多问题，比如说：</p>
<ul>
<li>给玩施加伤害</li>
<li>改变物理定律，在Volume中允许玩家悬浮等等</li>
<li>作为碰撞表面，不允许玩家进入</li>
<li>改变计算关卡光照和可见性方式</li>
</ul>
<p>等等，出了直接使用Modes panel中的Volume工具之外，也可以直接将几何体笔刷(brush)转化为相应的Volume。Details -&gt; Actor -&gt; Convert Actor -&gt; Volume(that you want)</p>
<p>参考资料：</p>
<ul>
<li><a href="http://api.unrealengine.com/INT/Engine/Actors/Volumes/" target="_blank" rel="noopener">Volume Reference</a></li>
</ul>
<h4 id="5-Z-Fighting"><a href="#5-Z-Fighting" class="headerlink" title="5.Z-Fighting"></a>5.Z-Fighting</h4><p>Z-Fighting又Depth Fighting，深冲突。就是贴图会出现闪烁的情况，与实际模型产生交叉融合</p>
<p>z-fighting的出现是的不同面上的像素在z-buffer中的值相近，导致前台取像素的时候一会去这个面的，一会取那个面的。改变照相机的near、far属性会涉及到z-buffer中的值的精度。因为在各个平台上z-buffer位数不同，因此改变near和far能给z-buffer中的值的浮点数部分尽量留出空间，消除z-fighting。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.arvrschool.com/read.php?tid=682" target="_blank" rel="noopener">z-fighting在unity中的解决方式</a></li>
</ul>
<h4 id="6-将选定的Actor合并为组"><a href="#6-将选定的Actor合并为组" class="headerlink" title="6.将选定的Actor合并为组"></a>6.将选定的Actor合并为组</h4><p>使用<code>Ctrl+G</code>的快捷键可以快速把选定的Actor(场景的素材)合并为一组，下次选定的时候会选定为一组。便于移动或者复制。</p>
<p>使用<code>Shift+G</code>的快捷键会解除分组。当然这些操作都可以在选中Actor之后:</p>
<ul>
<li>Right Click -&gt; Group进行分组和分解</li>
</ul>
<h4 id="7-UE4中的Material和Material-Function"><a href="#7-UE4中的Material和Material-Function" class="headerlink" title="7.UE4中的Material和Material Function"></a>7.UE4中的Material和Material Function</h4><p>在UE4中偶然看到了这两个材质的声明，发现名字不太一样，需要调查一下。</p>
<h3 id="UE-C-中的需要注意的问题"><a href="#UE-C-中的需要注意的问题" class="headerlink" title="UE C++中的需要注意的问题"></a>UE C++中的需要注意的问题</h3><h4 id="1-ConstructorHelpers类的使用"><a href="#1-ConstructorHelpers类的使用" class="headerlink" title="1.ConstructorHelpers类的使用"></a>1.ConstructorHelpers类的使用</h4><p>就我的理解这个类可以在其他类的构造函数中实例化对象。自己的情况中多为获取在工程中的资源，并不是level中的Actor资源而是单纯的Content文件夹中的某个资源。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line"><span class="comment">// SampleActorComponent.cpp中的构造函数</span></span><br><span class="line">USampleActorComponent::USampleActorComponent()</span><br><span class="line">&#123;</span><br><span class="line">    PrimaryComponnetTick.bCanEverTick = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt; SampleAsset(TEXT(<span class="string">"StaticMesh'/Game/StartrContent/Shapes/Shape_Plane.Shape_Plane'"</span>));</span><br><span class="line">    sample_mesh = SampleAsset.Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就能成功取到Content中的资源，当然不限于<code>StaticMesh</code>其他的类型<code>UMaterial</code>等等的类型都可以取到。需要注意的是</p>
<ul>
<li>ConstructorHelpers类的使用必须是要在类的构造函数中进行（吃了不少苦头）</li>
<li>SampleAsset的资源链接可以直接在UE4的Content文件夹右键资源<code>copy reference</code>中直接取到</li>
</ul>
<p>关于更多的使用应该在另一篇博文中有拓展。</p>
<h4 id="2-在C-类中为类添加用户输入响应"><a href="#2-在C-类中为类添加用户输入响应" class="headerlink" title="2.在C++类中为类添加用户输入响应"></a>2.在C++类中为类添加用户输入响应</h4><p>在网上搜了一下如何给一个脚本添加键盘输入事件，也不是那么全，有价值的一个提问是这个</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/166084/check-keyboard-events-in-code.html" target="_blank" rel="noopener">Check Keyboard Event in code</a></li>
</ul>
<p>但是试了一下并不好用，就自己的理解来说，基本上想要键盘的输入的事件响应的基本上都应该去继承UE4的<code>PawnActor</code>类去了，而我自己就是想用键盘来调试而已。继承的类是<code>ActorComponent</code>，并不能实现他们的代码。后来找了一找还是有实现方法的。</p>
<p>首先要去UE4的Editor中的Project Settings中的input选项中将自己想要绑定的键位命名并登录。我起的名字就是<code>PressedF</code>等等。</p>
<p>然后就是在c++中实现绑定了：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SampleActorComponent.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> USampleActorComponent::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为要绑定一下键位的事件，所以需要在这里写</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;GetOwner()-&gt;EnableInput(<span class="keyword">this</span>-&gt;GetWorld()-&gt;GetFirstPlayerController());</span><br><span class="line">    UInputComponent * myInputComp = <span class="keyword">this</span>-&gt;GetOwner()-&gt;InputComponent;</span><br><span class="line">    <span class="keyword">if</span>(myInputComp)    <span class="comment">// check(myInputComp)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SetupMyPlayerInput(myInputComponent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> USampeActorComponent::SetupMyPlayerInput(UInputComponent * myInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">    myInputComponent-&gt;BindAction(<span class="string">"PressedF"</span>, IE_Pressed, <span class="keyword">this</span>, &amp;USampleActorComponent::PressedMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> USampleActorComponent::PressedMethod()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里是按下键盘键位之后的动作内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SampleActorCompoennt.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USampleActorComponent</span> :</span> <span class="keyword">public</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UFUNCTINN(BlueprintCallable, Category = <span class="string">"MyUE4Class"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PressedMethod</span><span class="params">()</span></span>;  <span class="comment">// 这个在头文件的声明一定要使用UFUNCTION宏来修饰否则没有作用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetupMyPlayerInput</span><span class="params">(UInputComponent * myInputComponent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整的使用方法大概就是这样，应该有一篇文章介绍的很详细的但是关掉了页面不太好找了。</p>
<h4 id="3-像Unity一样保存场景中的参照"><a href="#3-像Unity一样保存场景中的参照" class="headerlink" title="3.像Unity一样保存场景中的参照"></a>3.像Unity一样保存场景中的参照</h4><p>在Unity中把scene中的参照直接拖进脚本的声明公共变量以达到快速参照的目的，在UE4中也有类似的用法。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USampleClass</span> :</span> <span class="keyword">public</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    USampleClass();</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, Category = <span class="string">"Edit"</span>)</span><br><span class="line">    AActor * targrtActor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为属性添加UPROPERTY()宏让变量暴露给编辑器，然后在该脚本的Detail面板上wei该变量找到场景中的Actor参照。虽然不能拖拽了。</p>
<hr>
<p><span style="color: blue">Tips更新(2020/06/03)</span></p>
<p>上面是C++中编程的场景，在UE的蓝图中保存参照的时候非常简单，直接将Actor从场景中拖到蓝图里就自动出现对象的引用了。但是在使用的过程中还是会有一些不便，比如说还要调整窗口的大小进行拖拽。</p>
<p>我在浏览官网的时候偶然发现的一个功能，<strong>就是在进入蓝图之前先选中Actor，复数的Actor也是可以的（当然这里应该不仅限于Actor），然后打开蓝图之后就会出现Call Function On Selected Actors这样的选项</strong>。嗯，这应该会有些用处。</p>
<hr>
<h4 id="4-获取Actor上的Component"><a href="#4-获取Actor上的Component" class="headerlink" title="4.获取Actor上的Component"></a>4.获取Actor上的Component</h4><p>不知道是不是UE4中获取Actor上的组件就这么麻烦还是我没找到，组件的获取并不是那么单纯的事情。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取名为targetActor身上的脚本组件（</span></span><br><span class="line"></span><br><span class="line">TArray&lt;USampleActorComponent*&gt; Comps;</span><br><span class="line">targetActor_p-&gt;GetComponents&lt;USampleActorComponent&gt;(Comps);</span><br><span class="line"><span class="comment">// 这样Comps[0]的内容应该就是想要的组件的参照了</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-在UEC-中实现代理"><a href="#5-在UEC-中实现代理" class="headerlink" title="5.在UEC++中实现代理"></a>5.在UEC++中实现代理</h4><p>我在现实中都没怎么用到过得代理，我竟然一次用了这么多。在UE4中代理的制作感觉好简单好方便。之前有一个是在C++中声明代理，但是实现是在蓝图中的，叫Multi-Cast-Delegate好像。这次完全是在C++中声明在C++中实现代理。</p>
<p>再来复述一下代理的情况：一个类想要做一件事儿，但是这件事跟这个类的关系是只想知道这件事做了而已，具体做的内容完全不关心，这件事情的实现是另一个类的分工。这个时候只要在自己的类里面声明一个代理，当想要执行的时候通知那个类就行。就像是事件一样。</p>
<h5 id="1-定义代理类型"><a href="#1-定义代理类型" class="headerlink" title="1.定义代理类型"></a>1.定义代理类型</h5><p>在UE4中引擎为我们做了大部分，而我们只要用就可以了。首先定义代理的类型。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SampleDelegateComponent.h"</span>  <span class="comment">// 我们需要委托的类头文件声明</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SampleActoomponent.generated.h"</span>   <span class="comment">// 这个头文件是自动生成的，没有的话要手动补上去就是自己的文件名加上.generated.h，而且这个声明必须要在所有的声明的最后。原因不清楚</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_DELEGATE(SampleDelegate)</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USampleActorComponnet</span> :</span> UActorComponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class Contents</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们便声明了一个类型为SampleDelegate的代理了。</p>
<h5 id="2-声明代理"><a href="#2-声明代理" class="headerlink" title="2.声明代理"></a>2.声明代理</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在USampleActorComponent中的声明这个该类型的代理变量</span></span><br><span class="line">SampleDelegate sample_delegate;</span><br></pre></td></tr></table></figure>
<h5 id="3-绑定代理"><a href="#3-绑定代理" class="headerlink" title="3.绑定代理"></a>3.绑定代理</h5><p>用上一条的方法获取到level中的Actor的参照，然后将代理绑定到这个想要代为我们执行的实例上去。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取得需要绑定的实例参照</span></span><br><span class="line"><span class="keyword">if</span>(targetActor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取到实例身上的脚本组件</span></span><br><span class="line">    TArray&lt;USampleDelegateComponent*&gt; Comps;</span><br><span class="line">    targetActor-&gt;GetComponents&lt;USampleDelegateComponent&gt;(Comps);</span><br><span class="line">    <span class="comment">// 绑定代理</span></span><br><span class="line">    sample_delegate.BindUObject(Comp[<span class="number">0</span>], &amp;USampleDelegateComponent::MethodWanted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4-代理执行"><a href="#4-代理执行" class="headerlink" title="4.代理执行"></a>4.代理执行</h5><p>剩下的就是在想要的时候执行代理就好了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sample_delegate.Execute();</span><br></pre></td></tr></table></figure></p>
<h4 id="6-动态加载资源"><a href="#6-动态加载资源" class="headerlink" title="6.动态加载资源"></a>6.动态加载资源</h4><p>关于动态加载资源又是能说一箩筐的话题，这次只记录自己用到的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UTexture2D * sampleTex = LoadObject&lt;UTexture2D&gt;(<span class="literal">NULL</span>, TEXT(<span class="string">"Texture2D'/Game/Path..'"</span>), <span class="literal">NULL</span>, LOAD_None, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p>
<p>参数啥的也不太清楚，用的时候按照这个方向查吧。之后的关于如何从零开始制作烟雾特效的教程里应该会出现。</p>
<h4 id="7-动态改变物体材质参数"><a href="#7-动态改变物体材质参数" class="headerlink" title="7.动态改变物体材质参数"></a>7.动态改变物体材质参数</h4><p>关于UE4的材质，有好多的话要说，关于如何动态的改变一个物体材质的问题要是不是自己非要用C++写蓝图，估计也不会钻研的那么深。</p>
<p>首先是要动态的改变一个材质里面的参数需要我们创建一个动态的材质。也就是说我们需要得到场景中的物体的材质的实例参照，然后以这个参照为模板创建一个动态材质，再把这个修改了的动态材质赋给物体。</p>
<p>老规矩，上代码：</p>
<p><strong>.h文件</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class内，省略大部分框架代码</span></span><br><span class="line"><span class="comment">// 头文件中声明材质</span></span><br><span class="line">UMaterial * target_material;</span><br><span class="line">UMaterialInstanceDynamic * target_material_dynamic;</span><br></pre></td></tr></table></figure></p>
<p><strong>.cpp文件</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数中使用ConstructorHelpers获取到物体的材质</span></span><br><span class="line"><span class="keyword">static</span> ConstructorHelpers::FObjectFinder&lt;UMaterial&gt; targetMT(TEXT(<span class="string">"PATH"</span>));</span><br><span class="line">target_material = targetMT.Object;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随后可以在BeginPlay函数中对动态材质进行初始化</span></span><br><span class="line">target_material_dynamic = UMaterialInstanceDynamic::Create(target_material, <span class="keyword">this</span>-&gt;GetWorld());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以为材质中的变量赋值</span></span><br><span class="line">target_material_dynamic-&gt;SetScalarParameterValue(<span class="string">"MaterialParaName"</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展复习~</span></span><br><span class="line"><span class="comment">// 获取一个UStaticMesh上的组件的材质</span></span><br><span class="line">TArray&lt;UStaticMeshComponent*&gt;comps;</span><br><span class="line"><span class="keyword">this</span>-&gt;GetOwner()-&gt;GetComponnets&lt;UStaticMeshComponent&gt;(comps);</span><br><span class="line">target_material = (UMaterial*)comps[<span class="number">0</span>]-&gt;GetMaterial(<span class="number">0</span>)    <span class="comment">// 指针类型强制转换这一步很重要</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新材质结束之后要赋给物体</span></span><br><span class="line">mesh_comp = comps[<span class="number">0</span>]</span><br><span class="line">mesh_comp-&gt;SetMaterial(<span class="number">0</span>, target_material_dynamic);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的是比较重要的一步</span></span><br><span class="line"><span class="comment">// 在BeginPlay中实例化动态材质之后需要</span></span><br><span class="line">target_material_dynamic-&gt;AddToRoot();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完后再EndPlay中将动态材质移除</span></span><br><span class="line">target_material_dynamic-&gt;RemoveFromRoot();</span><br></pre></td></tr></table></figure></p>
<p>这个也是吃了苦头的，因为自己非要用C++写，不用蓝图，这东西谁都不会告诉我啊。AddToRoot这个操作让UE的GC不会把我们创建的动态材质给回收掉。而使用的AddToRoot的东西在结束或者不想用的时候RemoveFromRoot，以便回收。哎呀没加的时候UE4崩的不要不要的。</p>
<h4 id="8-UE-LOG输出奇奇怪怪的数据类型"><a href="#8-UE-LOG输出奇奇怪怪的数据类型" class="headerlink" title="8.UE_LOG输出奇奇怪怪的数据类型"></a>8.UE_LOG输出奇奇怪怪的数据类型</h4><p>总是想输出些什么。使用UE_LOG可以在UE4的Editor输出运行的信息。但是C++嘛，你让它输出<code>FString</code>类型的东西，他不认识就不输出这个时候就像下面这样：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"output message %s"</span>), *(FDateTime::Now().ToString()));</span><br></pre></td></tr></table></figure></p>
<p>使用指针强制转换，我也不知道是个什么原理。</p>
<h4 id="9-FTimerManager定时器"><a href="#9-FTimerManager定时器" class="headerlink" title="9.FTimerManager定时器"></a>9.FTimerManager定时器</h4><p>定时器是个好东西。但是要怎么用呢？</p>
<p>首先要获取到这个定时器，在世界中有这么一个定时器：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为什么要加 &amp; ，引用的作用应该就是我不知道，不加就报错。我也不知道我是怎么灵机一动加上就好用的。</span></span><br><span class="line">FTimeManager &amp;timer = <span class="keyword">this</span>-&gt;GetOwner()-&gt;GetWorldTimerManager();</span><br></pre></td></tr></table></figure></p>
<p>然后声明一个Handle<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在.h文件中声明一个Timer Handle供我们使用，一个Handle就是一个定时的名字应该</span></span><br><span class="line">FTimerHandle timer_handle;</span><br></pre></td></tr></table></figure></p>
<p>最后开始定时：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">timer.SetTimer(timer_handle, <span class="keyword">this</span>, &amp;USampleActorComponent::TimerMethodWnted, <span class="number">1.0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>参数的意思应该一目了然了。</p>
<h3 id="UE4项目右键找不到GenerateProjectFile选项的问题"><a href="#UE4项目右键找不到GenerateProjectFile选项的问题" class="headerlink" title="UE4项目右键找不到GenerateProjectFile选项的问题"></a>UE4项目右键找不到GenerateProjectFile选项的问题</h3><p>换新电脑或者重做系统之后会遇到的麻烦事儿，就是想要重新生成UE4的<strong>sln</strong>工程文件，右键却找不到重新生成选项的问题。解决方案是：</p>
<p><strong>找到使用的引擎文件中的UnrealVersionSelector.exe文件，并双击。</strong></p>
<p>一般这个文件都是在UE4的<em>Binary</em>文件夹下面。</p>
<p>参考资料：<br><a href="https://forums.unrealengine.com/development-discussion/content-creation/81964-association-uproject-unreal-are-broken?109862-Association-uproject-unreal-are-broken=" target="_blank" rel="noopener">Association .uproject / unreal are broken</a></p>
<h2 id="UE4知识拓展"><a href="#UE4知识拓展" class="headerlink" title="UE4知识拓展"></a>UE4知识拓展</h2><p>主要用来记录一些常见但是需要理解的优先级不高或者不太常用的知识点的拓展。</p>
<h3 id="Class-Specifiers"><a href="#Class-Specifiers" class="headerlink" title="Class Specifiers"></a>Class Specifiers</h3><p>关于UClass的修饰符</p>
<p>Class Specifiers</p>
<p>我迟早要整理这些修饰符的内容。</p>
<h3 id="Metadata-Specifiers"><a href="#Metadata-Specifiers" class="headerlink" title="Metadata Specifiers"></a>Metadata Specifiers</h3><p>在UE4中的宏<code>UFUNCTION()</code>等等中会看到一些<code>meta</code>修饰符，有各自的用处。</p>
<p><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata" target="_blank" rel="noopener">Metadata Specifiers</a></p>
<h4 id="CallableWithoutWorldContext"><a href="#CallableWithoutWorldContext" class="headerlink" title="CallableWithoutWorldContext"></a>CallableWithoutWorldContext</h4><p>想要记录下这个meta的原因是，我想得到当前调用函数所在的Blueprint的名字。在C++中直接使用<code>__Function__</code>写个宏就可以直接得到调用函数的名字，但是在Blueprint中，没有宏当参数这么便利的方法，得顺便把self当参数传进去。</p>
<p>这就导致我想输出蓝图名字的时候，无论如何都得额外做一个把self传进去的操作。</p>
<p>但是有一天我发现，为什么UE4自带的<code>Print</code>函数就没有传这样的参，而且还把调用蓝图的名字输出来了。看代码就知道了。</p>
<p>在下面的源代码中可以找到UE4自带的Print函数声明定义：</p>
<ul>
<li><code>Engine\Source\Runtime\Engine\Classes\Kismet\KismetSystemLibrary.h</code></li>
<li><code>Engine\Source\Runtime\Engine\Private\KismetSystemLibrary.cpp</code></li>
</ul>
<p>会找到下面的声明：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable, meta=(WorldContext=<span class="string">"WorldContextObject"</span>, CallableWithoutWorldContext, Keywords = <span class="string">"log print"</span>, AdvancedDisplay = <span class="string">"2"</span>, DevelopmentOnly), Category=<span class="string">"Utilities|String"</span>)</span><br><span class="line">static void PrintString(UObject* WorldContextObject, const FString&amp; InString = FString(TEXT("Hello")), bool bPrintToScreen = true, bool bPrintToLog = true, FLinearColor TextColor = FLinearColor(0.0, 0.66, 1.0), float Duration = 2.f);</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> UKismetSystemLibrary::PrintString(UObject* WorldContextObject, <span class="keyword">const</span> FString&amp; InString, <span class="keyword">bool</span> bPrintToScreen, <span class="keyword">bool</span> bPrintToLog, FLinearColor TextColor, <span class="keyword">float</span> Duration)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !(UE_BUILD_SHIPPING || UE_BUILD_TEST) <span class="comment">// Do not Print in Shipping or Test</span></span></span><br><span class="line"></span><br><span class="line">    UWorld* World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull);</span><br><span class="line">    FString Prefix;</span><br><span class="line">    <span class="keyword">if</span> (World)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (World-&gt;WorldType == EWorldType::PIE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(World-&gt;GetNetMode())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> NM_Client:</span><br><span class="line">                    Prefix = FString::Printf(TEXT(<span class="string">"Client %d: "</span>), GPlayInEditorID - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NM_DedicatedServer:</span><br><span class="line">                <span class="keyword">case</span> NM_ListenServer:</span><br><span class="line">                    Prefix = FString::Printf(TEXT(<span class="string">"Server: "</span>));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> NM_Standalone:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> FString FinalDisplayString = Prefix + InString;</span><br><span class="line">    FString FinalLogString = FinalDisplayString;</span><br><span class="line"></span><br><span class="line">    static const FBoolConfigValueHelper DisplayPrintStringSource(TEXT("Kismet"), TEXT("bLogPrintStringSource"), GEngineIni);</span><br><span class="line">    <span class="keyword">if</span> (DisplayPrintStringSource)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> FString SourceObjectPrefix = FString::Printf(TEXT(<span class="string">"[%s] "</span>), *GetNameSafe(WorldContextObject));</span><br><span class="line">        FinalLogString = SourceObjectPrefix + FinalLogString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bPrintToLog)</span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(LogBlueprintUserMessages, Log, TEXT(<span class="string">"%s"</span>), *FinalLogString);</span><br><span class="line">        </span><br><span class="line">        APlayerController* PC = (WorldContextObject ? UGameplayStatics::GetPlayerController(WorldContextObject, <span class="number">0</span>) : <span class="literal">NULL</span>);</span><br><span class="line">        ULocalPlayer* LocalPlayer = (PC ? Cast&lt;ULocalPlayer&gt;(PC-&gt;Player) : <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (LocalPlayer &amp;&amp; LocalPlayer-&gt;ViewportClient &amp;&amp; LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole)</span><br><span class="line">        &#123;</span><br><span class="line">            LocalPlayer-&gt;ViewportClient-&gt;ViewportConsole-&gt;OutputText(FinalDisplayString);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        UE_LOG(LogBlueprintUserMessages, Verbose, TEXT(<span class="string">"%s"</span>), *FinalLogString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Also output to the screen, if possible</span></span><br><span class="line">    <span class="keyword">if</span> (bPrintToScreen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GAreScreenMessagesEnabled)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GConfig &amp;&amp; Duration &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                GConfig-&gt;GetFloat( TEXT(<span class="string">"Kismet"</span>), TEXT(<span class="string">"PrintStringDuration"</span>), Duration, GEngineIni );</span><br><span class="line">            &#125;</span><br><span class="line">            GEngine-&gt;AddOnScreenDebugMessage((uint64)<span class="number">-1</span>, Duration, TextColor.ToFColor(<span class="literal">true</span>), FinalDisplayString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            UE_LOG(LogBlueprint, VeryVerbose, TEXT(<span class="string">"Screen messages disabled (!GAreScreenMessagesEnabled).  Cannot print to screen."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点是下面</p>
<p><strong>WorldContext=”WorldContextObject”, CallableWithoutWorldContext</strong> 这部分。</p>
<p>受这个启发，这个让我们可以不用传入额外的参数（self），并且使用<code>GetNameSafe</code>函数得到名字。</p>
<p>顺便一提，Keywords关键字可以设置搜索的关键字。细节上面的官方文档中有。</p>
<h3 id="Property-Specifier"><a href="#Property-Specifier" class="headerlink" title="Property Specifier"></a>Property Specifier</h3><p>这一部分用来记录<code>UPROPERTY()</code>，修饰属性的各种修饰符。</p>
<h4 id="Transient"><a href="#Transient" class="headerlink" title="Transient"></a>Transient</h4><p>根据官网的描述：</p>
<blockquote>
<p>Property is transient, meaing it will not be saved or loaded. Properties tagged this way will be zero-filled at loat time.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY(Transient)</span><br><span class="line">int32 ValueX;</span><br></pre></td></tr></table></figure>
<p>说实话，在没有对UE4的多人模式进行学习的时候真是一头雾水。被标记了这个属性修饰符的变量，意味着变量存储的是一个暂时的值，我们并不想永久的保存它，比如说这个变量保存的是其它类中的内容，就好像是弱指针一样，只是暂时的保留这个变量的值。</p>
<p>还有一个作用就是，标记了这个修饰符的变量，它不会被Serialize(见UE4的Net Serialize)。</p>
<h3 id="Wildcard-类型"><a href="#Wildcard-类型" class="headerlink" title="Wildcard 类型"></a>Wildcard 类型</h3><p><code>Wildcard</code>这个数据类型是UE4的Editor的可以适配所有类型的Pin的类型。</p>
<p>可以用来作为一些宏的Event的类型指定，就像为函数提供一个delegate一样，UE4的蓝图的宏也可以使用类似的特性。</p>
<ul>
<li><a href="http://papersloth.hatenablog.com/entry/2019/10/23/024329" target="_blank" rel="noopener">UE4 Blueprintでdelegateを引数で使用する方法</a></li>
</ul>
<p>这篇文章的知识点随着时间的推移开始变得有些杂乱了，该考虑一下重新整理文章内容了。</p>
<h3 id="从UE4的源码中对工程进行设置"><a href="#从UE4的源码中对工程进行设置" class="headerlink" title="从UE4的源码中对工程进行设置"></a>从UE4的源码中对工程进行设置</h3><p><span style="color:blue">2020/06/03更新</span></p>
<p>参照官网上的步骤下载并配置源码版UnrealEngine，这其中有一个我漏掉的步骤，就是把UE4设置为启动工程</p>
<p>即在工程项目的SolutionExplorer中找到项目右键，会出现<strong>Set as StartUp Project</strong>,对，要执行这一步操作，然后在Build界面中选择<strong>Build UE4</strong>，因为这里不选直接使用默认的编译的话，会把全体都编译，有时间可以这么搞，没时间还是别这么搞，真的费时间。</p>
<p>这样按理说就可以使用编译好的引擎打开想要工作的项目了。</p>
<h3 id="DefaultBuildSettings"><a href="#DefaultBuildSettings" class="headerlink" title="DefaultBuildSettings"></a>DefaultBuildSettings</h3><p>UE4自4.24版本之后更改了默认的编译设定，<code>BuildSettingsVersion.V2</code></p>
<p>Here’s an example V1(legacy) target.cs file:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 1998-2019 Epic Games, Inc. All Right Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AGobesTestEditorTarget</span> : <span class="title">TargetRules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AGnoesTsetEditorTarget</span>(<span class="params"> TargetInfo Target </span>) : <span class="title">base</span>(<span class="params">Target</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Type = TargetType.Editor;</span><br><span class="line">        DefaultBuildSettings = BuildSettingsVersion.V1;</span><br><span class="line">        ExtraModuleNames.AddRange( <span class="keyword">new</span> String[] &#123; <span class="string">"AgonesTest"</span> &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Here’s an example V2 (new) target.cs:<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 1998-2019 Epic Games, Inc. All Right Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnrealBuildTool;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AGobesTestEditorTarget</span> : <span class="title">TargetRules</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AGnoesTsetEditorTarget</span>(<span class="params"> TargetInfo Target </span>) : <span class="title">base</span>(<span class="params">Target</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Type = TargetType.Editor;</span><br><span class="line">        DefaultBuildSettings = BuildSettingsVersion.V2;</span><br><span class="line">        ExtraModuleNames.AddRange( <span class="keyword">new</span> String[] &#123; <span class="string">"AgonesTest"</span> &#125; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有就是需要注意的是，当由之前的V1版本切换到V2版本之后会出现include文件路径不对的问题，换了一种编译方式，编译路径也不一样了。<br>然后就是自己的发现就是V2编译的路径变成了<strong>相对路径</strong>。</p>
<h1 id="道听途说"><a href="#道听途说" class="headerlink" title="道听途说"></a>道听途说</h1><h4 id="1-关于C-中的资源释放"><a href="#1-关于C-中的资源释放" class="headerlink" title="1.关于C++中的资源释放"></a>1.关于C++中的资源释放</h4><p>一般在c++中应该是资源的获取与申请（<code>new</code>等等的操作）与资源的释放都是需要程序员手动操作的。但是如果使用了UE管理的资源，比如继承了UE中的类库等等的操作，那么释放这些资源的操作，在UE中会自动释放而不需要程序员的额外操作，反而要是操作了还会出问题。</p>
<p>当然这个问题只是道听途说，未能够验证。</p>
<p>当然需要仔细调查了啊</p>
<h4 id="2-关于UE中UObject的派生对象的垃圾回收问题"><a href="#2-关于UE中UObject的派生对象的垃圾回收问题" class="headerlink" title="2.关于UE中UObject的派生对象的垃圾回收问题"></a>2.关于UE中UObject的派生对象的垃圾回收问题</h4><p>如果一个UObject的派生类对象中有一个UObject的派生类对象的指针变量，当这个指针变量经过<code>NewObject&lt;&gt;()</code>的操作实例化了之后，这个实例化对象就成为了<strong>GC对象</strong>（garbage collection）,但是仅仅如此还不足以达到自动回收的目的，像下面这样在声明之前加上<code>UPROPERTY()</code>宏，就不需要显式的<code>delete</code>垃圾回收了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">UPROPERTY()</span><br><span class="line">UObject* MyObjectReference;</span><br></pre></td></tr></table></figure></p>
<p>总结来说，在C++中使用了<code>new</code>等等的方式来申请了一部分空间的话在使用结束的时候需要显式的释放掉，否则的话就会造成内存泄漏。然而上述的使用方式会使得这样声明的实例对象能够得到的资源自动回收。</p>
<p>参考来源:</p>
<ul>
<li><a href="https://answers.unrealengine.com/questions/4485/question-uobject-pointer-references.html" target="_blank" rel="noopener">[Question]UObject Pointer References</a></li>
</ul>
<h1 id="关于C-好像发现了一个不得了的链接"><a href="#关于C-好像发现了一个不得了的链接" class="headerlink" title="关于C++好像发现了一个不得了的链接"></a>关于C++好像发现了一个不得了的链接</h1><p>貌似可以在这个链接中找到C++的标准文档，英文文档。</p>
<ul>
<li><a href="http://www.open-std.org/" target="_blank" rel="noopener">Open Standards</a></li>
</ul>
<h1 id="一些感觉蛮重要的文章"><a href="#一些感觉蛮重要的文章" class="headerlink" title="一些感觉蛮重要的文章"></a>一些感觉蛮重要的文章</h1><p>这里放置一些我想看但是暂时没有时间看的文章。</p>
<ul>
<li><a href="http://techblog.sega.jp/entry/2018/11/26/100000" target="_blank" rel="noopener">20年オヤジのUnreal Engine 4 TIPS</a></li>
</ul>
<p>感觉是比较新的知识点，总是有看到过的影子，关于<strong>MeshDistanceFields</strong>:</p>
<ul>
<li><a href="https://docs.unrealengine.com/ja/Engine/Rendering/LightingAndShadows/MeshDistanceFields/index.html" target="_blank" rel="noopener">メッシュディスタンス フィールド</a></li>
</ul>
]]></content>
      <categories>
        <category>UnrealEngine4</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
        <tag>UE4</tag>
      </tags>
  </entry>
  <entry>
    <title>C#中的单例模式-SingletonPattern</title>
    <url>/C#%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-SingletonPattern/</url>
    <content><![CDATA[<p>这次来整理一下C的单例模式，参考的文章是<a href="http://csharpindepth.com/Articles/General/Singleton.ASPx" target="_blank" rel="noopener">Implementing the Singleton Pattern in C#</a>。</p>
<p>曾经在做一个数据库管理类中经常多次使用了一个数据库管理的实例类对象，每次在新的不相关的类中需要使用数据库操作的时候都重新实例化一个数据库管理类对象，久而久之就觉得有些麻烦。便决定使用单例模式来管理，同时深究一下单例模式与C#中的使用。</p>
<a id="more"></a>
<p>算是这篇文章的汉化与总结吧。</p>
<p>–未完–</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Semaphore-信号量</title>
    <url>/Semaphore-%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<p>Semaphore,中文叫信号量，日语叫セマフォ（= .=）。经常会在多线程的编程中用到。信号量说简单点就是为了线程同步，或者说是为了限制线程能运行的数量。</p>
<p>仔细说明一下就是，信号量会在内部维护一个计数器，当一个线程调用了这个信号量，计数器就会减1，直到计数器减为0，调用这个信号量的线程将会被阻塞，直到有别的线程释放掉一个信号量使其计数器加1。</p>
<a id="more"></a>
<p>那么问题就来了，这个信号量维护的这个计数器应该是对线程的死锁有所防护的，也就是说同一时间只有一个线程能过获取这个信号量，而且当线程获取信号量的时候对信号量中的计数器进行减操作是具有<strong>原子性</strong>的操作。对于这个计数器的保存位置应该深入调查一下。</p>
<p>实例代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace Semaphore1</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        //我设置一个最大允许5个线程允许的信号量</span><br><span class="line">        //并将它的计数器的初始值设为0</span><br><span class="line">        //这就是说除了调用该信号量的线程都将被阻塞</span><br><span class="line">        static Semaphore semaphore = new Semaphore(0, 5);</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int i = 1; i &lt;= 5; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread thread = new Thread(new ParameterizedThreadStart(work));</span><br><span class="line"></span><br><span class="line">                thread.Start(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.Sleep(1000);</span><br><span class="line">            Console.WriteLine(&quot;Main thread over!&quot;);</span><br><span class="line"></span><br><span class="line">            //释放信号量，将初始值设回5，你可以将</span><br><span class="line">            //将这个函数看成你给它传的是多少值，计数器</span><br><span class="line">            //就会加多少回去，Release()相当于是Release(1)</span><br><span class="line">            semaphore.Release(5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static void work(object obj)</span><br><span class="line">        &#123;</span><br><span class="line">            semaphore.WaitOne();</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot;Thread &#123;0&#125; start!&quot;,obj);</span><br><span class="line"></span><br><span class="line">            semaphore.Release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS真机安装Build出错</title>
    <url>/iOS%E7%9C%9F%E6%9C%BA%E5%AE%89%E8%A3%85Build%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>为了面试，需要用尽一切手段了，把自己的毕业设计的时候做的2D游戏也拿出来了（捂脸）。找到了自己之前保存好的已经编译好的安装包，希望能够平安无事的安装到自己的系统高版本的iPhone7上。但是再次编译的时候果不其然还是要报错。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">'__declspec' attributes are not enabled; use '-fdeclspec' or '-fms-extensions' to enable support <span class="keyword">for</span> __declspec attributes</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>但是无论是Xcode还是Unity都已经升级的面目全非了，打开以前保存的Unity工程果不其然各种报错。想要解决出现的问题，第一个是NGUI的版本问题，代码中出现的一部分说是已经不支持Unity5.4+了…上网搜了一下，结果没有找到任何解答。</p>
<p>第一下就碰壁，只能再回去找已经编译好的文件的Build错误了。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>继续搜关键词，看到了Unity社区中有一个这个提问：<a href="https://forum.unity.com/threads/error-unknown-type-name-__declspec-after-xcode-7-3-upgrade.393128/" target="_blank" rel="noopener">Error “unknown type name __declspec” after Xcode 7.3 upgrade</a></p>
<p>出问题的代码部分跟我的是一样的:<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NORETURN</span> <span class="keyword">static</span> void il2cpp_codegen_raise_exception (<span class="type">Il2CppCodeGenException</span> *ex)</span><br><span class="line">&#123;</span><br><span class="line">    il2cpp::vm::<span class="type">Exception</span>::<span class="type">Raise</span> ((<span class="type">Il2CppException</span>*)ex);</span><br><span class="line">#<span class="keyword">if</span> __has_builtin(__builtin_unreachable)</span><br><span class="line">    __builtin_unreachable();</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然我是根本不知道这几行代码到底是干什么的。但是就是出错了…继续往下看，好像看到了一个解决方案:</p>
<blockquote>
<p>It has helped me:</p>
<p>1) Remove ‘NORETURN’<br>2) Clean build<br>3) Build it</p>
<p>Like a hack:)</p>
<p>XCode7.3, Unity5.2.2</p>
<p>UPD: XCode7.3, Unity5.3.4f1 - no issue</p>
</blockquote>
<p>跟我的情况太像了，抱着试一试的态度，然后…Build通过了，游戏也成功的安装到了我的手机上了。</p>
<p>で？这个<code>NORETURN</code>到底是个什么？</p>
<p>查了一下发现这个属性不光是<code>Swift</code>中的，<code>C++</code>中也有。所以说我已经厌倦了什么都学，什么都学对自己来说就是什么都学不会。自己之前一段时间看了<code>Swift</code>然后又去干别的，妥妥的全部忘光。</p>
<h2 id="noreturn-in-Swift"><a href="#noreturn-in-Swift" class="headerlink" title="noreturn in Swift"></a>noreturn in Swift</h2><p><code>noreturn</code>是一种属性，被这个属性修饰的函数表示没有任何返回值，函数可以被重写，但是重写之后也必须没有返回值。</p>
<p>具有代表性的函数有：<code>exit(),abort()</code>等等。</p>
<p>这里有一篇介绍Swift的Attributes的文章<a href="https://qiita.com/hayatan/items/fb875b24084e19cf484b" target="_blank" rel="noopener">Swift - Attributes(@attribute) について 【編集中】</a>介绍了Swift中的修饰属性。</p>
<h2 id="noreturn-in-C"><a href="#noreturn-in-C" class="headerlink" title="noreturn in C++"></a>noreturn in C++</h2><p>相比之下我更在意<code>noreturn</code>在<code>C++</code>中的作用。试着查了一下<a href="/questions/10538291/what-is-the-point-of-no">What is the point of noreturn?</a></p>
<p>字面意思看起来是:不返回函数的结果，没有返回值。但实际上跟<code>void funtion</code>还是有很大的区别。</p>
<ul>
<li><code>void function</code>运行会返回调用函数，只不过没有返回值。</li>
<li>被<code>noreturn</code>修饰的函数在运行结束之后并不会返回调用函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[[ noreturn ]] <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"error"</span>;</span><br><span class="line">    <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   f();</span><br><span class="line">   <span class="comment">// unreachable:  在调用了`f()`之后，下面的代码永远不会执行</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No! That's impossible"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别的事情不说，每次发现这种有关语言的语法的地方不明白的时候，就觉得特别打脸。</p>
]]></content>
      <categories>
        <category>备忘</category>
      </categories>
      <tags>
        <tag>Bugs</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh找不到gulp工具包</title>
    <url>/zsh%E6%89%BE%E4%B8%8D%E5%88%B0gulp%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<p>不能上网，一上网问题就接踵而来。今天突然看到了hexo博文压缩这个功能，就想着这个可以有，就按照教程安装了gult。安装完运行<code>hexo g &amp;&amp; gulp</code>之后准备舒舒服服的打包的时候，我一向视同己出的zsh弹出来了这个提示<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh: <span class="built_in">command</span> not found: gulp</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>刚装的你跟我说找不到？我信了你的邪。</p>
<p>自己解决应该是有点难度了，只能借用大家的智慧了。在网上搜到了这两篇博文<a href="http://blog.webbb.be/command-not-found-node-npm/" target="_blank" rel="noopener">COMMAND NOT FOUND<br>WITH A NODE MODULE (NPM) SOLUTION</a>与<a href="http://kenjimorita.jp/gulp-zsh-command-not-found-gulp/" target="_blank" rel="noopener">【gulp】zsh: command not found: gulp!!!「急にgulpが壊れた!」と思ったら読む記事</a>完美的解决了我的问题。</p>
<p>原因可以从下面的命令中看出来</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  blog npm root</span><br><span class="line">/Users/stone/Documents/mynote/BLOG/blog/node_modules</span><br><span class="line">➜  blog npm root -g</span><br><span class="line">/Users/stone/node_modules</span><br></pre></td></tr></table></figure>
<p>gulp被安装到了个人文件夹中去而不是NPM命令的全局文件夹。</p>
<p>解决办法是运行下面的命令<br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure></p>
<p>再运行一次<code>npm root -g</code>应该就会看到执行后的结果变化<br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  blog npm root -g</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/node_modules</span><br></pre></td></tr></table></figure></p>
<p>然后再次安装gulp，应该是全局的安装<br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">npm i -g gulp</span><br></pre></td></tr></table></figure></p>
<p>确认gulp的版本<br><figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">➜  blog gulp -v</span><br><span class="line">[23:25:50] CLI version 3.9.1</span><br><span class="line">[23:25:50] Local version 3.9.1</span><br></pre></td></tr></table></figure></p>
<p>出现了一个CLI版本跟一个本地的版本。嘛，反正是好用了。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文件转换为PDF文件</title>
    <url>/Markdown%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAPDF%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>最近闲来无事(实际上由于跳槽面试的原因忙的要死)，在知乎上看到了一篇搭建博客的文章，看了一眼发现对于我这种WEB盲还挺友好，于是就自己搭建了这个博客。</p>
<p>就在ZH上捞鱼捞的正爽的时候，面试(未)公司发来了要看看我的作品的消息。我一看表现的时候到了，就掏出我刚学的Markdown来写了几篇我的作品的说明文。正当我想把刚build好的html文件打包压缩发送过去的时候，(自动脑补柯南的灵光一闪音效)我发觉事情并不是这么简单。</p>
<a id="more"></a>
<p>要是我作死直接发了一堆html过去，估计就别想见到人家了，就算见到了人家公司的HR，估计见面也有不小的概率会被锤。这个时候慌乱的我,手不由自主的打开了谷歌并输入了:How to convert markdown to pdf.然后发现正确的提问用法是:How to convert from markdown to pdf.</p>
<p>(；´∀｀)嘛，英语不好这得批评，早晚得去考一次托福…</p>
<p>搜到的第一个是说用<strong>谷歌上的插件</strong>:<a href="https://chrome.google.com/webstore/detail/markdown-preview-plus/febilkbfcbhebfnokafefeacimjdckgl?hl=ja" target="_blank" rel="noopener">Markdown Preview Plus - Chrome Webstore</a>.ドラッグアンドドロップ就可以转换了。什么？ドラ…什么的，打开谷歌翻译:drag and drop.我…</p>
<p>但是利用网上的插件总感觉有些难受，还要上传文件什么的，万一上传到人家服务器上被人家看到了里面的内容就不好了(WEB盲)。于是看到了第二个方法：使用<strong>Node.js的工具</strong><a href="https://github.com/alanshaw/markdown-pdf" target="_blank" rel="noopener">markdown-pdf</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -g install markdown-pdf</span><br></pre></td></tr></table></figure>
<p>安装好工具之后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">markdown-pdf 我的说明文.md</span><br></pre></td></tr></table></figure>
<p>就能生成想要的PDF文件了。浏览生成的PDF文件的时候唯一在意的就是Markdown给隐藏起来的URL链接PDF文件也一并显示了出来。难不成是制作人有意这样，亦或者是机关在作祟，我就暂时不得而知了。因为现在的我得等人家的面试通知。</p>
<p>唉…寝よう</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Markdown</tag>
        <tag>碎碎念</tag>
      </tags>
  </entry>
</search>
