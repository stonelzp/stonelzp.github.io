<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"stonelzp.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta name="keywords" content="UE4,ActionRPG">
<meta property="og:type" content="article">
<meta property="og:title" content="UE4-GameplayAbilitySystem学习">
<meta property="og:url" content="http://stonelzp.github.io/ue4-gameplay-ability-system/index.html">
<meta property="og:site_name" content="StoneのBLOG">
<meta property="og:description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/ListenForAttributeChange.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/abilityflowchartsimple.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/abilityflowchartcomplex.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/InstancingPolicy.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/NetExecutionPolicy.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/AbilityTags1.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/AbilityTags2.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/PassDataToAbility.PNG">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/NetSecurityPolicy.PNG">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/WaitDelay.png">
<meta property="og:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/TaskWaitDelay.png">
<meta property="og:updated_time" content="2021-08-16T01:46:42.523Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="UE4-GameplayAbilitySystem学习">
<meta name="twitter:description" content="这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中Action RPG这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。">
<meta name="twitter:image" content="http://stonelzp.github.io/ue4-gameplay-ability-system/ListenForAttributeChange.png">

<link rel="canonical" href="http://stonelzp.github.io/ue4-gameplay-ability-system/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>UE4-GameplayAbilitySystem学习 | StoneのBLOG</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StoneのBLOG</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">生活这种事情，从来都是自我陶醉</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://stonelzp.github.io/ue4-gameplay-ability-system/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="stone">
      <meta itemprop="description" content="爱自己，对爱你的人来说，是最大的安慰">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StoneのBLOG">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UE4-GameplayAbilitySystem学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-05 12:27:01" itemprop="dateCreated datePublished" datetime="2020-06-05T12:27:01+09:00">2020-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-16 10:46:42" itemprop="dateModified" datetime="2021-08-16T10:46:42+09:00">2021-08-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UnrealEngine4/" itemprop="url" rel="index"><span itemprop="name">UnrealEngine4</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这次是UE4的学习，要学习如何在UE4中制作动作游戏，在UE4官方放出来的案例中<strong>Action RPG</strong>这个案例里面包含了大量有用的知识点，这篇文章就是就这个案例进行学习整理。</p>
<a id="more"></a>
<p>这里涉及到一个相当大的概念，<strong>GamePlay</strong>，这个应该是UE4模式的游戏架构，理解的话需要花费很多精力，大量的名词我都闻所未闻，只能一点点的啃了。</p>
<h1 id="GamePlay-Guide"><a href="#GamePlay-Guide" class="headerlink" title="GamePlay Guide"></a>GamePlay Guide</h1><p>这是官网的标题，暂时我不会整理，先从别的部分一点点入手</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/index.html" target="_blank" rel="noopener">Gameplay Guide-Overviews and examples of gameplay functionality for programmers and visual scripters.</a></li>
</ul>
<p>UE4官网的文章都是有中文的，但是还是放着吧，机翻翻译的我不知所云。</p>
<h2 id="Gameplay-Ability-System"><a href="#Gameplay-Ability-System" class="headerlink" title="Gameplay Ability System"></a>Gameplay Ability System</h2><p>官网上对于GAS的介绍，也是这篇文章要搞明白的部分。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Gameplay/GameplayAbilitySystem/index.html" target="_blank" rel="noopener">Gameplay Ability System-High-level view of the Gameplay Ability System</a></li>
</ul>
<h1 id="ActionRPG"><a href="#ActionRPG" class="headerlink" title="ActionRPG"></a>ActionRPG</h1><p>这里我要逐步理解GAS的组成，剖析这个项目的源码。</p>
<ul>
<li><a href="https://docs.unrealengine.com/en-US/Resources/SampleGames/ARPG/index.html" target="_blank" rel="noopener">Action RPG Game - A sample game that shows how to use the Ability System plugin.</a></li>
</ul>
<h2 id="ActionRPG内容分析"><a href="#ActionRPG内容分析" class="headerlink" title="ActionRPG内容分析"></a>ActionRPG内容分析</h2><h2 id="ActionRPG练习"><a href="#ActionRPG练习" class="headerlink" title="ActionRPG练习"></a>ActionRPG练习</h2><p>这一部分的内容是针对ActionRPG源码的练习，同时也是在公司练手的时候的练习。旨在熟悉GAS的使用。</p>
<p>下一章节的<em>GameplayAbilities and you</em>中是对PlayerInput和Ability进行了绑定，而大多数情况我觉得用到的可能性很小。但是作为熟悉GAS的使用是足够了。下一步是对使用GameplayAbility作为事件的Trigger进行介绍。</p>
<h1 id="GameplayAbilities-and-you"><a href="#GameplayAbilities-and-you" class="headerlink" title="GameplayAbilities and you"></a>GameplayAbilities and you</h1><p>这是一篇本应在UnrealEngineforums上的文章，但是不知道为什么页面被关闭了，但是我找到了GitHub上有人转载了</p>
<ul>
<li><a href="https://github.com/michaeltchapman/MCGameplayAbilities/wiki/GameplayAbilities-and-You" target="_blank" rel="noopener">GameplayAbilities and you</a></li>
</ul>
<p>这是一篇相当晦涩难懂的文章，当然也包含了全是英文这个原因，但是也总好于上面的ActionRPG只有一个工程，其他的啥也没有的要好。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>关于GameplayAbility(一下简称GA)，在这篇文章或者官网中有介绍，或者上面的部分有提到这里不再赘述。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><p>所以让我直接开始正题，如何一步一步按照文章的步骤来初步理解GA的。</p>
<h3 id="Setting-up-the-Project"><a href="#Setting-up-the-Project" class="headerlink" title="Setting up the Project"></a>Setting up the Project</h3><p>第一步是建立我们的项目，首先我是使用的UE4.25版本，创建了一个完全空白的项目。这里文章中要求的是让我们导入<strong>C++ Third persion</strong>，就是那个第三人称的控制器。而在这里我遇见了一个挑战。</p>
<p>如何导入第三人称控制器。由于我创建的是初始的空白项目。</p>
<p>ContentBrows -&gt; Add New -&gt; Add Feature or Content Pack to the Project -&gt; C++ Feature -&gt; Third Person</p>
<p>就这样导入项目了，但是下一个问题又来了，导入项目的ThirdPerson编译错误。</p>
<p>绕了一大圈，最终发现是在项目源码的Build.cs中缺少了<strong>HeadMountedDisplay</strong>这个Module。至于为什么会缺少这个module的原因我猜测是</p>
<ul>
<li>BlankProject确实是没有这个Module的</li>
<li>在我禁用SteamVRPlugin的时候自动给我删除掉了</li>
</ul>
<p>当然我还是觉得第一种可能性是比较大的，而我也没想到这个第三人称的控制器需要用到VR相关的Module。最后的调整，编译无错的版本是这样的：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="创建第一个GamePlayAbility-blueprint"><a href="#创建第一个GamePlayAbility-blueprint" class="headerlink" title="创建第一个GamePlayAbility blueprint"></a>创建第一个GamePlayAbility blueprint</h4><p>这个就是创建一个GA蓝图，继承GameplayAbility蓝图类，这一步超级简单，然后打开创建的蓝图，会看到ActivateAbility的节点，在后面添加一个print节点，打印HelloWorld。</p>
<h3 id="Setting-up-our-Charactor"><a href="#Setting-up-our-Charactor" class="headerlink" title="Setting up our Charactor"></a>Setting up our Charactor</h3><p>哦对，在我们建立项目之后应该启用<strong>GameplayAbilityPlugin</strong>，以便于我们在项目中引用它。</p>
<p>在我们的Build.cs中添加GameplayAbility的Module，最终的感觉像这样：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PublicDependencyModuleNames.AddRange(<span class="keyword">new</span> <span class="keyword">string</span>[] &#123; <span class="string">"Core"</span>, <span class="string">"CoreUObject"</span>, <span class="string">"Engine"</span>, <span class="string">"InputCore"</span>, <span class="string">"HeadMountedDisplay"</span>, <span class="string">"GameplayAbilities"</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>找到第三人称控制器的源码，我们将在源码中添加一些修饰。我自己的项目则是<strong>TP_ThirdPersonCharacter.h</strong>文件。</p>
<p>首先我们要为Charactor添加AbilitySystemComponent组件，在别的地方应该也有提到，这个组件是Actor必须的，非常关键的，对于GameplayAbilitySystem来说。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Camera boom positioning the camera behind the character */</span></span><br><span class="line">UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">USpringArmComponent</span>* <span class="title">CameraBoom</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Follow camera */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UCameraComponent</span>* <span class="title">FollowCamera</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Our ability system */</span> UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Abilities, meta = (AllowPrivateAccess = <span class="string">"true"</span>)) <span class="class"><span class="keyword">class</span> <span class="title">UAbilitySystemComponent</span>* <span class="title">AbilitySystem</span>;</span></span><br></pre></td></tr></table></figure>
<p>因为我添加的代码跟文章中的差不多，所以直接复制粘贴了。</p>
<p>这之后，也是非常重要的，我们需要继承<code>IAbilitySystemInterface</code>接口并实现里面的方法。</p>
<blockquote>
<p>This interface here gives other actors an easy way to both know we have an ability system, and a way to get it without doing something dumb and inefficient like iterating through our components for an ability system.</p>
</blockquote>
<p>AbilitySystem貌似就是通过这个接口来确定Actor的AbilitySystem能否正常工作。实现的效果像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemInterface.h"</span> <span class="comment">//We add this include 别忘了添加头文件</span></span></span><br><span class="line">UCLASS(config=Game) <span class="class"><span class="keyword">class</span> <span class="title">AGameplayAbilitiesTutCharacter</span> :</span> <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface <span class="comment">//We add this parent.继承接口</span></span><br><span class="line"></span><br><span class="line"><span class="function">UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span> <span class="keyword">const</span> override <span class="comment">//We add this function, overriding it from IAbilitySystemInterface. 接口的方法实现</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> AbilitySystem; &#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后我们需要对AbilitySystemComponnent进行创建，在头文件中只是声明了一下。实现的就像这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"TP_ThirdPersonCharacter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AbilitySystemComponent.h"</span></span></span><br><span class="line"><span class="comment">// 省略了与文章无关的头文件</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// ATP_ThirdPersonCharacter</span></span><br><span class="line"></span><br><span class="line">ATP_ThirdPersonCharacter::ATP_ThirdPersonCharacter()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 省略一些源码</span></span><br><span class="line">    <span class="comment">// Create a follow camera</span></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom, USpringArmComponent::SocketName); <span class="comment">// Attach the camera to the end of the boom and let the boom adjust to match the controller orientation</span></span><br><span class="line">    FollowCamera-&gt;bUsePawnControlRotation = <span class="literal">false</span>; <span class="comment">// Camera does not rotate relative to arm</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our ability system component 创建组件</span></span><br><span class="line">    AbilitySystem = CreateDefaultSubobject&lt;UAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystem"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character)</span></span><br><span class="line">    <span class="comment">// are set in the derived blueprint asset named MyCharacter (to avoid direct content references in C++)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Once you have compiled, you can open your character blueprint(which inherits from your C++ character) and lo and behold, right under the character’s movement component you should see an AbilitySystemComponent.</p>
</blockquote>
<p>就像上面说的那样，当你编译之后就能在Map中的第三人称控制器的蓝图中找到我们创建的AbilitySystemComponent组件。</p>
<p>So far so good.</p>
<p>但是目前为止，我们还有很长的路。现在我们什么都没实现。</p>
<blockquote>
<p>That’s because the ability system doesn’t have any abilities to activate yet, nor does it have any inputs assigned to them, anyway, so trying to activate an ability you do not have is, obviously, a quite useless effort. We will work on fixing both things. You must do both things in C++.</p>
</blockquote>
<p>上面这句话有两个：</p>
<ul>
<li>需要一个ability去激活ability system</li>
<li>需要绑定输入(inputs)到它们身上</li>
</ul>
<h3 id="Binding-to-Character-input"><a href="#Binding-to-Character-input" class="headerlink" title="Binding to Character input"></a>Binding to Character input</h3><p>首先，我们需要将我们的AbilitySystem绑定到Character’s input。我们想把我们的abilitysystem绑定到UInputComponent上。</p>
<blockquote>
<p>We want to call AbilitySystem-&gt;BindAbilityActivationToInputComponent within the SetupPlayerInputComponent. It takes two parameters: The UInputComponent pointer at hand and a struct called FGameplayAbiliyInputBinds. This is not a typo! It is not called FGameplayAbilityInputBinds, but FGameplayAbiliyInputBinds!</p>
</blockquote>
<p>所以说FGameplayAbiliyInputBinds是什么？注意这里我还真拼错了一次。</p>
<blockquote>
<p>The constructor for FGameplayAbiliyInputBinds takes at least 3 parameters: The first two are strings, and represent the input names that will be used to define “Confirm” and “Cancel”-input commands. You do not necessarily need these depending on your game, but abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too, so generally it can’t hurt to have these even if you will never use them. The third parameter is the name of an arbitrary UEnum of all things. This is one of the witchcraft-ier aspects of the system: <strong>The ability system component will look into the enum whose name you’ve given and will map its ability slots to the names of the elements contained within the enum</strong>.</p>
</blockquote>
<p>顾名思义，应该就是负责存储对应Ability和键位映射的结构数据或者中间数据，FGameplayAbiliyInputBinds的构造函数至少有三个参数，前两个参数是字符串，代表着定义”Confirm”和”Cancel”两个输入命令(input commands)的输入名字。根据游戏的需要可能这并不是必须的。</p>
<p>这里我没怎么明白这前两个参数的具体意思，文章中说的<em>abilities can be set up to listen to these while they’re active, and targeting actors (basically, actors that return an ability viable targets/locations to aim at for an ability, if an ability requests one) will use these too</em>这里我也不是非常清楚，谁是谁，说的是谁我都不知道。</p>
<p>第三个参数是一个自定义的UENUM枚举，他说这里是这个GAS的神奇的地方，而我只觉得想骂人。</p>
<p>AbilitySystemComponent会取出自定义的枚举类型的名字，然后映射他的<strong>ability slots</strong>到这个枚举类型中所包含的名字上。下面是这个自定义枚举的举例实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example for an enum the FGameplayAbiliyInputBinds may use to map input to ability slots.</span></span><br><span class="line"><span class="comment">//It's very important that this enum is UENUM, because the code will look for UENUM by the given name and crash if the UENUM can't be found. BlueprintType is there so we can use these in blueprints, too. Just in case. Can be neat to define ability packages.</span></span><br><span class="line">UENUM(BlueprintType) <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">AbilityInput</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    UseAbility1 UMETA(DisplayName = "Use Spell 1"), //This maps the first ability(input ID should be 0 in int) to the action mapping(which you define in the project settings) by the name of "UseAbility1". "Use Spell 1" is the blueprint name of the element.</span><br><span class="line">    UseAbility2 UMETA(DisplayName = "Use Spell 2"), //Maps ability 2(input ID 1) to action mapping UseAbility2. "Use Spell 2" is mostly used for when the enum is a blueprint variable.</span><br><span class="line">    UseAbility3 UMETA(DisplayName = "Use Spell 3"),</span><br><span class="line">    UseAbility4 UMETA(DisplayName = "Use Spell 4"),</span><br><span class="line">    WeaponAbility UMETA(DisplayName = "Use Weapon"), //This finally maps the fifth ability(here designated to be your weaponability, or auto-attack, or whatever) to action mapping "WeaponAbility".</span><br><span class="line"></span><br><span class="line">    <span class="comment">//You may also do something like define an enum element name that is not actually mapped to an input, for example if you have a passive ability that isn't supposed to have an input. This isn't usually necessary though as you usually grant abilities via input ID,</span></span><br><span class="line">    <span class="comment">//which can be negative while enums cannot. In fact, a constant called "INDEX_NONE" exists for the exact purpose of rendering an input as unavailable, and it's simply defined as -1.</span></span><br><span class="line">    <span class="comment">//Because abilities are granted by input ID, which is an int, you may use enum elements to describe the ID anyway however, because enums are fancily dressed up ints.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我直接复制粘贴了。将上面的Enum实现放到头文件，然后回到cpp文件中对键位进行绑定。</p>
<p>回到Cpp文件中的<code>SetupPlayerInputComponent</code>函数中,用户输入键位进行绑定。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystem-&gt;BindAbilityActivationToInputComponent(PlayerInputComponent, FGameplayAbiliyInputBinds(<span class="string">"ConfirmInput"</span>, <span class="string">"CancelInput"</span>, <span class="string">"AbilityInput"</span>));</span><br></pre></td></tr></table></figure></p>
<p>所以到这一步为止，如果编译没有出错误的话，我们已经成功的将<strong>ability system’s sbility activation</strong>()绑定到了用户输入(player input)上。</p>
<h3 id="Giving-the-Character-an-Ability"><a href="#Giving-the-Character-an-Ability" class="headerlink" title="Giving the Character an Ability"></a>Giving the Character an Ability</h3><p>最后一步是给我们的AbilitySystem一个Ability，就如已经预备好的一样，我们要将这个Ability放到已经映射到PlayerInput的第一个ability slot上。</p>
<p>这里使用了蓝图的一个类似Unity的Inspector中拖拽搞定Reference的功能，我之前也有实现过，只不过拖拽是不支持的，可以在下拉菜单中选择自己定义好的蓝图而已，而这里则是选择我们一开始创建的那个GameplayAbility蓝图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Abilities)</span><br><span class="line">TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UGameplayAbility</span>&gt; <span class="title">Ability</span>;</span></span><br></pre></td></tr></table></figure>
<p>随后我们将在BeginPlay中调用AbilitySystem的GiveAbility函数，看名字就知道是干什么得了。但是需要注意的是我们必须，或者说只能在Server端执行Ability的赋予，这里应该是GAS的要求或者说实现，因为GAS是支持多人通信的系统，就文章所说如果在Client中赋予Ability的话，会崩溃，UE4和你都会崩溃（这是我加的）。</p>
<p>GiveAbility需要一个FGameplayAbilitySpec作为参数，FGameplayAbilitySpec是围绕着GameplayAbility的数据（类型），包含着level和input ID。</p>
<blockquote>
<p>GiveAbility requests an FGameplayAbilitySpec as parameters. An FGameplayAbilitySpec is the data surrounding a GameplayAbility, notably which level (the system has built-in support for a level variable, quite good for RPGs/MOBAs as mentioned) and which input ID it is.</p>
</blockquote>
<ul>
<li>level: 系统已经内置的关卡变量，对RPGs/MOBAs类的游戏非常友好。也就是关卡的标志，或许我以后会经常用到。</li>
<li>input ID: 这里终于跟上面连起来了，那个自定义的ENUM已经跟我们的AbilitySystem的AbilitySlots进行了绑定，这个Input ID则是可以对AbilitySlot进行指定（这是目前为止自己的理解）</li>
</ul>
<p>FGameplayAbilitySpec需要一个GameplayAbility对象作为参数，我们可以使用Ability的默认对象（class’s default object），依文章的作者所言：</p>
<blockquote>
<p>There is very little reason to use anything other than the default object of a GameplayAbility class as far as I’ve understood it from going through the source.</p>
</blockquote>
<p>关于默认对象的描述贴一段来自官网的内容：</p>
<blockquote>
<p><a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Objects/index.html" target="_blank" rel="noopener">Objects</a></p>
<p>The UCLASS Macro</p>
<p>The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type. Each UCLASS maintains one Object called the ‘Class Default Object’, or CDO for short. The CDO is essentially a default ‘template’ Object, generated by the class constructor and unmodified thereafter. Both the UCLASS and the CDO can be retrieved for a given Object instance, though they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the GetClass() function.</p>
</blockquote>
<p>我们还要调用<strong>AbilitySystem-&gt;InitAbilityActorInfo</strong>函数，来告诉AbilitySystem谁是Owner谁是Avatar。</p>
<blockquote>
<p>Finally, while on the topic of BeginPlay, we should also call AbilitySystem-&gt;InitAbilityActorInfo. It tells the AbilitySystem what its Owner (the actor responsible for the AbilitySystem) and Avatar (the actor through which the AbilitySystem acts, uses Abilities from etc.) is. In our case our character is both.</p>
</blockquote>
<ul>
<li>Owner: AbilitySystem的持有Actor</li>
<li>Avatar:使用这个AbilitySystem的Ability的Actor？这里我不是太明白。</li>
</ul>
<p>BeginPlay中的实现效果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BeginPlay</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> ATP_ThirdPersonCharacter::BeginPlay()</span><br><span class="line">&#123;</span><br><span class="line">    Super::BeginPlay();</span><br><span class="line">    <span class="keyword">if</span> (AbilitySystem) &#123;</span><br><span class="line">    <span class="keyword">if</span> (HasAuthority() &amp;&amp; Ability) &#123;</span><br><span class="line">    AbilitySystem-&gt;GiveAbility(FGameplayAbilitySpec(Ability.GetDefaultObject(), <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    AbilitySystem-&gt;InitAbilityActorInfo(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还有需要注意的是，我们必须要保证每当controller改变的时候，AbilitySystemComponent’s ActorInfo struct的内容被更新。这里贴上原作者的话:</p>
<blockquote>
<p>You also need to make sure that the AbilitySystemComponent’s ActorInfo struct is being updated each time the controller changes. On the surface much of the system will work without that, but in a multiplayer enviroment especially(where pawns may be spawned before the client controller possesses them) you will experience crashes and behaviour that can be difficult to debug should you not properly set the ActorInfo up.</p>
</blockquote>
<p>这里有我不太明白的地方，就下面的源码来看这个Controller指的是哪个Controller我都不知道，这里是知识盲区。实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController * NewController)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="keyword">void</span> AGameplayAbilitiesTutCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">   Super::PossessedBy(NewController);</span><br><span class="line">   AbilitySystem-&gt;RefreshAbilityActorInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里扫一下盲，关于PossessedBy函数的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pawn.h</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Called when this Pawn is possessed. Only called on the server (or in standalone).</span></span><br><span class="line"><span class="comment">    * @param NewController The controller possessing this pawn</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PossessedBy</span><span class="params">(AController* NewController)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>以上都编译好了之后，还有两步，一是把我们一开始创建好的GameplayAbility蓝图（输出HelloWorld）指定到我们预备好的AbilitySlot上。</p>
<p>在打开的Map中找到我们使用的第三人称控制器（ThirdPersonCharacter），在它的Details面板使用我们设置的Category-Abilities检索，便会找到我们准备好的AbilitySlot1，在这里我们指定我们制作的打印HelloWorld的GameplayAbility蓝图。</p>
<p>第二步是指定PlayerInput的映射，我们已经把Ability映射到了PlayerInput上了，但是没有指定哪一个Ability到哪一个键位，这个时候回想起那个我们制作的不知道干什么的UENUM枚举类型。</p>
<p>去Edit-&gt;Project Settings中找到Input，添加Action Mappings。</p>
<p>添加一个新的<strong>Action Mappings</strong>，名字指定为”UseAbility1”,这个名字跟你声明的Enum枚举类型里定义的变量名对应，注意是变量名字。然后指定键位，我这里指定的是Enter键。</p>
<p>好了以上就是我跟着做的过程的全部内容，运行游戏，然后按下Enter键，就会发现左上角打印出了HelloWorld！。</p>
<p>虽然只能触发一次。</p>
<p>这里文章还提到如果出现了问题，比如说UE4崩溃，或者AbilityActor is invalid之类的错误的话提供下面的解决方案：</p>
<blockquote>
<p>Note that if it crashes and spits out an error message talking about AbilityActorInfo being invalid, try adding this code just before the HasAuthority() check and seeing if it fixes the problem:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FGameplayAbilityActorInfo* ActorInfo = <span class="keyword">new</span> FGameplayAbilityActorInfo();</span><br><span class="line">ActorInfo-&gt;InitFromActor(<span class="keyword">this</span>, <span class="keyword">this</span>, AbilitySystem); AbilitySystem-&gt;AbilityActorInfo = TSharedPtr&lt;FGameplayAbilityActorInfo&gt;(actorInfo);</span><br></pre></td></tr></table></figure>
<p>然后我们枯燥的部分终于告一段落了。</p>
<h2 id="The-Essentials-要点"><a href="#The-Essentials-要点" class="headerlink" title="The Essentials (要点)"></a>The Essentials (要点)</h2><p>在解决了漫长的Setup设置之后，是对GAS的各种基础概念进行认知。但是这篇文章从现在开始的部分真的对我来说是晦涩难懂，每一句话太长了，让我陷入了不会英语的自责。。。</p>
<p>我只能一点点的理解。</p>
<p>这个章节是对GAS中的一些要点，关键概念进行总结和理解。</p>
<h3 id="GameplayAbilities"><a href="#GameplayAbilities" class="headerlink" title="GameplayAbilities"></a>GameplayAbilities</h3><h3 id="GameplayTasks"><a href="#GameplayTasks" class="headerlink" title="GameplayTasks"></a>GameplayTasks</h3><h3 id="GameplayEffects"><a href="#GameplayEffects" class="headerlink" title="GameplayEffects"></a>GameplayEffects</h3><h3 id="AttributeSet"><a href="#AttributeSet" class="headerlink" title="AttributeSet"></a>AttributeSet</h3><p>这里我先跨过前面的部分直接说AttributeSet。其实我是大概的看完了这个部分，然后又看了下面的文章才更新的这部分的内容的。</p>
<ul>
<li><a href="https://forums.unrealengine.com/community/community-content-tools-and-tutorials/116578-comprehensive-gameplayabilities-analysis-series" target="_blank" rel="noopener">Comprehensive GameplayAbilities Analysis Series</a></li>
</ul>
<p>这篇文章对AttributeSet的内容讲解的稍微深了些，或者说配合代码讲解，本应是很好理解的，但是我只理解了一半。有时间，或者再加深一些理解之后再来总结这篇文章吧。</p>
<h1 id="GASDocumentation"><a href="#GASDocumentation" class="headerlink" title="GASDocumentation"></a>GASDocumentation</h1><ul>
<li><a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a></li>
</ul>
<p>这是一个完整的关于GameplayAbilitySystem的框架的使用文章，这里面包含了很多的知识，也吃掉了我许多时间，实在是理解GAS的一个非常好非常重要的文章。</p>
<p>由于理解本身就已经非常费时费力，当然更多的是自己的摸鱼和工作不力，但还是希望能好好理解UE4这个框架</p>
<h2 id="GASDocumentation的个人翻译和理解"><a href="#GASDocumentation的个人翻译和理解" class="headerlink" title="GASDocumentation的个人翻译和理解"></a>GASDocumentation的个人翻译和理解</h2><p>在这里我准备把这个GitHub的文章的一些重要部分进行翻译和整理，当然不是全部，还有对其中的实现做一些记录。</p>
<h3 id="Intro-to-the-GameplayAbilitySystem-Plugin"><a href="#Intro-to-the-GameplayAbilitySystem-Plugin" class="headerlink" title="Intro to the GameplayAbilitySystem Plugin"></a>Intro to the GameplayAbilitySystem Plugin</h3><p>官网上的说明跳过不说，我自己的理解就是，GAS这个系统是为RPG和MOBA类游戏打造的框架，里面包含了升级啊角色技能冷却啊之类的要素的开箱即用的功能，即包装好的功能。由于在这个框架中实现了许多Multiplay的内容，相较于自己重新构建，学习使用这个框架的成本更低一些，嘛代价就是不能彻底理解UE4的多人游戏网络框架了。</p>
<p>但是有得必有失。由于GAS已经内置于UE4的源码中了，所以直接拿来用就好了。如果有不满的地方，那么之后再考虑如何对其进行扩展。</p>
<p>关于UE4中关于GAS提供的功能，在这篇文章中是这样形容的：</p>
<blockquote>
<p>The plugin provides an out-of-the-box solution in single and multiplayer games for:</p>
<ul>
<li>Implementing level-based character abilities or skills with optional costs and cooldowns (GameplayAbilities)</li>
<li>Manipulating numerical Attributes belonging to actors (Attributes)</li>
<li>Applying status effects to actors (GameplayEffects)</li>
<li>Applying GameplayTags to actors (GameplayTags)</li>
<li>Spawning visual or sound effects (GameplayCues)</li>
<li>Replication of everything mentioned above</li>
</ul>
</blockquote>
<p>在我整理这篇文章的时候已经对这篇文章和这个项目的源码进行了大致的理解和实现，所以对于不知所云的地方会加上一些标注。</p>
<p>GAS提供的一些开箱即用的功能有（包含单人和多人游戏）：</p>
<ul>
<li>基于等级的能力和技能的实现带有一些数值的消耗或者冷却时间，即GameplayAbility</li>
<li>操纵Actor的数值属性，即Attribute</li>
<li>应用一些“影响”到Actor当前的状态上，即GameplayEffect</li>
<li>将GameplayTags应用到Actor上，即一些GameplayTag的使用</li>
<li>生成一些特效或音效，即GameplayCue</li>
<li>上述提到的内容的状态复制，即Replication</li>
</ul>
<blockquote>
<p>In multiplayer games, GAS provides support for client-side prediction of:</p>
<ul>
<li>Ability activation</li>
<li>Playing animation montages</li>
<li>Changes to Attributes</li>
<li>Applying GameplayTags</li>
<li>Spawning GameplayCues</li>
<li>Movement via RootMotionSource functions connected to the CharacterMovementComponent.</li>
</ul>
</blockquote>
<p>关于GAS的一些高级特性，就是某种程度上提供了<strong>客户端本地预测</strong>。</p>
<ul>
<li>Ability的激活</li>
<li>Animation Montage的播放</li>
<li>Attribute的变动</li>
<li>应用GameplayTag</li>
<li>生成GameplayCue</li>
<li><span style="color: red; ">Movement via RootMotionSource functions connected to the CharacterMovementComponent.</span></li>
</ul>
<p>最后一个特性是我没有遇见过的也是没有验证过的，也不知道该怎么翻译</p>
<blockquote>
<p>Current issues with GAS:</p>
<ul>
<li>GameplayEffect latency reconciliation (can’t predict ability cooldowns resulting in players with higher latencies having lower rate of fire for low cooldown abilities compared to players with lower latencies).</li>
<li>Cannot predict the removal of GameplayEffects. We can however predict adding GameplayEffects with the inverse effects, effectively removing them. This is not always appropriate or feasible and still remains an issue.</li>
<li>Lack of boilerplate templates, multiplayer examples, and documentation. Hopefully this helps with that!</li>
</ul>
</blockquote>
<p>目前GAS上仍然需要解决的问题是以下几个问题：</p>
<ul>
<li>GameplayEffect latency reconciliation, 我也不知道该怎么翻译这个，按照描述时所说就是ability的colldown无法本地预测导致了拥有高延迟的本地玩家相较于低延迟的玩家拥有更低的开火率，这在GameplayEffect章节中会再提及。</li>
<li>不能预测GameplayEffect的移除。虽然可以预测性的添加具有相反效果的GE来完成看似删除的效果，但是这不是总是可行的，仍然是一个问题。</li>
<li>确实样例模板和文档。（跟GAS相关的文档就少到离谱，而且大多还是英文，而事实上这篇文章帮了我很多很多）</li>
</ul>
<p>但是最详尽的文档就是UE4的源码了…</p>
<h3 id="Setting-Up-a-Project-Using-GAS"><a href="#Setting-Up-a-Project-Using-GAS" class="headerlink" title="Setting Up a Project Using GAS"></a>Setting Up a Project Using GAS</h3><blockquote>
<ol>
<li>Enable GameplayAbilitySystem plugin in the Editor</li>
<li>Edit YourProjectName.Build.cs to add “GameplayAbilities”, “GameplayTags”, “GameplayTasks” to your PrivateDependencyModuleNames</li>
<li>Refresh/Regenerate your Visual Studio project files</li>
<li>Starting with 4.24, it is now mandatory to call UAbilitySystemGlobals::InitGlobalData() to use TargetData. The Sample Project does this in UEngineSubsystem::Initialize(). See InitGlobalData() for more information.</li>
</ol>
</blockquote>
<p>前几条就是常规操作了，但是最后一条，在使用了<strong>TargetData</strong>之后，不要忘记调用<code>UAbilitySystemGlobals::InitGlobalData()</code>，这个部分我还没有验证过。</p>
<h3 id="AbilitySystemComponent"><a href="#AbilitySystemComponent" class="headerlink" title="AbilitySystemComponent"></a>AbilitySystemComponent</h3><p><code>AbilitySystemComponent</code>简称ACS，是GAS的自内脏，嘛就是中心，控制着GAS中的所有的交互。如果想要让一个Actor拥有<strong>Attributes</strong>，或者能够使用<strong>GameplayAbilities</strong>，那么对于Actor来说都需要一个ACS。我们可以选择直接使用或者继承它自己定义新的Component。</p>
<p>ACS所依附(AttachTo)的Actor一般名义上就是这个ASC的<strong>OwnerActor</strong>。而ACS的实际上的物理使用者Actor则被称为<strong>AvatarActor</strong>。(这里文章所说的<em>PhysicalRepresentationActor</em>我不知道该如何翻译)一般情况下这两者都会是相同的Acotr(MOBA游戏中的简单的AI控制单位AI minion等等)。他们也有可能是不同的Actor，比如说MOBA游戏中玩家控制的Hero角色，OwnerActor是PlayerState，AvatarActor则是Hero的Character类来担任。</p>
<p>大多数情况下Actor都会自己持有ASC，除非是想要Respawn这个Actor而且想要持续的保持Actor中的属性状态，就像是MOBA游戏中的Hero的属性，这个时候我们第一个想到的就是将ASC放到PlayerState上。</p>
<blockquote>
<p>If your Actor will respawn and need persistence of Attributes or GameplayEffects between spawns (like a hero in a MOBA), then the ideal location for the ASC is on the PlayerState.</p>
</blockquote>
<p>需要注意的是：</p>
<ol>
<li>如果设置了ASC到PlayerState上了，要记着调整<code>NetUpdateFrequency</code>的值。默认的值很低，使用默认值的话，Client上可能会有很高的延迟感，相对于Attributes和GameplayTag的使用来说。<ul>
<li>记得开启<code>AdaptiveNetworkUpdateFrequency</code>选项。Fortnite使用了这个。</li>
</ul>
</li>
<li><p>想要使用ASC的时候一定要继承实现<code>IAbilitySystemInterface</code>,如果是上述的那种OwnerActor和AvatarActor不同的情况下（也就是PlayerState拥有真正的ASC实例，Character只是ASC的指针的时候）对于两个Actor来说，都需要继承该接口并对其进行实现。</p>
<ul>
<li><code>UAbilitySystemComponent* GetAbilitySystemComponent() const</code>进行实现</li>
<li>ASCs interact with each other internally to the system by looking for this interface function.ASC之间的交互貌似会用到这个接口，其他情况下不太清楚。</li>
</ul>
</li>
<li><p>ASC中有一个变量<code>FActiveGameplayEffectsContainer ActiveGameplayEffects</code>用来保存目前active状态的GameplayEffects</p>
</li>
<li>ASC中有一个变量<code>GameplayAbilitySpecContainer ActivatableAbilities</code>用来保存所有生成的GameplayAbilities。<ul>
<li>这里的<em>granted Gameplay Abilities</em>的翻译可能不是很准确。</li>
<li>如果需要遍历<code>ActivatableAbilities.Items这个List的时候，一定要在之前加上</code>ABILITYLIST_SCOPE_LOCK();`来防止在循环的时候内容被修改(removing a ability是被修改的原因)。</li>
<li>在scope中的时候<code>AbilityScopeLockCount</code>会加算，scope运行结束之后会减去。</li>
<li>不要尝试在<code>ABILITYLIST_SCOPE_LOCK();</code>中移除ability(the clear ability functions check AbilityScopeLockCount internally to prevent removing abilities if the list is locked)</li>
</ul>
</li>
</ol>
<h4 id="Replication-Mode"><a href="#Replication-Mode" class="headerlink" title="Replication Mode"></a>Replication Mode</h4><p>ASC为<code>GameplayEffects</code>,<code>GameplayTags</code>,<code>GameplayCues</code>提供了三种不同的复制模式(Replication Mode)，<code>Full</code>,<code>Mixed</code>,<code>Minimal</code>。<br><code>Attributes</code>的Replication是由<code>AttributeSet</code>负责的。</p>
<table>
<thead>
<tr>
<th>Replication Mode</th>
<th>When to Use</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Full</code></td>
<td>SinglePlayer</td>
<td>每一个<code>GameplayEffect</code>都会被复制(replicated)到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Mixed</code></td>
<td>Multiplayer,<br> player controlled Actors</td>
<td><code>GameplayEffect</code>只会被复制到自己的<strong>OwningClient</strong>上。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
<tr>
<td><code>Minimal</code></td>
<td>Multiplayer,<br>AI controlled Actors</td>
<td><code>GameplayEffect</code>不会被复制到任何客户端的连接。只有<code>GameplayTags</code>和<code>GameplayCues</code>会被复制到每一个对应的客户端上。</td>
</tr>
</tbody>
</table>
<p>Note：这里需要注意的是，设置为<code>Mixed</code>模式的时候，ASC的<code>OwnerActor&#39;s</code> <code>Owner</code>需要是<code>Controller</code>。<code>PlayerState</code>的<code>Owner</code>默认就是<code>Controller</code>，而使用<code>Character</code>的情况下就不是，需要我们调用<code>SetOwner()</code>函数手动设置一个有效的<code>Controller</code>。</p>
<p>从UE4的4.24版本开始，<code>Pawn</code>的<code>PossessedBy()</code>函数会设置<code>Owner</code>的新<code>Controller</code>。</p>
<p>出于好奇，调查了一下<code>SetOwner()</code>函数，发现这个是<code>AActor</code>的函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Set the owner of this Actor, used primarily for network replication.</span></span><br><span class="line"><span class="comment">     * @param NewOwner The Actor who takes over ownership of this Actor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetOwner</span><span class="params">( AActor* NewOwner )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the owner of this Actor, used primarily for network replication. */</span></span><br><span class="line">    UFUNCTION(BlueprintCallable, Category=Actor)</span><br><span class="line">    <span class="function">AActor* <span class="title">GetOwner</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似Actor的Owner都需要正确的设置才能被Replicated。</p>
<h4 id="Setup-and-Initialization"><a href="#Setup-and-Initialization" class="headerlink" title="Setup and Initialization"></a>Setup and Initialization</h4><p>ACS一般情况下都需要在<code>OwnerActor</code>的构造函数中创建，而且需要被标记为<strong>Replicated</strong>。这一步只能在C++中完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AGDPlayerState::AGDPlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create ability system component, and set it to be explicitly replicated</span></span><br><span class="line">    AbilitySystemComponent = CreateDefaultSubobject&lt;UGDAbilitySystemComponent&gt;(TEXT(<span class="string">"AbilitySystemComponent"</span>));</span><br><span class="line">    AbilitySystemComponent-&gt;SetIsReplicated(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ASC需要初始化它<strong>Server/Client</strong>的<code>OwnerActor</code>和<code>AvatarActor</code>，这一步可以在<code>Pawn</code>的<code>Controller</code>被设置(possession)的时候执行。单人游戏的话就只需要担心Server端就行了。</p>
<p>据作者的习惯，当把ASC放在玩家控制的Pawn的时候，我们可以在Server的<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，Client端在<code>PlayerController&#39;s</code> <code>AcknowledgePossession()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> APACharacterBase::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (AbilitySystemComponent)</span><br><span class="line">    &#123;</span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ASC MixedMode replication requires that the ASC Owner's Owner be the Controller.</span></span><br><span class="line">    SetOwner(NewController);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> APAPlayerControllerBase::AcknowledgePossession(APawn* P)</span><br><span class="line">&#123;</span><br><span class="line">    Super::AcknowledgePossession(P);</span><br><span class="line"></span><br><span class="line">    APACharacterBase* CharacterBase = Cast&lt;APACharacterBase&gt;(P);</span><br><span class="line">    <span class="keyword">if</span> (CharacterBase)</span><br><span class="line">    &#123;</span><br><span class="line">            CharacterBase-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(CharacterBase, CharacterBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们把ASC放到玩家控制的<code>PlayerState</code>上的时候，Server端还是一样放到<code>Pawn&#39;s</code> <code>PossessedBy()</code>中初始化，而Client端在<code>Pawn&#39;s</code> <code>OnRep_PlayerState()</code>中初始化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Server only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::PossessedBy(AController * NewController)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PossessedBy(NewController);</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC on the Server. Clients do this in OnRep_PlayerState()</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AI won't have PlayerControllers so we can init again here just to be sure. No harm in initing twice for heroes that have PlayerControllers.</span></span><br><span class="line">            PS-&gt;GetAbilitySystemComponent()-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client only</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::OnRep_PlayerState()</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnRep_PlayerState();</span><br><span class="line"></span><br><span class="line">    AGDPlayerState* PS = GetPlayerState&lt;AGDPlayerState&gt;();</span><br><span class="line">    <span class="keyword">if</span> (PS)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">// Set the ASC for clients. Server does this in PossessedBy.</span></span><br><span class="line">            AbilitySystemComponent = Cast&lt;UGDAbilitySystemComponent&gt;(PS-&gt;GetAbilitySystemComponent());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Init ASC Actor Info for clients. Server will init its ASC when it possesses a new Actor.</span></span><br><span class="line">            AbilitySystemComponent-&gt;InitAbilityActorInfo(PS, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果出现了<code>LogAbilitySystem: Warning: Can&#39;t activate LocalOnly or LocalPredicted ability %s when not local!</code>这样的警告消息，意味着ASC没有在Client端完成<code>OwnerActor</code>和<code>AvatarActor</code>的初始设定。</p>
<p><strong>Tips:</strong> <br><br>这里在ASC到底是放在PlayerState还是Character上的问题上，就我自身遇到的情况来看，</p>
<p>当ASC放在PlayerState上的时候，即ASC的OwnerActor是PlayerState，优点是可以省略一些Controller的设置操作。但是我遇到的是需要对ASC中的属性进行Replicated的时候，由于PlayerState本身默认的<code>NetUpdateFrequency</code>的值很低(听来的)，更新不频繁就会使得属性的Replication变得很迟缓，故而会有问题。</p>
<p>调整PlayerState的属性网络更新频率也是一种方法，但是跟Character的情况就多了一些操作。</p>
<h3 id="Gameplay-Tags"><a href="#Gameplay-Tags" class="headerlink" title="Gameplay Tags"></a>Gameplay Tags</h3><p><code>FGameplayTags</code>是一种层级式的命名方式，就像<code>Parent.Child.Grandchild...</code>这样，被登记在<code>GameplayTagManager</code>里面。据作者所说，<code>GameplayTags</code>非常的有用，有的时候会在程序的逻辑中使用一些<code>booleans</code>或者枚举，这些可以用<code>GameplayTags</code>来替代。</p>
<p>通常我们是向ASC中添加一个<code>Tag</code>，以便于和<strong>GAS</strong>的交互。<code>UAbilitySystemComponent</code>实现了<code>IGameplayTagAssetInterface</code>接口，这个接口提供了访问自己的<code>GameplayTags</code>的函数。</p>
<p>多个<code>GameplayTags</code>可以使用<code>FGameplayTagContainer</code>来存储，相比于常规的<code>TArray&lt;FGameplayTag&gt;</code>，前者更加有效率(efficiency magic)。Tags是标准的<code>FName</code>类型，在<code>FGameplayTagContainer</code>中存储可以非常效率的打包方便<strong>Replication</strong>。前提是开启了ProjectSetting中的<code>Fast Replication</code>功能。<code>Fast Replication</code>要求Server和Client拥有相同的<code>GameplayTags</code>的列表(list)，一般情况下这不是问题，所以应该开启这个功能。</p>
<p><code>GameplayTagontainer</code>也可以返回一个<code>TArray&lt;FGameplayTag&gt;</code>方便我们遍历。</p>
<p>存储在<code>FGameplayTagCountContainer</code>的<code>GameplayTags</code>有一个<code>TagMap</code>被用来存储<code>GameplayTag</code>的实例(Instance)的数量。一个<code>FGameplayTagCountContainer</code>也许会存在某个<code>GameplayTag</code>，但是它的<code>TagMapCount</code>的值是<code>0</code>，这也许会在调试的时候遇到这种情况，可能明明已经移除了这个GameplayTag(encounter)，但是ASC仍然持有这个<code>GameplayTag</code>。</p>
<p>使用<code>HasTag()</code>或者<code>HasMatchingTag()</code>之类相似的函数，会检查<code>TagMapCount</code>的值，当该<code>GameplayTag</code>不存在亦或者<code>TagMapCount</code>的值为0的时候返回false。</p>
<p>使用<strong>GameplayTag</strong>的时候，一定要在<code>DefaultGameplayTags.ini</code>中提前定义。（个人经验就是用了没有定义过的GameplayTags之后会发生不太好的事情）成为直接在配置文件中定义GameplayTag之外，还可以利用UE4Editor提供的接口界面，</p>
<p>此处应有GameplayTag的编辑界面图片。</p>
<blockquote>
<p>Searching for GameplayTag references will bring up the familiar Reference Viewer graph in the Editor showing all the assets that reference the GameplayTag. This will not however show any C++ classes that reference the GameplayTag.<br>这句话的意思没有完全理解，在尝试对<code>GameplayTag</code>的Reference进行搜索的时候，使用那个<strong>ReferenceViewer</strong>，会表示与之相关的资产(Assets)，但是不会显示任何与C++类相关联的资产。</p>
</blockquote>
<p>这句话让我联想到了如果一大堆素材与这个GameplayTag相关联的话，是不是都会被加载到内存里面，无论它是不是会用到。至于C++中使用这个GameplayTag的话是不是就相对安全一些？看来在制作的过程中，勤奋的确认ReferenceView的内容是必要的啊。</p>
<p>对GameplayTag进行重命名(Rename)会产生一个重定向(redirect)以便于其所关联的资产能够重定向到新的GameplayTag上。据作者所说，可能的话还是新建一个GameplayTag，然后手动调整资产连接到新的GameplayTag上，然后删掉旧的GameplayTag，最好还是避免创建重定向(redirect)资源。我也认为既然重命名是一个会创建资源的操作的话还是避免为好。</p>
<p>除了<code>Fast Replication</code>之外，<code>GameplayTag</code> editor还有一个可以更加深度优化<code>GameplayTag</code>的<code>Replicated</code>的选项。</p>
<p>由<code>GameplayEffect</code>添加的GameplayTag会Replicated。ASC还允许添加不会Replicated的<code>LooseGameplayTags</code>，它必须手动的进行管理。该项目就使用了<code>State.Dead</code>作为<code>LooseGameplayTag</code>，以便于当玩家的HP降到0的时候OwningClient能够立马做出反应。Respawning的时候再手动的将这个Tag的<code>TagMapCount</code>置为0。当使用<code>LooseGameplayTag</code>的时候，只能手动的去调整<code>TagMapCount</code>的值。</p>
<p>这里推荐<code>UAbilitySystemComponent::AddLooseGameplayTag()</code>和<code>UAbilitySystemComponent::RemoveLooseGameplayTag()</code>函数，它们应该会自动调整<code>TagMapCount</code>的值，使用这个函数应该不用真的去对TagMapCount的值进行操作。</p>
<p>在C++中获取一个GameplayTag的Reference的方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FGameplayTag::RequestGameplayTag(FName(<span class="string">"Your.GameplayTag.Name"</span>))</span><br></pre></td></tr></table></figure></p>
<p><code>GameplayTagManager</code>还提供了一些GameplayTag的高级用法，比如获取一个GameplayTag的Parent和Children。添加<code>GameplayTagManager.h</code>头文件以便于使用其功能。<code>UGameplayTagManager::Get().FunctionName</code>这样调用，实际上GameplayTagManager就是用这种类似节点(relational node)的方式(parent,child,etc)来存储GameplayTag，方便用来进行类似字符串的合并对比操作。</p>
<p>GameplayTag和GameplayTagContainer有一个可选的<code>UPROPERTY()</code>属性修饰符(specifier)，<code>Meta = (Categories = &quot;GameplayCue&quot;)</code>，可以用来在Blueprint中筛选表示ParentNode是<code>GameplayCue</code>的标签。当你知道这些GameplayTag和GameplayTagContainer仅在<code>GameplayCue</code>中使用的时候这个修饰符会很有用。</p>
<p>除此之外还有一个<code>FGameplayCueTag</code>的结构体，它对GameplayTag做了些制约(猜测是只有Parent是GameplayCue的Tag)，它会自动的过滤在Blueprint中仅显示GameplayCue为父节点的标签。</p>
<p>同理，如果想在函数里面过滤GameplayTag，使用<code>UFUNCTION()</code>的修饰符<code>Meta = (GameplayTagFilter = &quot;GameplayCue&quot;)</code>。但是GameplayTagContainer就不行了，想要它也适用则需要对引擎做些修改。</p>
<blockquote>
<p>If you would like to edit your engine to allow this, look at how <code>SGameplayTagGraphPin::ParseDefaultValueData()</code> from <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagGraphPin.cpp</code> calls <code>FilterString = UGameplayTagsManager::Get().GetCategoriesMetaFromField(PinStructType);</code> and passes <code>FilterString</code> to <code>SGameplayTagWidget</code> in <code>SGameplayTagGraphPin::GetListContent().</code> The <code>GameplayTagContainer</code> version of these functions in <code>Engine\Plugins\Editor\GameplayTagsEditor\Source\GameplayTagsEditor\Private\SGameplayTagContainerGraphPin.cpp</code> do not check for the meta field properties and pass along the filter.</p>
</blockquote>
<p>这涉及具体操作了我看太懂，直接复制过来了。</p>
<h4 id="GameplayTag有变动的函数回调"><a href="#GameplayTag有变动的函数回调" class="headerlink" title="GameplayTag有变动的函数回调"></a>GameplayTag有变动的函数回调</h4><p>ASC提供了GameplayTag的<strong>Add/Remove</strong>操作的Delegate，这个Delegate需要一个<code>EGameplayTagEventType</code>类型的参数，只有当GameplayTag由于Add/Remove等操作使得<code>GameplayTag&#39;s</code> <code>TagMapCount</code>的值被修改的时候，这个代理会被执行(fire)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;RegisterGameplayTagEvent(FGameplayTag::RequestGameplayTag(FName(<span class="string">"State.Debuff.Stun"</span>)), EGameplayTagEventType::NewOrRemove).AddUObject(<span class="keyword">this</span>, &amp;AGDPlayerState::StunTagChanged);</span><br></pre></td></tr></table></figure></p>
<p>回调函数有该GameplayTag和新的<code>TagCount</code>值作为参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StunTagChanged</span><span class="params">(<span class="keyword">const</span> FGameplayTag CallbackTag, int32 NewCount)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h3><h4 id="Attribute-定义"><a href="#Attribute-定义" class="headerlink" title="Attribute 定义"></a>Attribute 定义</h4><p><code>Attributes</code>是由<code>FGameplayAttributeData</code>结构体定义的<strong>float values</strong>。他可以表示游戏中的任何数值类的能力，像HP，MP，玩家等级之类的。游戏设计中如果<code>Actor</code>有什么数值相关的属性能力，都可以考虑用<code>Attributes</code>来实现。<br><br><code>Attributes</code>的修改一般情况下都应该由<code>GameplayEffects</code>来执行，这样方便ASC预测这些修改(predict the changes)。<br></p>
<p>关于GAS的一些预测(prodict)功能，也是很重要的内容，会在以后进行验证。<br><span style="color:blue">此处应该有FGameplayAttributeData结构体的源码截图。</span></p>
<p><code>Attributes</code>是由<code>AttributeSet</code>来定义和保持的，同时也负责着<code>Attributes</code>的Replication。</p>
<p><span style="color:blue">此处应该有AttributeSet的源码截图</span></p>
<p><strong>Tips</strong> :<br><br>可以使用<code>Meta = (HideInDetailsVies)</code>属性修饰符来隐藏<code>Attributes</code>,使其不会出现在UE4Editor的列表中。</p>
<h4 id="BaseValue-vs-CurrentValue"><a href="#BaseValue-vs-CurrentValue" class="headerlink" title="BaseValue vs CurrentValue"></a>BaseValue vs CurrentValue</h4><p>一个<code>Attribute</code>是由两个值组成的，<code>BaseValue</code>和<code>CurrentValue</code>。</p>
<ul>
<li><code>BaseValue</code> : 代表着Attribute永久变更的值(the permanent value)，相对于<code>CurrentValue</code>而言。</li>
<li><code>CurrentValue</code> : 代表着Attribute的<code>BaseValue</code>加上来自<code>GameplayEffect</code>的临时变更的值。</li>
</ul>
<p>举个栗子就是玩家的移动速度是1m/s，那么此时BaseValue和CurrentValue的值都是1m/s。但是当我们给玩家一个加速效果(GameplayEffect)，玩家的移动速度变成了1.1m/s，此时BaseValue是1m/s，而CurrentValue的值是(1+0.1=)1.1m/s。当加速效果结束，BaseValue和CurrentValue的值都回到了1m/s。</p>
<p>这里需要注意的是BaseValue经常会被误认为是Attribute的最大值，而我最开始确实是这样误解的，其实不是。某个属性的最大值比如说HP等，同样也是Attribute的一种，也是需要BaseValue和CurrentValue。</p>
<p>对于Attribute的最大值最小值进行硬编码的问题，UE4提供了一种<code>DataTable</code>，使用<code>FAttributeMetaData</code>来设置。但是据源码的评论内容来看这个Struct仍然是WIP状态。只有期待后续的更新了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* DataTable that allows us to define meta data about attributes. Still a work in progress.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">FAttributeMetaData</span> :</span> <span class="keyword">public</span> FTableRowBase</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_USTRUCT_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FAttributeMetaData();</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> BaseValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MinValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">float</span> MaxValue;</span><br><span class="line"></span><br><span class="line">    UPROPERTY()</span><br><span class="line">    FString DerivedAttributeInfo;</span><br><span class="line"></span><br><span class="line">    UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = <span class="string">"Gameplay Attribute"</span>)</span><br><span class="line">    <span class="keyword">bool</span> bCanStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>目前我并没有使用这个方法，而是将最大值和最小值也视为常规的Attribute来使用。</p>
<p>通常对于来自GameplayEffect的处理，会有Clamp之类的处理，而这类的处理，对于Attribute中的这两个值来说会被放在不同的地方：</p>
<ul>
<li><code>CurrentValue</code>的Clamp处理通常会在<code>PreAttributeChange()</code>函数里进行</li>
<li><code>BaseValue</code>的Clamp处理通常会在<code>PostGameplayEffectExecute()</code>函数里进行</li>
</ul>
<p>通常情况下，<code>Instant`</code>GameplayEffects<code>这种类型的GE被视为对Attribute的永久变更，会直接改变</code>BaseValue<code>的值，而</code>Duration<code>Infinite`类型的`GameplayEffects`则是一种暂时的状态会改变`CurrentValue`的值。`Periodic</code>GameplayEffects<code>类型像</code>Instant<code>一样会改变</code>BaseValue`的值。</p>
<h4 id="Meta-Attributes"><a href="#Meta-Attributes" class="headerlink" title="Meta Attributes"></a>Meta Attributes</h4><p>有一些Attributes可以被用来当做是占位符(placeholders)或者临时的变量，目的是与其他的Attributes做一些交互(interact)，我们称作这样的变量为<code>MetaAttribute</code>。最常见的就是<strong>Damage</strong>伤害变量，我们将Damage变量作为占位符变量存储伤害数值，而不是将其封装在GameplayEffect中，使用GE<strong>直接</strong>改变我们的生命值。</p>
<p>这种方式可以方便的将伤害值传给<code>GameplayEffectExecutionCalculation</code>，方便其进行一些Buff和Debuff的计算。而且还可以更方便在<code>AttributeSet</code>中进行操作。需要注意的是MetaAttributes在GameplayEffect之间没有持久性(persistence)，也就是可以被任何一方修改，或者说是重写(override)。<strong>一般MetaAttributes不会Replicated</strong>。</p>
<p>MetaAttributes为分离逻辑和数值的设计模式提供了良好的灵活性，但也不是必须要这么使用，取决于项目要求。</p>
<h4 id="Responding-to-Attribute-Changes"><a href="#Responding-to-Attribute-Changes" class="headerlink" title="Responding to Attribute Changes"></a>Responding to Attribute Changes</h4><p>监听Attributes的值的变化可以用来更新UI或者其他的gameplay。使用<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>函数，该函数会返回一个代理(delegate)，我们可以将想要执行的函数比如说更新UI，绑定到这个代理上。</p>
<p>这个代理提供了一个<code>FOnAttributeChangeData</code>参数，里面包含了<code>NewValue</code>和<code>OldValue</code>，还有<code>FGameplayEffectModCallbackData</code>参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(AttributeSetBase-&gt;GetHealthAttribute()).AddUObject(<span class="keyword">this</span>, $AGDPlayerState::HealthChanged);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HealthChanged</span><span class="params">(<span class="keyword">const</span> FOnAttributeChangeData&amp; Data)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p><code>FGameplayEffectModCallbackData</code>只能在Server端被设置。</p>
<p>目前关于这个struct的内容我还不太清楚。</p>
<p>在GASDocumentation的项目中，作者制作了一个<code>AsyncTask</code>，用来方便的定制Attribute的更新与UI的更新事件。由于制作很是巧妙，而且还有我不知道的用法在里面，就像复制粘贴过来。至于源文件的链接我也贴上。</p>
<ul>
<li><a href="https://github.com/tranek/GASDocumentation/blob/master/Source/GASDocumentation/Public/Characters/Abilities/AsyncTaskAttributeChanged.h" target="_blank" rel="noopener">GASDocumentation-AsyncTaskAttributeChanged.h</a><br><details><br><summary>点击展开代码</summary><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2020 Dan Kestranek.</span><br><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">#include &quot;CoreMinimal.h&quot;</span><br><span class="line">#include &quot;Kismet/BlueprintAsyncActionBase.h&quot;</span><br><span class="line">#include &quot;AbilitySystemComponent.h&quot;</span><br><span class="line">#include &quot;AsyncTaskAttributeChanged.generated.h&quot;</span><br><span class="line"></span><br><span class="line">DECLARE_DYNAMIC_MULTICAST_DELEGATE_ThreeParams(FOnAttributeChanged, FGameplayAttribute, Attribute, float, NewValue, float, OldValue);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Blueprint node to automatically register a listener for all attribute changes in an AbilitySystemComponent.</span><br><span class="line"> * Useful to use in UI.</span><br><span class="line"> */</span><br><span class="line">UCLASS(BlueprintType, meta=(ExposedAsyncProxy = AsyncTask))</span><br><span class="line">class GASDOCUMENTATION_API UAsyncTaskAttributeChanged : public UBlueprintAsyncActionBase</span><br><span class="line">&#123;</span><br><span class="line">        GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">        UPROPERTY(BlueprintAssignable)</span><br><span class="line">        FOnAttributeChanged OnAttributeChanged;</span><br><span class="line"></span><br><span class="line">        // Listens for an attribute changing.</span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;))</span><br><span class="line">        static UAsyncTaskAttributeChanged* ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute);</span><br><span class="line"></span><br><span class="line">        // Listens for an attribute changing.</span><br><span class="line">        // Version that takes in an array of Attributes. Check the Attribute output for which Attribute changed.</span><br><span class="line">        UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;))</span><br><span class="line">        static UAsyncTaskAttributeChanged* ListenForAttributesChange(UAbilitySystemComponent* AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes);</span><br><span class="line"></span><br><span class="line">        // You must call this function manually when you want the AsyncTask to end.</span><br><span class="line">        // For UMG Widgets, you would call it in the Widget&apos;s Destruct event.</span><br><span class="line">        UFUNCTION(BlueprintCallable)</span><br><span class="line">        void EndTask();</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">        UPROPERTY()</span><br><span class="line">        UAbilitySystemComponent* ASC;</span><br><span class="line"></span><br><span class="line">        FGameplayAttribute AttributeToListenFor;</span><br><span class="line">        TArray&lt;FGameplayAttribute&gt; AttributesToListenFor;</span><br><span class="line"></span><br><span class="line">        void AttributeChanged(const FOnAttributeChangeData&amp; Data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<ul>
<li><a href>GASDocumentation-AsyncTaskAttributeChanged.cpp</a><br><details><br><summary>点击展开代码</summary>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2020 Dan Kestranek.</span><br><span class="line">#include &quot;Characters/Abilities/AsyncTaskAttributeChanged.h&quot;</span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(UAbilitySystemComponent* AbilitySystemComponent, FGameplayAttribute Attribute)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributeToListenFor = Attribute;</span><br><span class="line"></span><br><span class="line">        if (!IsValid(AbilitySystemComponent) || !Attribute.IsValid())</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line"></span><br><span class="line">        return WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAsyncTaskAttributeChanged * UAsyncTaskAttributeChanged::ListenForAttributesChange(UAbilitySystemComponent * AbilitySystemComponent, TArray&lt;FGameplayAttribute&gt; Attributes)</span><br><span class="line">&#123;</span><br><span class="line">        UAsyncTaskAttributeChanged* WaitForAttributeChangedTask = NewObject&lt;UAsyncTaskAttributeChanged&gt;();</span><br><span class="line">        WaitForAttributeChangedTask-&gt;ASC = AbilitySystemComponent;</span><br><span class="line">        WaitForAttributeChangedTask-&gt;AttributesToListenFor = Attributes;</span><br><span class="line"></span><br><span class="line">        if (!IsValid(AbilitySystemComponent) || Attributes.Num() &lt; 1)</span><br><span class="line">        &#123;</span><br><span class="line">                WaitForAttributeChangedTask-&gt;RemoveFromRoot();</span><br><span class="line">                return nullptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (FGameplayAttribute Attribute : Attributes)</span><br><span class="line">        &#123;</span><br><span class="line">                AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).AddUObject(WaitForAttributeChangedTask, &amp;UAsyncTaskAttributeChanged::AttributeChanged);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return WaitForAttributeChangedTask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAsyncTaskAttributeChanged::EndTask()</span><br><span class="line">&#123;</span><br><span class="line">        if (IsValid(ASC))</span><br><span class="line">        &#123;</span><br><span class="line">                ASC-&gt;GetGameplayAttributeValueChangeDelegate(AttributeToListenFor).RemoveAll(this);</span><br><span class="line"></span><br><span class="line">                for (FGameplayAttribute Attribute : AttributesToListenFor)</span><br><span class="line">                &#123;</span><br><span class="line">                        ASC-&gt;GetGameplayAttributeValueChangeDelegate(Attribute).RemoveAll(this);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SetReadyToDestroy();</span><br><span class="line">        MarkPendingKill();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAsyncTaskAttributeChanged::AttributeChanged(const FOnAttributeChangeData &amp; Data)</span><br><span class="line">&#123;</span><br><span class="line">        OnAttributeChanged.Broadcast(Data.Attribute, Data.NewValue, Data.OldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ul>
<p></p>
<p>这段代码实现了两个函数<code>ListenForAttributeChange</code>和<code>ListenForAttributesChange</code>用来监视Attribute的值的变更，同时是基于<code>UBlueprintAsyncActionBase</code>扩展的类，也可以在BP中方便的使用这两个函数，主要是对于UI的操作来说，提供这样的函数会更加方便一些。</p>
<p><img src="ListenForAttributeChange.png" alt="AttributeChange"></p>
<h4 id="Derived-Attributes"><a href="#Derived-Attributes" class="headerlink" title="Derived Attributes"></a>Derived Attributes</h4><p>刚开始看的时候就觉得好高大上啊，派生属性好厉害，难不成是AttributeSet的派生类中的Attribute也能更新，但仔细想想这太厉害了也，而且不符合我学到的知识。</p>
<p>关于这个Attribute的派生的功能，其实是说比如当我们在<code>Infinite</code>类型的<code>GameplayEffect</code>中使用一个或更多个的<code>Attribute Based</code>和<code>MMC Modifiers</code>的时候，<code>Derived Attribute</code>会依据它所依赖的上述类型的变量的变化而更新自己的值。</p>
<blockquote>
<p>The <code>Derived Attribute</code> will update automatically when an <code>Attribute</code> that it depends on is updated.</p>
</blockquote>
<p>简单来理解就是当一个Attribute依赖于其他的Attribute的时候，这个Attribute就是一个<code>Derived Attribute</code>，而且其它的Attribute的值更新的时候，这个Attribute的值也会被更新。<br>文章中所举的例子就是：<code>TestAttrA = (TestAttrA + TestAttrB) * 2 * TestAttrC</code>这种计算中，<code>TestAttrA</code> <code>TestAttrB</code> <code>TestAttrC</code>中的任何一个值有更新，<code>TestAttrA</code>的值都会随之被更新。</p>
<p>至于这段内容还有没有额外的意思我不太确定，我只理解到了这一步。</p>
<blockquote>
<p>The final formula for all the <code>Modifiers</code> on a <code>Derived Attribute</code> is the same formula for <code>Modifier Aggregators</code>. If you need calculations to happen in a certain order, do it all inside of an <code>MMC</code>.</p>
</blockquote>
<p>关于<code>Modifier Aggregator</code>的内容我目前也不是很了解，大意应该就是，对于<code>Derived Attribtue</code>来说普通的<code>Modifier</code>计算公式顺序是和<code>Modifier Aggregator</code>是一样的，如果想要其按照某种顺序你想要的顺序来计算的话，就需要我们在<code>MMC</code>中完成这些事情。</p>
<blockquote>
<p><strong>Note:</strong> If playing with multiple clients in PIE, you need to disable <code>Run Under One Process</code> in the Editor <code>Preferences</code> otherwise the <code>Derived Attributes</code> will not update when their independent Attributes update on clients other than the first.</p>
</blockquote>
<p><strong>Note:</strong> 这段的意思我不是完全理解，大意应该就是在Editor的PIE模式下运行多个客户端的时候，记得把Editor的<code>Preference</code>中的<code>Run Under One Process</code>一项禁用掉，不然的话，除了第一个被运行的Client之外，其他Client上的<code>Dervied Attributes</code>尽管依赖的属性更新，其派生的Attribute的值也不会被更新。</p>
<h3 id="Attribute-Set"><a href="#Attribute-Set" class="headerlink" title="Attribute Set"></a>Attribute Set</h3><h4 id="Attribute-Set定义"><a href="#Attribute-Set定义" class="headerlink" title="Attribute Set定义"></a>Attribute Set定义</h4><p><code>Attributes</code>的变更是由 <code>AttributeSet</code>定义，维持和管理的。需要继承<code>UAttributeSet</code>类来实现。</p>
<p>在<code>OwnerActor</code>的构造函数中创建<code>AttributeSet</code>的话，会自动的登记到它的<code>ASC</code>上。这句话我很在意，也就是说在别处创建的话就需要手动登记<code>AttributeSet</code>到<code>ASC</code>上的意思？</p>
<p>这部分是只有在C++中才能实现的。</p>
<h4 id="如何设计AttributeSet"><a href="#如何设计AttributeSet" class="headerlink" title="如何设计AttributeSet"></a>如何设计AttributeSet</h4><p>一个<code>ASC</code>可以拥有一个或者多个<code>AttributeSet</code>。由于<code>AttributeSet</code>的内存开销极小，所以拥有多少个<code>Attribute</code>完全取决于开发者的意愿。</p>
<p>如何对<code>AttributeSet</code>进行分类管理也取决于开发者。</p>
<p><code>Attribute</code>在内部是以<code>AttributeSetClassName.AttributeName</code>这种方式来识别的。也就是说<code>Attribute</code>会拥有它们父类的名字作为自己名字的前缀。</p>
<p>我们可以拥有复数个<code>AttributeSet</code>，但是却不能让<code>ASC</code>拥有相同类的复数个<code>AttributeSet</code>。如果添加了同一个类的<code>AttributeSet</code>，它会不知道指的是哪一个。</p>
<p>↑上面这个我没有验证过。</p>
<p>这之后文章又举了几个例子来验证<code>AttributeSet</code>的实现和可行性。总结起来就是，使用<code>AttributeSet</code>的场景需要具体情况具体分析，不要过度迷信它的使用，有的时候有的场景，单纯的使用一个简单的<code>float</code>变量会更好的解决问题。</p>
<h5 id="运行时添加或移除AttributeSet"><a href="#运行时添加或移除AttributeSet" class="headerlink" title="运行时添加或移除AttributeSet"></a>运行时添加或移除AttributeSet</h5><p>添加：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASC-&gt;SpawnedAttributes.AddUnique(AttributeSetPointer);</span><br><span class="line">ASC-&gt;ForceReplication();</span><br></pre></td></tr></table></figure></p>
<p>移除：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASC-&gt;SpawnedAttributes.Remove(AttributeSetPointer);</span><br><span class="line">ASC-&gt;ForceReplication();</span><br></pre></td></tr></table></figure></p>
<p>由于移除操作是一个非常危险的操作，使用的时候需要斟酌。比如说Client移除之后，来自于Server的Replication操作会使游戏崩溃。</p>
<h5 id="使用float来替代AttributeSet"><a href="#使用float来替代AttributeSet" class="headerlink" title="使用float来替代AttributeSet"></a>使用float来替代AttributeSet</h5><p>这里我想记录的其实是<code>PreReplication</code>这个函数。</p>
<p>我们可以使用float来暂时代替<code>AttributeSet</code>，当然这只是一个我自己的想当然的说法，只是本应该用<code>AttributeSet</code>来表现的属性值，我们选择了用简单的<code>float</code>来实现。</p>
<p>这就导致了我们没有办法使用GE，也没办法预测（Prediction）。</p>
<p>所以就有了<code>PreReplication</code>函数的使用，我们需要对这个float做一些本地预测的处理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AGSWeapon::RreReplication(IRepChangedPropertyTracker&amp; ChangedPropertyTracker)</span><br><span class="line">&#123;</span><br><span class="line">    Super::PreReplication(ChangedPropertyTracker);</span><br><span class="line"></span><br><span class="line">    DOREPLIFETIME_ACTIVE_OVERRIDE(AGSWeapon, PrimaryClipAmmo, (IsValid(ASC)&amp;&amp;!ASC-&gt;HasMatchhingGameplayTag(WeaponIsFireTag)));</span><br><span class="line">    DOREPLIFETIME_ACTIVE_OVERRIDE(AGSWeapon, SecondaryClipAmmo, (IsValid(ASC)&amp;&amp;!ASC-&gt;HasMatchhingGameplayTag(WeaponIsFireTag)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的实现还是得去看这个项目的源码。</p>
<p>当我们把<code>AttributeSet</code>并不是放到ASC的<code>OwnerActor</code>上的时候，放在其他的<code>Actor</code>比如说<code>Weapon</code>的时候，在<code>Actor</code>的构造函数中对<code>AttributeSet</code>进行实例化操作可能会出现编译错误，我们只要把<code>AttributeSet</code>的实例化操作放到<code>BeginPlay()</code>中就好了。</p>
<p>↑上面的说法，当然我没有遇见过这个编译错误，毕竟我还没有验证过。</p>
<h4 id="Attributes定义"><a href="#Attributes定义" class="headerlink" title="Attributes定义"></a>Attributes定义</h4><p><code>Attribute</code>的定义只能在C++中进行，定义在<code>AttributeSet.h</code>头文件中。</p>
<p>推荐奖下面的宏添加到头文件中，这个宏会自动的帮我们生成<code>Attribute</code>的<code>Getter</code>和和<code>Setter</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses macros from AttributeSet.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \</span></span><br><span class="line">    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \</span><br><span class="line">    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)</span><br></pre></td></tr></table></figure></p>
<p>然后定义一个可以<code>Replicated</code>的<code>attribute</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPROPERTY(BlueprintReadOnly, Category = <span class="string">"Health"</span>, ReplicatedUsing = OnRep_Health)</span><br><span class="line">FGameplayAttributeData Health;</span><br><span class="line">ATTRIBUTE_ACCESSORS(UGDAttributeSetBase, Health)</span><br></pre></td></tr></table></figure></p>
<p>然后不要忘了声明实现上面要用到的<code>OnRep</code>函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION()</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnRep_Health</span><span class="params">(<span class="keyword">const</span> FGameplayAttributeData&amp; OldHealth)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在 .cpp 文件中对上面的复制函数实现的时候要添加一个<code>GAMEPLAYATTRIBUTE_REPNOTIFY</code>宏，GAS的<strong>prediction system</strong>需要使用到它。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDAttributeSetBase::OnRep_Health(<span class="keyword">const</span> FGameplayAttributeData&amp; OldHealth)</span><br><span class="line">&#123;</span><br><span class="line">    GAMEPLAYATTRIBUTE_REPNOTIFY(UGDAttributeSetBase, Health, OldHealth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后把复制的属性添加到<code>GetLifetimeReplicatedProps</code>中去。这些都是UE4中使用Actor的<em>Replication</em>的常规操作了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDAttributeSetBase::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Super::GetLifetimeReplicatedProps(OutLifetimeProps);</span><br><span class="line"></span><br><span class="line">    DOREPLIFETIME_CONDITION_NOTIFY(UGDAttributeSetBase, Health, COND_None, REPNOTIFY_Always);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>REPTNOTIFY_Always</code> tells the OnRep function to trigger if the local value is already equal to the value being repped down from the Server (due to prediction). By default it won’t trigger the OnRep function if the local value is the same as the value being repped down from the Server.REPTNOTIFY_Always tells the OnRep function to trigger if the local value is already equal to the value being repped down from the Server (due to prediction). By default it won’t trigger the OnRep function if the local value is the same as the value being repped down from the Server.</p>
</blockquote>
<p><code>REPNOTIFY_Always</code>会触发<code>OnRep</code>事件，不论来自Server的值是否与我们本地的值相等。而默认的话相等的情况下是不会触发该事件的。</p>
<p>如果是使用<code>Meta Attribute</code>的话，<code>OnRep</code>和<code>GetLifetimeReplicatedProps</code>都可以跳过。</p>
<h4 id="Attribute的初始化"><a href="#Attribute的初始化" class="headerlink" title="Attribute的初始化"></a>Attribute的初始化</h4><p>观察<code>·Attributes</code>的源码会找到多种初始化属性的方法。Epic官方推荐的是使用<code>Instant GameplayEffect</code>来执行初始化。</p>
<p>或者使用了上面的<code>ATTRIBUTE_ACCESSORS</code>宏的话就可以使用定义好的Setter函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InitHealth(float InitialValue) is an automatically generated function for an Attribute 'Health' defined with the `ATTRIBUTE_ACCESSORS` macro</span></span><br><span class="line">AttributeSet-&gt;InitHealth(<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: Prior to 4.24, FAttributeSetInitterDiscreteLevels did not work with FGameplayAttributeData. It was created when Attributes were raw floats and will complain about FGameplayAttributeData not being Plain Old Data (POD). This is fixed in 4.24 <a href="https://issues.unrealengine.com/issue/UE-76557.Note" target="_blank" rel="noopener">https://issues.unrealengine.com/issue/UE-76557.Note</a>: Prior to 4.24, FAttributeSetInitterDiscreteLevels did not work with FGameplayAttributeData. It was created when Attributes were raw floats and will complain about FGameplayAttributeData not being Plain Old Data (POD). This is fixed in 4.24 <a href="https://issues.unrealengine.com/issue/UE-76557" target="_blank" rel="noopener">https://issues.unrealengine.com/issue/UE-76557</a>.</p>
</blockquote>
<p>由于这个是之前版本的已修复的问题我就直接贴原文了。</p>
<p><strong>Tips</strong></p><br>我在GASDocumentation中看到，关于AttributeSet的初始化的问题。作者选择了Server和Client两侧都执行了初始化的操作。<p></p>
<details><br>    <summary><mark><font color="darked">初始化Attribute操作，点击展开代码</font></mark> </summary><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// GDCharacterBase.h</span><br><span class="line">// Initialize the Character&apos;s attributes. Must run on Server but we run it on Client too</span><br><span class="line">// so that we don&apos;t have to wait. The Server&apos;s replication to Client wont&apos;t matter since</span><br><span class="line">// the values should be the same.</span><br><span class="line">virtual void InitializeAttributes();</span><br><span class="line"></span><br><span class="line">// GDCharacterBase.cpp</span><br><span class="line">void AGDCharacterBase::InitializeAttributes()</span><br><span class="line">&#123;</span><br><span class="line">    if(!AbilitySystemComponent.IsValid()</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!DefaultAttributes)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Can run on Server and Client</span><br><span class="line">    FGameplayEffectContextHandle EffectContext = AbilitySystemComponent-&gt;MakeEffectContext();</span><br><span class="line">    EffectContext.AddSourceObject(this);</span><br><span class="line"></span><br><span class="line">    FGameplayEffectSpecHandle NewHandle = AbilitySystemComponent-&gt;MakeOutgoingSpec(DefaultAttributes, GetCharacterLevel(), EffectContext);</span><br><span class="line">    if(NewHandle.IsValid())</span><br><span class="line">    &#123;</span><br><span class="line">        FActiveGameplayEffectHandle ActiveGEHandle = AbilitySystemComponent-&gt;ApplyGameplayEffectSpecToTarget(*NewHandle.Data.Get(), AbilitySystemComponent.Get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<p><br></p>
<p>像上面这样在双方都进行了初始化，但是我自己实验了之后明显Client这边没有被成功的初始化，貌似GameplayEffect这边执行Apply的时候也会有一个Authority检查，就导致Client在上面的<code>ApplyGameplayEffectSpecToTarget</code>这一步返回的<code>ActiveGEHandle</code>是<code>-1</code>，也就是无效的Handle。(可能是跟ASC的ReplicationMode有关？我选的是MixMode)</p>
<p>看来真的想在Client端也进行初始化的话，还是用<code>Setter</code>,<code>Getter</code>函数比较靠谱。再就是直接使用Epic官方推荐的使用GE的方式。</p>
<h4 id="PreAttributeChange-函数"><a href="#PreAttributeChange-函数" class="headerlink" title="PreAttributeChange()函数"></a>PreAttributeChange()函数</h4><p><code>PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue)</code>这个函数会在<code>Attribute</code>的<code>CurrentValue</code>的值被改变之前调用，比如我们想要对新的<code>CurrentValue</code>的值进行<strong>Clamp</strong>处理的时候这个函数就是很好的地方。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetMoveSpeedAttribute()是之前的宏自动定义的Getter函数</span></span><br><span class="line"><span class="keyword">if</span> (Attribute == GetMoveSpeedAttribute())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Cannot slow less than 150 units/s and cannot boost more than 1000 units/s</span></span><br><span class="line">    NewValue = FMath::Clamp&lt;<span class="keyword">float</span>&gt;(NewValue, <span class="number">150</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是这个函数会在只要<code>Attributes</code>值有变动的时候就会被调用，不是仅限于<code>Attributes</code>的<code>Setter</code>函数被调用还是<code>GameplayEffect</code>被应用。</p>
<p><strong>Note</strong>：</p>
<ol>
<li>需要注意的是，在这个函数里发生的<strong>Clamp</strong>操作，在类似的<code>GameplayEffectExecutionCalculation</code>和<code>ModifierMagnitudeCalculation</code>之类的Modifier存在还需要再做一次Clamp处理。</li>
</ol>
<p>这里我也不是特别清楚，总之先把原文贴上：</p>
<blockquote>
<p> Any clamping that happens here does not permanently change the modifier on the ASC. It only changes the value returned from querying the modifier. This means anything that recalculates the CurrentValue from all of the modifiers like <code>GameplayEffectExecutionCalculations</code> and <code>ModifierMagnitudeCalculations</code> need to implement clamping again.</p>
</blockquote>
<ol start="2">
<li>正如上面说的只要<code>Atttributes</code>的值有变动这个函数就会被调用，Epic官方只推荐在这个函数中做一些对属性Clamp之类的处理，不要当做Attribute的OnChange的Callback来使用。UE4有好好提供正式的Callback函数：<code>UAbilitySystemComponent::GetGameplayAttributeValueChangeDelegate(FGameplayAttribute Attribute)</code>，参考上面。</li>
</ol>
<h4 id="PostGameplayEffectExecute-函数"><a href="#PostGameplayEffectExecute-函数" class="headerlink" title="PostGameplayEffectExecute()函数"></a>PostGameplayEffectExecute()函数</h4><p><code>PostGameplayEffectExecute(const FGameplayEffectModCallbackData &amp; Data)</code>函数仅会在<code>Instant GameplayEffect</code>改变了<code>Attribute</code>的<code>BaseValue</code>值之后被调用。</p>
<p>这是一个操控由<code>GameplayEffect</code>修改的<code>Attribute</code>的值的好地方。</p>
<p>GASDocumentation项目在这个函数里做了许多事情，比如说最终对HP的削减，处理HitReaction的动画事件，显示漂浮的伤害数字等等。</p>
<p>对于那些值跟<code>Instant GameplayEffect</code>相关的属性来说，是Clamp处理的好地方。</p>
<p><strong>Note</strong>：</p>
<p><code>PostGameplayEffectExecute()</code>函数被调用的时候，Attribute的值的修改已经发生了，但是还没有被Replicated到其他的客户端上的，所以在这个函数的Clamp操作不会导致两次Client的ValueUpdate。<strong>客户端只会收到Clamp操作更新之后的值</strong>。</p>
<h4 id="OnAtttributeAggregatorCreate-函数"><a href="#OnAtttributeAggregatorCreate-函数" class="headerlink" title="OnAtttributeAggregatorCreate()函数"></a>OnAtttributeAggregatorCreate()函数</h4><p><code>OnAttributeAggregatorCreated(const FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</code>函数会在一个AttributeSet中为Attribute创建了一个<code>Aggregator</code>的时候被调用。</p>
<p>它允许我们自定义<code>FAggregatorEvaluateMetaData</code>的设置。<code>AggregatorEvaluateMetaData</code>被用来对Attribute的<code>CurrentValue</code>基于<strong>Modifier</strong>进行评价的东西。(英文的这里有些晦涩难懂)比如说默认的情况下我们会使用<code>MostNegativeMod_AllPosositiveMods</code>的模式，表示对于Attribute的<code>CurrentValue</code>的<strong>Modifier</strong>操作来说，积极意义的操作(Positive)允许该<strong>Modifier</strong>对<code>CurrentValue</code>的值进行修改，但是对于消极意义的操作(Negative)就会加以限制，只允许其中最消极的一个<strong>Modifier</strong>对<code>CurrentValue</code>进行修改。</p>
<p>文章中举的栗子就是在同一时间对于玩家速度的所有的增益效果都会被保留并反映到数值上，但是对于所有的减益效果在同一时间只会把最消极的效果应用到玩家速度上反映到数值上。需要注意的是，此时这些减益效果的Effect仍然是存在ASC上的，它们只是最终没有被聚合反映到最终的<code>CurrentValue</code>上而已。</p>
<p>由于这段晦涩难懂，我害怕自己理解错误，以防万一贴上原文</p>
<details><br>    <summary>点击展开英文原文</summary><br>    &gt; <code>OnAttributeAggregatorCreated(const FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</code> triggers when an Aggregator is created for an Attribute in this set. It allows custom setup of <code>FAggregatorEvaluateMetaData</code>. <code>AggregatorEvaluateMetaData</code> is used by the Aggregator in evaluating the <code>CurrentValue</code> of an Attribute based on all the <code>Modifiers</code> applied to it. By default, <code>AggregatorEvaluateMetaData</code> is only used by the Aggregator to determine which Modifiers qualify with the example of <code>MostNegativeMod_AllPositiveMods</code> which allows all positive Modifiers but restricts negative Modifiers to only the most negative one. This was used by Paragon to only allow the most negative move speed slow effect to apply to a player regardless of how many slow effects where on them at any one time while applying all positive move speed buffs. Modifiers that don’t qualify still exist on the ASC, they just aren’t aggregated into the final CurrentValue. They can potentially qualify later once conditions change, like in the case if the most negative Modifier expires, the next most negative Modifier (if one exists) then qualifies.<br><br></details><br><br><br><br>项目中的代码就是演示这种效果:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAttributeAggregatorCreated</span><span class="params">(<span class="keyword">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator)</span> <span class="keyword">const</span> override</span>;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGSAttributeSetBase::OnAttributeAggregatorCreated(<span class="keyword">const</span> FGameplayAttribute&amp; Attribute, FAggregator* NewAggregator) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAttributeAggregatorCreated(Attribute, NewAggregator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NewAggregator)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Attribute == GetMoveSpeedAttribute())</span><br><span class="line">    &#123;</span><br><span class="line">        NewAggregator-&gt;EvaluationMetaData = &amp;FAggregatorEvaluateMetaDataLibrary::MostNegativeMod_AllPositiveMods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; Your custom AggregatorEvaluateMetaData for qualifiers should be added to FAggregatorEvaluateMetaDataLibrary as static variables.<br><br>自定义的<code>AggregatorEvaluateMeteData</code>貌似还需要一些额外的操作。<br><br><br>### Gameplay Efffects<br>关于GE的内容实在是太多了，没有办法完全整理，集中精力去整理这些的话又要花费好多时间，而且最近也没有太多时间整理，其它的想要整理的东西就完全赶不上日程。<br><br>由于目前并没有需要使用这一部分的知识，我也是大致的了解，等到下次有机会的时候再好好进行整理和验证。<br><br>#### GameplayEffect定义<br>之后更新。<br><br>### Gameplay Abilities<br>这一部分详细介绍GA的内容。<br><br>#### Gameplay Ability定义<br><code>GameplayAbility</code>(GA)概括的形容就是game中<code>Actor</code>可以做什么。动作也好，技能也好都可被称为是一个GA。这一部分是C++和BP都可以实现的。<br><br>当然这些都是理想情况，一些的Action的实现也是需要随机应变的，不要迷信<code>GameplayAbility</code>的的制作，感觉可以简单实现的操作就交给GA，自己的自定义的Action有的时候也是必不可少的。关于GA我也是有一些了解了，有一些简单的内容直接就跳过了。<br><br>&gt; <code>GameplayAbilities</code> run on the owning client and/or the server depending on the <code>Net Execution Policy</code> but not <code>simulated</code> proxies.<br><br>上面这句话很重要，也就是说GA事件的触发只会在<strong>Owning Client</strong>和Server上运行，在<code>Simulated Proxy</code>上接受不到事件的触发的，这种情况下想要在<code>Simulated Proxy</code>上根据需求实现一些数据同步是不太现实的，解决方案有两种，也是最通常的方法，第一个是使用RPCs，这个不是特别推荐的。第二种方法就是使用<code>Property Replication</code>，这个是推荐的而且是UE4中使用的。(参照ASC的Pawn的SkeletalMesh的Animation的同步实现。)<br><br>GA的<code>Net Execution Policy</code>决定了GA是否可以本地预测(locally predicted)。除此之外还有默认的可选的功能：cost和cooldown GameplayEffect。<br><br>GA使用<code>AbilityTask</code>来实现一些异步操作，在之后的部分会详细介绍。<br><br>&gt;<strong>Simulated clients will not run GameplayAbilities.</strong> Instead, when the server runs the ability, anything that visually needs to play on the simulated proxies (like animation montages) will be replicated or RPC’d through <code>AbilityTasks</code> or <code>GameplayCues</code> for cosmetic things like sounds and particles.<br><br>由于GA的工作流程我已经大致了解为了节省时间我就对一些经常使用的函数不做过多介绍。<br><br><code>GameplayAbility</code>的简单流程：<br><img src="abilityflowchartsimple.png" alt="abilityflowchartsimple"><br><br><code>GameplayAbility</code>的稍微复杂的流程：<br><img src="abilityflowchartcomplex.png" alt="abilityflowchartcomplex"><br><br>##### Replication Policy<br>一句话，不要使用这个选项。<br><br>完全不需要修改，将来有可能会移除。<br><br>&gt; Don’t use this option. The name is misleading and you don’t need it. GameplayAbilitySpecs are replicated from the server to the owning client by default. As mentioned above, GameplayAbilities don’t run on simulated proxies. They use AbilityTasks and GameplayCues to replicate or RPC visual changes to the simulated proxies. Dave Ratti from Epic has stated his desire to <a href="https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89" target="_blank" rel="noopener">remove this option in the future</a>.<br><br>##### Server Respects Remote Ability Cancellation<br>这个选项或多或少会造成一些麻烦。这个选项意思是当Client端的<code>GameplayAbility</code>执行结束(被取消或者顺利的执行完毕)的时候，是否会强制结束Server端的对应的正在执行的版本的运行。<br><br>通常情况下这个问题的来源是高延迟的玩家在进行游玩LocallyPredicted的<code>GameplayAbilities</code>的时候。但是<strong>一般情况下会禁用这个选项</strong>。<br><br>##### Replicate Input Directly<br>这个选项会把Client的Input输入的<strong>press</strong>和<strong>release</strong>事件Replicate到Server中去。<br><br>Epic不推荐使用这个选项，而是推荐使用另一种方法：如果我们把Input绑定到了ASC上，我们可以使用已经内置到<code>AbilityTask</code>中的input函数。<br><br>上面说的不是特别清楚，就是在使用了Ability的InputBind之后(把Ability的激活绑定到用户的输入上的方式)，使用AbilityTask中的有一个监听用户输入的Task，在这个项目的还是GASShooter项目的Fire部分有涉及到，我记不太清楚了，之后有时间应该会把那一部分的代码拿过来使用的。<br><br>&gt; Epic’s comment:<br>&gt;<br>&gt; /<strong> Direct Input state replication. These will be called if<br>&gt; bReplicateInputDirectly is true on the ability and is generally not a good<br>&gt;  thing to use. (Instead, prefer to use Generic Replicated Events). */<br>&gt;<br>&gt;  UAbilitySystemComponent::ServerSetInputPressed()，<br><br>#### 绑定输入到AbilitySystemComponent<br>ASC允许我们直接绑定用户输入到<code>GameplayAbilities</code>上，当我们绑定完毕之后检测到输入的ASC会自动帮我们激活被绑定对象的GA。被绑定的</strong>InputAction<strong>则是用到了内置的检测输入的</strong>AbilityTask<strong>。<br><br>被绑定的用户输入的动作，除了被用来激活GA，除此之外还提供了<code>Confirm</code> 和<code>Cancle</code>两种操作，这</strong>两种操作被AbilityTask用来对TargetActor进行一些操作<strong>。<br><br>为了能绑定输入到ASC上，我们首先需要制作一个枚举列表，用来把InputAction的名字转换为字节数据。枚举列表中变量的名字需要跟我们在ProjectSettings中的InputAction的变量名字保持一致。<br><br>枚举类型代码参考：<br><details><br>    <summary><mark><font color="darked">点击展开示例代码</font></mark></summary><br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EGDAbilityInputID</span> :</span> uint8</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0 None</span></span><br><span class="line">    None            UMETA(DisplayName = "None"),</span><br><span class="line">    <span class="comment">// 1 Confirm</span></span><br><span class="line">    Confirm         UMETA(DisplayName = "Confirm"),</span><br><span class="line">    <span class="comment">// 2 Cancel</span></span><br><span class="line">    Cancel          UMETA(DisplayName = "Cancel"),</span><br><span class="line">    <span class="comment">// 3 LMB</span></span><br><span class="line">    Ability1        UMETA(DisplayName = "Ability1"),</span><br><span class="line">    <span class="comment">// 4 RMB</span></span><br><span class="line">    Ability2        UMETA(DisplayName = "Ability2"),</span><br><span class="line">    <span class="comment">// 5 Q</span></span><br><span class="line">    Ability3        UMETA(DisplayName = "Ability3"),</span><br><span class="line">    <span class="comment">// 6 E</span></span><br><span class="line">    Ability4        UMETA(DisplayName = "Ability4"),</span><br><span class="line">    <span class="comment">// 7 R</span></span><br><span class="line">    Ability5        UMETA(DisplayName = "Ability5"),</span><br><span class="line">    <span class="comment">// 8 Sprint</span></span><br><span class="line">    Sprint          UMETA(DisplayName = "Sprint"),</span><br><span class="line">    <span class="comment">// 9 Jump</span></span><br><span class="line">    <span class="function">Jump            <span class="title">UMETA</span><span class="params">(DisplayName = <span class="string">"Jump"</span>)</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><br></details><br><br><br><br>如果是将ASC放到了</strong>Character<strong>上，那么<code>SetupPlayerInputComponent</code>函数是一个很好的进行ASC的InputAction绑定的地方。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind to AbilitySystemComponent</span></span><br><span class="line">AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(PlayerInputComponent, FGameplayAbilityInputBinds(FString(<span class="string">"ConfirmTarget"</span>), FString(<span class="string">"CancelTarget"</span>), FString(<span class="string">"EGDAbilityInputID"</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br></pre></td></tr></table></figure><br><br>如果ASC是被放到了</strong>PlayerState<strong>上，如果还是放到<code>SetupPlayerInputComponent</code>中的话就可能会发生一些问题，因为当这个函数被执行的时候，Client端的PlayerState可能还没有被复制Replicated。解决方案是除了<code>SetupPlayerInputComponent</code>这个函数之外，我们在<code>OnRep_PlayerState</code>函数中在做一次绑定，以保证绑定操作一定会被执行，当然需要我们额外添加一个布尔变量以保证我们不会二次绑定。

</strong>Note:**<br><br>在项目中可以观察到上面的输入绑定枚举列表中的<code>Confirm</code> 和<code>Cancel</code>并没有与ProjectSettings中<code>ConfirmTarget</code>和<code>CancelTarget</code>的名字相匹配，原因是我们在<code>BindAbilityActivationToInputComponent</code>函数的参数中对其进行了匹配，当然也可以让它们互相匹配。<br><br>当然这种情况下的绑定输入，一次用户的输入只会激活其绑定的一个GA，能否绑定多个GA这个问题我没有找到解答，因此对于扩展性还是有限制的。当然，这个功能的目的就是对标MOBA类游戏的技能的Slot。我们可以尝试其它的方式获取更多的自由度，比如说在Ability添加一个变量来控制等等。<br><br>至于其他的方式，如果这种特定的场景不适合的话，还是不采用这种输入绑定的方式为好。<br><br>##### 绑定输入到ASC但是不激活GA<br>如何在使用了上面的绑定输入的方法，在使用的过程中会有接收到用户输入之后但是不想激活GA的情况。我们可以在我们的GA中添加一个控制是否自动激活的变量<code>bActivateOnInput</code>，然后override<code>UAbilitySystemComponent::AbilityLocalInputPressed()</code>函数：<br><details><br>    <summary><mark><font color="darked">点击展开代码详细</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGSAbilitySystemComponent::AbilityLocalInputPressed(int32 InputID)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Consume the input if this InputID is overloaded with GenericConfirm/Cancel and the GenericConfim/Cancel callback is bound</span></span><br><span class="line">    <span class="keyword">if</span> (IsGenericConfirmInputBound(InputID))</span><br><span class="line">    &#123;</span><br><span class="line">        LocalInputConfirm();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsGenericCancelInputBound(InputID))</span><br><span class="line">    &#123;</span><br><span class="line">        LocalInputCancel();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    ABILITYLIST_SCOPE_LOCK();</span><br><span class="line">    <span class="keyword">for</span> (FGameplayAbilitySpec&amp; Spec : ActivatableAbilities.Items)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Spec.InputID == InputID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Spec.Ability)</span><br><span class="line">            &#123;</span><br><span class="line">                Spec.InputPressed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (Spec.IsActive())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Spec.Ability-&gt;bReplicateInputDirectly &amp;&amp; IsOwnerActorAuthoritative() == <span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        ServerSetInputPressed(Spec.Handle);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    AbilitySpecInputPressed(Spec);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Invoke the InputPressed event. This is not replicated here. If someone is listening, they may replicate the InputPressed event to the server.</span></span><br><span class="line">                    InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, Spec.Handle, Spec.ActivationInfo.GetActivationPredictionKey());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    UGSGameplayAbility* GA = Cast&lt;UGSGameplayAbility&gt;(Spec.Ability);</span><br><span class="line">                    <span class="keyword">if</span> (GA &amp;&amp; GA-&gt;bActivateOnInput)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// Ability is not active, so try to activate it</span></span><br><span class="line">                        TryActivateAbility(Spec.Handle);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details>

<h4 id="Granting-Abilitie"><a href="#Granting-Abilitie" class="headerlink" title="Granting Abilitie"></a>Granting Abilitie</h4><p>生成GA其实就是把GA的实例Instance放入到GAS的<code>ActivatableAbilities</code>列表中，在这个列表中的GA实例都是可以被激活的，在遇到需要的<strong>GameplayTags</strong> 或者满足其它条件之后就会被激活。</p>
<p>我们应当只在Server进行<strong>GameplayAbilities Granting</strong>，它们(确切来说是<code>GaameplayAbilitySpec</code>)会被自动的复制到它们的<strong>OwningClient</strong>中去。其他的<code>SimulatedProxy</code>不会收到对应的复制，所以说GA不会在<code>SimulatedProxy</code>上执行。</p>
<p>生成Abilities的示例代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AGDCharacterBase::AddCharacterAbilities()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Grant abilities, but only on the server  </span></span><br><span class="line">    <span class="keyword">if</span> (Role != ROLE_Authority || !AbilitySystemComponent.IsValid() || AbilitySystemComponent-&gt;CharacterAbilitiesGiven)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (TSubclassOf&lt;UGDGameplayAbility&gt;&amp; StartupAbility : CharacterAbilities)</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;GiveAbility(</span><br><span class="line">            FGameplayAbilitySpec(StartupAbility, GetAbilityLevel(StartupAbility.GetDefaultObject()-&gt;AbilityID), <span class="keyword">static_cast</span>&lt;int32&gt;(StartupAbility.GetDefaultObject()-&gt;AbilityInputID), <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbilitySystemComponent-&gt;CharacterAbilitiesGiven = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就生成了可以被激活的GAs，这里面的关键的类和变量：<code>GameplayAbilitySpec</code>, <code>UGameplayAbility</code>, <code>SourceObject</code>。</p>
<h4 id="Activating-Abilities-激活"><a href="#Activating-Abilities-激活" class="headerlink" title="Activating Abilities 激活"></a>Activating Abilities 激活</h4><p>如果上面那样对ASC的输入进行了绑定，那么InputAction就会帮我们激活GA。除此之外我们还有其它四种方式来<strong>Activate Abilities</strong>，可以挑选适合自己的方式。</p>
<ul>
<li>通过<code>GameplayTag</code></li>
<li>通过<code>GameplayAbility</code>class类</li>
<li>通过<code>FGameplayAbilitySpec</code> Handle</li>
<li>通过<code>Event</code>事件来激活，这种方式还允许传递其它的自定义参数(payload)</li>
</ul>
<p><details><br>    <summary><mark><font color="darked">点击展开示例代码</font></mark></summary><br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"Abilities"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilitiesByTag</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"Abilities"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbilityByClass</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; InAbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TryActivateAbility</span><span class="params">(FGameplayAbilitySpecHandle AbilityToActivate, <span class="keyword">bool</span> bAllowRemoteActivation = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TriggerAbilityFromGameplayEvent</span><span class="params">(FGameplayAbilitySpecHandle AbilityToTrigger, FGameplayAbilityActorInfo* ActorInfo, FGameplayTag Tag, <span class="keyword">const</span> FGameplayEventData* Payload, UAbilitySystemComponent&amp; Component)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FGameplayAbilitySpecHandle <span class="title">GiveAbilityAndActivateOnce</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpec&amp; AbilitySpec)</span></span>;</span><br></pre></td></tr></table></figure></details></p>
<p><br><br></p>
<p>这里需要注意的是使用Event来激活Abilities的时候，需要我们设置好<code>GameplayAbility</code>的<code>Trigger</code>。指定一个<code>GameplayTag</code>，切换成<code>GameplayEvent</code>项目，想要调用事件的时候使用<code>UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(AActor* Actor, FGameplayTag EventTag, FGameplayEventData Payload)</code>，从参数中可以观察到，使用这种方式激活Ability允许我们传递一个<strong>Payload Data</strong>。</p>
<p>这里应该有GA的Trigger情报的照片。</p>
<p>从图片中应该可以简单的观察到，<code>GameplayTag</code>的<strong>Add/Remove</strong>操作可以用来触发GA的激活。</p>
<p><strong>Note:</strong></p>
<p>当我们在Blueprint中使用<code>GameplayAbility</code>的时候，当我们想使用Event的方式对这个BPGameplayAbility进行Activate的时候，我们需要用<code>ActivateAbilityFromEvent</code>节点来替代默认的标准的<code>ActivateAbility</code>节点，而且还需要保证与<code>ActivateAbility</code>同时存在。如果同时存在的话，会总是调用<code>ActivateAbilityFromEvent</code>节点。</p>
<p>不要忘了在GA的逻辑执行完之后调用<code>EndAbility()</code>。除非是把这个Ability作为被动技能。但是即使如此在生命周期结束前调用一下还是稳妥一些。</p>
<p>对于<strong>Locally Predicted</strong>的<code>GameplayAbility</code>来说，大概的执行流程：</p>
<p>Activation sequence for locally predicted GameplayAbilities:</p>
<ol>
<li>Owning client calls TryActivateAbility()</li>
<li>Calls InternalTryActivateAbility()</li>
<li>Calls CanActivateAbility() and returns whether GameplayTag requirements are met, if the ASC can afford the cost, if the GameplayAbility is not on cooldown, and if no other instances are currently active</li>
<li>Calls CallServerTryActivateAbility() and passes it the Prediction Key that it generates</li>
<li>Calls CallActivateAbility()</li>
<li>Calls PreActivate() Epic refers to this as “boilerplate init stuff”</li>
<li>Calls ActivateAbility() finally activating the ability</li>
</ol>
<p>Server receives CallServerTryActivateAbility()</p>
<ol>
<li>Calls ServerTryActivateAbility()</li>
<li>Calls InternalServerTryActivateAbility()</li>
<li>Calls InternalTryActivateAbility()</li>
<li>Calls CanActivateAbility() and returns whether GameplayTag requirements are met, if the ASC can afford the cost, if the GameplayAbility is not on cooldown, and if no other instances are currently active</li>
<li>Calls ClientActivateAbilitySucceed() if successful telling it to update its ActivationInfo that its activation was confirmed by the server and broadcasting the OnConfirmDelegate delegate. This is not the same as input confirmation.</li>
<li>Calls CallActivateAbility()</li>
<li>Calls PreActivate() Epic refers to this as “boilerplate init stuff”</li>
<li>Calls ActivateAbility() finally activating the ability</li>
</ol>
<p>如果Server端的GA激活失败，会调用<code>ClientActivateAbilityFailed</code>，立马中断Client的GA的执行，并且回滚任何预测的变更。</p>
<h5 id="Passive-Abilities被动"><a href="#Passive-Abilities被动" class="headerlink" title="Passive Abilities被动"></a>Passive Abilities被动</h5><p>对于如何使用GA来实现被动的效果，我们可以在<code>UGameplayAbility::OnAvatarSet()</code>函数中实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo * ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec &amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAvatarSet(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ActivateAbilityOnGranted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;TryActivateAbility(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种<strong>PassiveAbilities</strong>的<code>NetExecutionPolicy</code>通常是<strong>Server Only</strong>的。</p>
<p>Epic的评论形容<code>OnAvatarSet()</code>这个函数就类似于<code>BeginPlay()</code>。</p>
<h4 id="Canceling-Abilities取消"><a href="#Canceling-Abilities取消" class="headerlink" title="Canceling Abilities取消"></a>Canceling Abilities取消</h4><p>取消GA的执行我们可以调用<code>CancelAbility()</code>函数，这个函数会调用<code>EndAbility()</code>函数并把它的<code>WasCancelled</code>参数设置为True。</p>
<p>关于取消GA的执行，大概提供的函数(这些函数在哪个类中需要调查)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cancels the specified ability CDO. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbility</span><span class="params">(UGameplayAbility* Ability)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels the ability indicated by passed in spec handle. If handle is not found among reactivated abilities nothing happens. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilityHandle</span><span class="params">(<span class="keyword">const</span> FGameplayAbilitySpecHandle&amp; AbilityHandle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancel all abilities with the specified tags. Will not cancel the Ignore instance */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAbilities</span><span class="params">(<span class="keyword">const</span> FGameplayTagContainer* WithTags=<span class="literal">nullptr</span>, <span class="keyword">const</span> FGameplayTagContainer* WithoutTags=<span class="literal">nullptr</span>, UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities regardless of tags. Will not cancel the ignore instance */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CancelAllAbilities</span><span class="params">(UGameplayAbility* Ignore=<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cancels all abilities and kills any remaining instanced abilities */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DestroyActiveState</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>Note：</strong></p>
<blockquote>
<p>I have found that CancelAllAbilities doesn’t seem to work right if you have a Non-Instanced GameplayAbilities. It seems to hit the Non-Instanced GameplayAbility and give up. CancelAbilities can handle Non-Instanced GameplayAbilities better and that is what the Sample Project uses (Jump is a non-instanced GameplayAbility). Your mileage may vary.</p>
</blockquote>
<p>关于上面的内容由于我对<strong>Non-Instanced GameplayAbility</strong>并没有涉猎，就先粘原文了。</p>
<h4 id="获取Active-Ability"><a href="#获取Active-Ability" class="headerlink" title="获取Active Ability"></a>获取Active Ability</h4><p>关于如何在运行时获取已被激活的GA，首先我们可能会需要先获取到所有的ASC上的GAs。</p>
<p>使用<code>UAbilitySystemComponent::GetActivatableAbilities()</code>函数会返回一个<code>TArray&lt;FGameplayAbilitySpec&gt;</code>类型的列表，就是我们想要的所有的GA。</p>
<p>除此之外还有一种方法就是利用<code>GameplayTagContainer</code>，也就是<code>GameplayTags</code>来筛选我们想要的GA。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UAbilitySystemComponent::GetActivatableGameplayAbilitySpecsByAllMatchingTags(<span class="keyword">const</span> FGameplayTagContainer&amp; GameplayTagContainer, TArray &lt; struct FGameplayAbilitySpec* &gt;&amp; MatchingGameplayAbilities, <span class="keyword">bool</span> bOnlyAbilitiesThatSatisfyTagRequirements = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p>
<p>想要知道具体怎么使用的话直接找源码会比较快。</p>
<p>在取到所有的GA之后，通过<code>IsActive()</code>函数来查看该GA是否已被激活。这里要注意的是<code>IsActive</code>中的并不是一个布尔值而是int值。</p>
<h4 id="Instancing-Policy"><a href="#Instancing-Policy" class="headerlink" title="Instancing Policy"></a>Instancing Policy</h4><p>GA的这个选项决定了GA被激活时的实例化操作有什么区别。<br><img src="InstancingPolicy.png" alt="InstancingPolicy"></p>
<h4 id="Net-Execution-Policy"><a href="#Net-Execution-Policy" class="headerlink" title="Net Execution Policy"></a>Net Execution Policy</h4><p>这个项目决定了GA由谁执行和执行顺序。<br><img src="NetExecutionPolicy.png" alt="NetExecutionPolicy"></p>
<h4 id="Ability-Tags"><a href="#Ability-Tags" class="headerlink" title="Ability Tags"></a>Ability Tags</h4><p>GA的内部也有内置的<code>GameplayTagContainer</code>，嘛，GA也可以对<code>GameplayTags</code>进行操作和存储就大致猜到了。虽然跟ASC一样有内置的<code>GameplayTagContainer</code>但是这里的<code>GameplayTags</code>都不会被<strong>Replicated</strong>。<br><img src="AbilityTags1.png" alt="AbilityTag01"><br><img src="AbilityTags2.png" alt="AbilityTag02"></p>
<h4 id="Gameplay-Ability-Spec"><a href="#Gameplay-Ability-Spec" class="headerlink" title="Gameplay Ability Spec"></a>Gameplay Ability Spec</h4><p>当GA被生成的时候，<code>GameplayAbilitySpec</code>便会被实例化，用来收集GA之外的情报，与其说是生成GA，本质上就是生成这个<code>GameplayAbilitySpec</code>。关于这个结构体的情报</p>
<p>这里应该有<code>GameplayAbilitySpec</code>的源码截图。</p>
<p>当一个GA在Server被生成(grant)，这个<code>GameplayAbilitySpec</code>会被生成，Server会将<code>GameplayAbilitySpec</code>复制到Replicate到<strong>OwningClient</strong>上。</p>
<p>根据<code>GameplayAbility</code>的<code>InstancingPolicy</code>，<code>GameplayAbilitySpec</code>会为其生成相应的实例或者不生成实例(Non-Instanced GA)。。</p>
<h4 id="向Ability中传递数据"><a href="#向Ability中传递数据" class="headerlink" title="向Ability中传递数据"></a>向Ability中传递数据</h4><p>Ability的使用流程一般为<code>Activate-&gt;Generate Data-&gt;Apply-&gt;End</code>，有的时候Ability的内部逻辑实现需要外部的数据，这个时候如何向Ability中传递数据就是一个问题。</p>
<p>而除了上面我们提到过的使用Event方式激活Ability可以传递<strong>Payload</strong>之外，还有其他的方法。</p>
<p><img src="PassDataToAbility.PNG" alt="PassingDataToAbilities"></p>
<p>用的时候再理解我就不翻译了。</p>
<h4 id="Ability-Cost-and-Cooldown"><a href="#Ability-Cost-and-Cooldown" class="headerlink" title="Ability Cost and Cooldown"></a>Ability Cost and Cooldown</h4><p><code>Instant GameplayEffect</code> (<code>Cost GE</code>)和<code>Duration GameplayEffect</code>(<code>Cooldown GE</code>)，是已经内置到GA中的两种GE。顾名思义。</p>
<blockquote>
<p>Before a <code>GameplayAbility</code> calls <code>UGameplayAbility::Activate()</code>, it calls <code>UGameplayAbility::CanActivateAbility()</code>. This function checks if the owning ASC can afford the cost (<code>UGameplayAbility::CheckCost()</code>) and ensures that the <code>GameplayAbility</code> is not on cooldown (<code>UGameplayAbility::CheckCooldown()</code>).</p>
<p>After a <code>GameplayAbility</code> calls <code>Activate()</code>, it can optionally commit the cost and cooldown at any time using <code>UGameplayAbility::CommitAbility()</code> which calls <code>UGameplayAbility::CommitCost()</code> and <code>UGameplayAbility::CommitCooldown()</code>.</p>
</blockquote>
<p>关于具体实现参考GE章节。</p>
<h4 id="Ability-Sets"><a href="#Ability-Sets" class="headerlink" title="Ability Sets"></a>Ability Sets</h4><p><code>GameplayAbilitySets</code>是一个很方便的<code>UDataAsset</code>类去放置GA。</p>
<p>我没有见过这个类啊……有兴趣的话可以搜一下，不是必须要使用的类。</p>
<h4 id="Ability-Batching"><a href="#Ability-Batching" class="headerlink" title="Ability Batching"></a>Ability Batching</h4><p>一个普通的GA的生命周期在<code>Server-Client</code>之间都会产生<strong>2-3个RPCs</strong>的调用。</p>
<ol>
<li><code>CallServerTryActivateAbility()</code></li>
<li><code>ServerSetReplicatedTargetData()</code> (Optional)</li>
<li><code>ServerEndAbility()</code></li>
</ol>
<p>根据情况有的时候我们可以将这些RPCs打包至两个甚至一个RPCs中去。这就是GAS中的<code>Ability Batching</code>技术。</p>
<p>在GASShooter项目中这个技术有用到。由于我并没有用到，即使是现在想要完全把文章内容理解应该也只是表面功夫。等到真正需要使用的时候再整理，或者有时间去验证的时候再进行整理。</p>
<h4 id="Net-Security-Policy"><a href="#Net-Security-Policy" class="headerlink" title="Net Security Policy"></a>Net Security Policy</h4><p>GA的的这个选项，决定了一个Ability可以在哪个Network上执行，它可以限制一些CGA在Client上执行。<br><img src="NetSecurityPolicy.PNG" alt="NetSecurityPolicy"></p>
<h3 id="Ability-Task"><a href="#Ability-Task" class="headerlink" title="Ability Task"></a>Ability Task</h3><h4 id="Ability-Task定义"><a href="#Ability-Task定义" class="headerlink" title="Ability Task定义"></a>Ability Task定义</h4><h3 id="Gameplay-Cues"><a href="#Gameplay-Cues" class="headerlink" title="Gameplay Cues"></a>Gameplay Cues</h3><h4 id="Gameplay-Cues定义"><a href="#Gameplay-Cues定义" class="headerlink" title="Gameplay Cues定义"></a>Gameplay Cues定义</h4><h3 id="AbilitySystemGlobals"><a href="#AbilitySystemGlobals" class="headerlink" title="AbilitySystemGlobals"></a>AbilitySystemGlobals</h3><p><code>AbilitySystemGlobals</code>类保持着GAS的所有的全局信息。大多数的变量的值可以直接在<code>DefaultGame.ini</code>中进行修改。一般情况下不需要用到这个类，但是需要意识到它的存在。当需要对<code>GameplayCueManager</code>或者<code>GameplayEffectContext</code>之类的类进行继承自定义的时候，就需要这个类来做一些设定了(具体什么设定我还不清楚)。</p>
<blockquote>
<p>To subclass AbilitySystemGlobals, set the class name in the DefaultGame.ini:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [/Script/GameplayAbilities.AbilitySystemGlobals]</span><br><span class="line">&gt; AbilitySystemGlobalsClassName=<span class="string">"/Script/ParagonAssets.PAAbilitySystemGlobals"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="InitGlobalData"><a href="#InitGlobalData" class="headerlink" title="InitGlobalData()"></a>InitGlobalData()</h4><h3 id="Prediction"><a href="#Prediction" class="headerlink" title="Prediction"></a>Prediction</h3><h3 id="Targeting"><a href="#Targeting" class="headerlink" title="Targeting"></a>Targeting</h3><h4 id="Target-Data"><a href="#Target-Data" class="headerlink" title="Target Data"></a>Target Data</h4><h3 id="GAS小结"><a href="#GAS小结" class="headerlink" title="GAS小结"></a>GAS小结</h3><p>这一部分内容实在是太多，我也不想找借口，主要是时间有限，如果一直保持整理这篇文章会耗费大量时间而妨碍了其它新的东西，时常接受新的知识并进行总结也是非常重要的。</p>
<p>除了整理好的这部分内容之外还有许多我没办法一一整理，但是如果未来有机会再深入了解和使用GAS的话再这个基础上进一步的进行整理吧。</p>
<p>总之我对GAS整体上有了大概的了解，也不是之前的满头雾水，也算是一种安慰吧。</p>
<h2 id="GameplayAbilitySystem中重要的类，结构体"><a href="#GameplayAbilitySystem中重要的类，结构体" class="headerlink" title="GameplayAbilitySystem中重要的类，结构体"></a>GameplayAbilitySystem中重要的类，结构体</h2><h3 id="GameplayAbilitySpec"><a href="#GameplayAbilitySpec" class="headerlink" title="GameplayAbilitySpec"></a>GameplayAbilitySpec</h3><p>暂时先放到这里之后整理</p>
<p>我遇到了一个问题就是FGameplayAbilitySpec的SourceObject并不会replicated的问题，所以别想着在GA中尝试使用通用的SourceObject了，在Server和Client之间。</p>
<h3 id="GameplayEffect"><a href="#GameplayEffect" class="headerlink" title="GameplayEffect"></a>GameplayEffect</h3><h4 id="FGameplayEffectContext"><a href="#FGameplayEffectContext" class="headerlink" title="FGameplayEffectContext"></a>FGameplayEffectContext</h4><h4 id="FGameplayEffectContextHandle"><a href="#FGameplayEffectContextHandle" class="headerlink" title="FGameplayEffectContextHandle"></a>FGameplayEffectContextHandle</h4><h3 id="InputBind"><a href="#InputBind" class="headerlink" title="InputBind"></a>InputBind</h3><p>使用GAS的功能可以直接绑定Ability的激活到输入里，我暂时先把这个写下来之后整合到上面的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.h</span></span><br><span class="line">    <span class="comment">// Called from both SetupPlayerInputComponent and OnRep_PlayerState because of a potential race condition where the PlayerController might</span></span><br><span class="line">    <span class="comment">// call ClientRestart which calls SetupPlayerInputComponent before the PlayerState is repped to the client so the PlayerState would be null in SetupPlayerInputComponent.</span></span><br><span class="line">    <span class="comment">// Conversely, the PlayerState might be repped before the PlayerController calls ClientRestart so the Actor's InputComponent would be null in OnRep_PlayerState.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BindASCInput</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyCharacter.cpp</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::BindASCInput()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ASCInputBound &amp;&amp; AbilitySystemComponent.IsValid() &amp;&amp; IsValid(InputComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        AbilitySystemComponent-&gt;BindAbilityActivationToInputComponent(InputComponent, FGameplayAbilityInputBinds(FString(<span class="string">"ConfirmTarget"</span>),</span><br><span class="line">        FString(<span class="string">"CancelTarget"</span>), FString(<span class="string">"EGDAbilityInputID"</span>), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Confirm), <span class="keyword">static_cast</span>&lt;int32&gt;(EGDAbilityInputID::Cancel)));</span><br><span class="line"></span><br><span class="line">        ASCInputBound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一些小的知识点"><a href="#一些小的知识点" class="headerlink" title="一些小的知识点"></a>一些小的知识点</h2><p>这里插播几个小知识点，在C++中添加了BlueprintCallable的函数的时候，直接编译之后保持Editor的开启状态可能会不出现，在Blueprint的编辑界面还是找不到这个函数，此时需要重启UE4的Editor。</p>
<p>还有一个就是在Blueprint中调用Parent节点的内容时，需要右键该节点找到<strong>add call to parent function</strong>。</p>
<h3 id="OnAvatarSet"><a href="#OnAvatarSet" class="headerlink" title="OnAvatarSet"></a>OnAvatarSet</h3><p>GameplayAbility.h<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UCLASS(Blueprintable)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GAMEPLAYABILITIES_API</span> <span class="title">UGameplayAbility</span> :</span> <span class="keyword">public</span> UObject, <span class="keyword">public</span> IGameplayTaskOwnerInterface</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Called when the avatar actor is set/changes */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Projects may want to initiate passives or do other "BeginPlay" type of logic here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是GameplayAbility自身所有的一个函数，在想要使用的时候需要对其重写。就像是对Actor的BeginPlay函数一样，对GameplayAbility来说就是OnAvatarSet函数。</p>
<p>按照这篇文章的做法就是将被动属性的GameplayAbility的激活放在了一开始，就是这个函数里面。</p>
<p>GASDocumentation/GDGameplayAbility<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GASDOCUMENTATION_API</span> <span class="title">UGDGameplayAbility</span> :</span> <span class="keyword">public</span> UGameplayAbility</span><br><span class="line">&#123;</span><br><span class="line">    GENERATED_BODY()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// If an ability is marked as ‘'ActivateAbilityOnGranted', activate them immediately when given here</span></span><br><span class="line">    <span class="comment">// Epic's comment: Projects may want to initiate passives or do other "BeginPlay" type of logic here.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnAvatarSet</span><span class="params">(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span> override</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GASDocumentation/GDGameplayAbility.cpp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UGDGameplayAbility::OnAvatarSet(<span class="keyword">const</span> FGameplayAbilityActorInfo* ActorInfo, <span class="keyword">const</span> FGameplayAbilitySpec&amp; Spec)</span><br><span class="line">&#123;</span><br><span class="line">    Super::OnAvatarSet(ActorInfo, Spec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ActivateAbilityOnGranted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ActivatedAbility = ActorInfo-&gt;AbilitySystemComponent-&gt;TryActivateAbility(Spec.Handle, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>bAllowRemoteActivation</code>标志位被设置为false，这样设置的理由我目前还没有完全搞清楚。</p>
<p>以上就是<code>OnAvatarSet</code>函数的使用理由和方法了。</p>
<h3 id="WaitDelay"><a href="#WaitDelay" class="headerlink" title="WaitDelay"></a>WaitDelay</h3><p>这次我遇到的是一个<strong>WaitDelay</strong>的BlueprintNode，这里需要注意的是要与另外一个BPNode<strong>TaskWaitDelay</strong>区分开来。</p>
<p><img src="WaitDelay.png" alt="WaitDelay"><br><img src="TaskWaitDelay.png" alt="TaskWaitDelay"></p>
<p>区别是一个是面向GameplayTask的一个是面向AbilityTask的。目前只对WaitDelay即AbilityTask的内容进行理解。</p>
<h1 id="从零开始搭建一个GAS工程"><a href="#从零开始搭建一个GAS工程" class="headerlink" title="从零开始搭建一个GAS工程"></a>从零开始搭建一个GAS工程</h1><p>这部分更新于我开始阅读并理解上面的<a href="https://github.com/tranek/GASDocumentation" target="_blank" rel="noopener">GASDocumentation</a>的三个月后，没错，我用了超过3个月的时间进行<strong>GameplayAbilitySystem</strong>的学习。甚至还只是局限于读懂而已。</p>
<p>这之间涉及了太多的UE4的框架部分的知识，我先在我构建这样一个工程的同时，同时记录下我遇见的疑难知识点，算是自我的提升和加深记忆了。</p>
<p>当然主要的还是对上面的那篇文章的实践和翻译。</p>
<h2 id="创建一个空白的项目，准备导入GAS"><a href="#创建一个空白的项目，准备导入GAS" class="headerlink" title="创建一个空白的项目，准备导入GAS"></a>创建一个空白的项目，准备导入GAS</h2><p>就如标题所说，我们创建一个空白的项目，但是在导入GAS之前我们要把框架搭好。关于UE4的MultiPlay框架在别的文章有涉及。</p>
<p>要决定好一些我之后可能要修改的配置，尽可能的创造一些基类，为扩展做一些铺垫。倒也不是尽可能的，看情况吧。</p>
<h3 id="GameMode"><a href="#GameMode" class="headerlink" title="GameMode"></a>GameMode</h3><p>首先我们要决定我们的<strong>GameMode</strong>，这里要对游戏一开始的内容做一些初始的处理，包含一些登录操作什么的，之后再展开。</p>
<p>在继承了<code>AGameModeBase</code>得到了自己的GameMode之后，新建一个blueprint继承这个GameMode，主要是为了方便在Editor上切换GamMode相关的设定。</p>
<p>在Editor主界面找到<strong>Blueprint -&gt; WorldOverride</strong> 指定我们准备好的BP_GameMode，就可以了。</p>
<h3 id="Pawn"><a href="#Pawn" class="headerlink" title="Pawn"></a>Pawn</h3><p>至于顺序，看心情吧没有非要这样的顺序。下一个是开始我们的Pawn的制作，世界做好了得让人物动起来，也就是我们需要一个或者一些Character。</p>
<blockquote>
<p>Characters are Pawns that have a mesh, collision, and built-in movement logic.</p>
</blockquote>
<p>选自<code>ACharacter</code>类的注释，直接使用APawn也可以，是勇士了。</p>
<p>ACharacter有一个内置的SkeletalMeshComponent，还有一些关于移动的逻辑。</p>
<p>说到关于移动的逻辑那就只有<strong>CharacterMovementComponent</strong>了，但是我在<code>Character.cpp</code>中看到了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ACharacter::ACharacter(<span class="keyword">const</span> FObjectInitializer&amp; ObjectInitializer)</span><br><span class="line">: Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    CharacterMovement = CreateDefaultSubobject&lt;UCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName);</span><br><span class="line">    <span class="keyword">if</span> (CharacterMovement)</span><br><span class="line">    &#123;</span><br><span class="line">        CharacterMovement-&gt;UpdatedComponent = CapsuleComponent;</span><br><span class="line">        CrouchedEyeHeight = CharacterMovement-&gt;CrouchedHalfHeight * <span class="number">0.80f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么看都是只要继承了Character这个类的话都会有一个<code>UCharacterMovementComponent</code>的，但实际上在GASDocumentation中，又再一次生成了这个移动组件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GDCharacterBase.cpp</span></span><br><span class="line"><span class="comment">// Sets default values</span></span><br><span class="line">AGDCharacterBase::AGDCharacterBase(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) :</span><br><span class="line">    Super(ObjectInitializer.SetDefaultSubobjectClass&lt;UGDCharacterMovementComponent&gt;(ACharacter::CharacterMovementComponentName))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.</span></span><br><span class="line">    PrimaryActorTick.bCanEverTick = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    GetCapsuleComponent()-&gt;SetCollisionResponseToChannel(ECollisionChannel::ECC_Visibility, ECollisionResponse::ECR_Overlap);</span><br><span class="line"></span><br><span class="line">    bAlwaysRelevant = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乍看一下好帅啊这个组件生成方法，但是这个是有其特殊用意的。</p>
<p>这个<strong>SetDefaultSubjectClass</strong>是用来做什么的呢？这个问题竟然回到了我之前一直疑惑的问题上。</p>
<h4 id="Constructor-with-or-without-FObjectInitializer"><a href="#Constructor-with-or-without-FObjectInitializer" class="headerlink" title="Constructor with or without FObjectInitializer"></a>Constructor with or without FObjectInitializer</h4><p>关于UE4中C++的构造函数的问题，我们有三种方式来实现UE4中的构造函数</p>
<ul>
<li>不声明构造函数</li>
<li>声明一个无参的默认构造函数</li>
<li>声明一个<code>FObjectInitializer</code>参数的构造函数</li>
</ul>
<p>写法网上一搜都有，说不定我哪篇文章也写过。</p>
<p>第一种是UE4的<code>GENERATED_BODY()</code>宏会生成构造函数，即使不特意的声明也没有问题。貌似生成的Constructor会存在与<code>XXX.generated.h</code>文件中。</p>
<p>第二种则是我经常用的方式，毕竟还多几行代码，看起来好看，也是最常规最常见的。</p>
<p>第三种，要在什么情况下使用呢？</p>
<blockquote>
<p>as long you dont have to replace any base component (such as replacing the MovementComponent class) that basic constructor works just fine if you do not use the GENERATED_CLASS_BODY() macro. (using GENERATED_BODY() instead).</p>
</blockquote>
<p>来自问题<a href="https://forums.unrealengine.com/development-discussion/c-gameplay-programming/97550-constructor-with-or-without-fobjectinitializer" target="_blank" rel="noopener">Constructor with or without FObjectInitializer</a></p>
<p>大意就是说在没有<strong>替换组件例如MovementComponent</strong>的时候，第二种构造函数没有问题。</p>
<p>所以就引出了这一小节的主角</p>
<h4 id="ObjectInitializer控制组件生成"><a href="#ObjectInitializer控制组件生成" class="headerlink" title="ObjectInitializer控制组件生成"></a>ObjectInitializer控制组件生成</h4><p>也就是这篇<a href="https://historia.co.jp/archives/6587/" target="_blank" rel="noopener">UE4 ObjectInitializerでコンポーネント生成を制御する</a></p>
<p>关于宏生成构造函数的解说在上面的文章很详细，我也是：啊啊，好像是那样。</p>
<p>那么什么情况下我们非要使用带有<strong>ObjectInitializer</strong>的构造函数不可呢？</p>
<p>与其相关的最常见到的就是<code>CreateDefaultSubobject</code>这个函数了。在Constructor中生成Component。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USceneComponent* SceneComponent = ObjectInitializer.CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>想用这招的话，看起来好像非这种构造函数不可了，但实际上：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USceneComponent* SceneComponent = CreateDefaultSubobject&lt;USceneComponent&gt;(TEXT(<span class="string">"SceneComponent"</span>));</span><br></pre></td></tr></table></figure></p>
<p>这种写法也是对的，因为UObject为其提供了同名的包装方法(wrap function)。</p>
<p>所以只有这个<strong>CreateDefaultSubobject</strong>也不是一定要用第三种构造函数。</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CreateEditorOnlyDefaultSubobject</td>
<td>エディタのみで有効なコンポーネントを作成する</td>
</tr>
<tr>
<td>CreateOptionalDefaultSubobject</td>
<td>作られなくても良い（動作には必ずしも必要無い）コンポーネントを作成する※ これは後述する関数と組み合わせて利用します</td>
</tr>
<tr>
<td>CreateAbstractDefaultSubobject</td>
<td>Abstract 属性のクラスは CreateDefaultSubobject を使うと作成できないようになっているので、必要な場合は明示的にこの関数を利用する</td>
</tr>
</tbody>
</table>
<p>上面的函数的使用对于ObjectInitializer的需要都不是必须的，但是除了这些之外的，就要了。</p>
<blockquote>
<p>これらのみを利用する場合は ObjectInitializer を利用する必要性はありません。</p>
<p>逆に言えば、<strong>これら以外の ObjectInitializer が提供するAPIを利用したい時は引数に与える必要性がある</strong> ということです。</p>
<p>UObject でラップされていない、ObjectInitializer が提供する関数は以下のものがあります。</p>
</blockquote>
<table>
<thead>
<tr>
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>SetDefaultSubobjectClass</td>
<td>親クラスがコンポーネントを作成する時、そのコンポーネントのクラスを名前指定で上書きする <br>※ 親クラスが作成するコンポーネントから派生したコンポーネントのみが指定できます</td>
</tr>
<tr>
<td>DoNotCreateDefaultSubobject</td>
<td>CreateOptionalDefaultSubobject でコンポーネントを作成する時、名前指定でコンポーネントの作成を無効化できる</td>
</tr>
</tbody>
</table>
<p>其中尤为重要的就是<strong>SetDefaultSubobjectClass</strong>,最常用的例子就是<code>UCharacterMovementComponent</code>是ACharacter默认提供的功能，如果我们想为其提供自定义的MovementComponent，那就使用这个函数，覆盖ACharacter提供的默认的移动组件。</p>
<p>至于怎么用，就像上面那么用。</p>
<blockquote>
<p>ちなみに SetDefaultSubobjectClass 及び DoNotCreateDefaultSubobject の戻り値は FObjectInitializer のコピーなので、メソッドチェーンで記述することが可能です。</p>
</blockquote>
<p>呃，这个意思不太懂。</p>
<h4 id="Camera组件"><a href="#Camera组件" class="headerlink" title="Camera组件"></a>Camera组件</h4><p>接下来是要为我们的Character添加摄像机，一个是<strong>CameraComponent</strong>，另一个是<strong>SpringArmComponent</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AGDHeroCharacter::AGDHeroCharacter(<span class="keyword">const</span> class FObjectInitializer&amp; ObjectInitializer) : Super(ObjectInitializer)</span><br><span class="line">&#123;</span><br><span class="line">    CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(FName(<span class="string">"CameraBoom"</span>));</span><br><span class="line">    CameraBoom-&gt;SetupAttachment(RootComponent);</span><br><span class="line">    CameraBoom-&gt;bUsePawnControlRotation = <span class="literal">true</span>;</span><br><span class="line">    CameraBoom-&gt;SetRelativeLocation(FVector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">68.492264</span>));</span><br><span class="line"></span><br><span class="line">    FollowCamera = CreateDefaultSubobject&lt;UCameraComponent&gt;(FName(<span class="string">"FollowCamera"</span>));</span><br><span class="line">    FollowCamera-&gt;SetupAttachment(CameraBoom);</span><br><span class="line">    FollowCamera-&gt;FieldOfView = <span class="number">80.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现就像上面那样，别问我为什么要那么实现，我也不知道。</p>
<h5 id="SpringArmComponent"><a href="#SpringArmComponent" class="headerlink" title="SpringArmComponent"></a>SpringArmComponent</h5><p>相机臂组件，是我之前一直忽略的组件，但是最近一点点觉得可能这个组件很重要。因为大多数的3D游戏对镜头的操纵极为重要，流畅华丽的镜头切换是会让人心情舒畅的。</p>
<p>但是我不知道那些游戏里镜头的移动是否是依赖于这个组件…</p>
<p>默认的情况下CameraBoom（上面的SpringArmComponent）是有碰撞判定的，即相机和Character之间有物体的话会缩短相机臂的距离，如果不想要这个功能的话</p>
<p>接上面的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// これだけでカメラの当たり判定が無効になる</span></span><br><span class="line">  CameraBoom-&gt;bDoCollisionTest = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></p>
<p>貌似可以实现一些物体加速的相机追踪延迟的效果，但是要是想实现更丰富的镜头切换应该需要更多的自定义。</p>
<p>暂时先挖个坑。</p>
<h4 id="SetupPlayerInputComponent"><a href="#SetupPlayerInputComponent" class="headerlink" title="SetupPlayerInputComponent"></a>SetupPlayerInputComponent</h4><p>用来设置键位的组件，需要override这个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line">    <span class="comment">// Called to bind functionality to input</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetupPlayerInputComponent</span><span class="params">(class UInputComponent* PlayerInputComponent)</span> override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="comment">// Called to bind functionality to input</span></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)</span><br><span class="line">&#123;</span><br><span class="line">    Super::SetupPlayerInputComponent(PlayerInputComponent);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveForward"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveForward);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"MoveRight"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::MoveRight);</span><br><span class="line"></span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUp"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUp);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"LookUpRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::LookUpRate);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"Turn"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::Turn);</span><br><span class="line">    PlayerInputComponent-&gt;BindAxis(<span class="string">"TurnRate"</span>, <span class="keyword">this</span>, &amp;AGDHeroCharacter::TurnRate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bind player input to the AbilitySystemComponent. Also called in OnRep_PlayerState because of a potential race condition.</span></span><br><span class="line">    BindASCInput();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUp(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::LookUpRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerPitchInput(Value * BaseLookUpRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::Turn(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::TurnRate(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsAlive())</span><br><span class="line">    &#123;</span><br><span class="line">        AddControllerYawInput(Value * BaseTurnRate * GetWorld()-&gt;DeltaTimeSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveForward(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetForwardVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AGDHeroCharacter::MoveRight(<span class="keyword">float</span> Value)</span><br><span class="line">&#123;</span><br><span class="line">    AddMovementInput(UKismetMathLibrary::GetRightVector(FRotator(<span class="number">0</span>, GetControlRotation().Yaw, <span class="number">0</span>)), Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我就粘贴上大概的实现，反正要找的话都能找到。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/UE4/" rel="tag"># UE4</a>
              <a href="/tags/ActionRPG/" rel="tag"># ActionRPG</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/csharp-attribute/" rel="prev" title="CSharp-Attribute的理解与使用">
      <i class="fa fa-chevron-left"></i> CSharp-Attribute的理解与使用
    </a></div>
      <div class="post-nav-item">
    <a href="/ue4-multiplay-framework/" rel="next" title="UE4-多人游戏框架理解">
      UE4-多人游戏框架理解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GamePlay-Guide"><span class="nav-number">1.</span> <span class="nav-text">GamePlay Guide</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Gameplay-Ability-System"><span class="nav-number">1.1.</span> <span class="nav-text">Gameplay Ability System</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ActionRPG"><span class="nav-number">2.</span> <span class="nav-text">ActionRPG</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ActionRPG内容分析"><span class="nav-number">2.1.</span> <span class="nav-text">ActionRPG内容分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ActionRPG练习"><span class="nav-number">2.2.</span> <span class="nav-text">ActionRPG练习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GameplayAbilities-and-you"><span class="nav-number">3.</span> <span class="nav-text">GameplayAbilities and you</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">3.1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Getting-Started"><span class="nav-number">3.2.</span> <span class="nav-text">Getting Started</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-the-Project"><span class="nav-number">3.2.1.</span> <span class="nav-text">Setting up the Project</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建第一个GamePlayAbility-blueprint"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">创建第一个GamePlayAbility blueprint</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-our-Charactor"><span class="nav-number">3.2.2.</span> <span class="nav-text">Setting up our Charactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Binding-to-Character-input"><span class="nav-number">3.2.3.</span> <span class="nav-text">Binding to Character input</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Giving-the-Character-an-Ability"><span class="nav-number">3.2.4.</span> <span class="nav-text">Giving the Character an Ability</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Essentials-要点"><span class="nav-number">3.3.</span> <span class="nav-text">The Essentials (要点)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayAbilities"><span class="nav-number">3.3.1.</span> <span class="nav-text">GameplayAbilities</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayTasks"><span class="nav-number">3.3.2.</span> <span class="nav-text">GameplayTasks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayEffects"><span class="nav-number">3.3.3.</span> <span class="nav-text">GameplayEffects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AttributeSet"><span class="nav-number">3.3.4.</span> <span class="nav-text">AttributeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GASDocumentation"><span class="nav-number">4.</span> <span class="nav-text">GASDocumentation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GASDocumentation的个人翻译和理解"><span class="nav-number">4.1.</span> <span class="nav-text">GASDocumentation的个人翻译和理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Intro-to-the-GameplayAbilitySystem-Plugin"><span class="nav-number">4.1.1.</span> <span class="nav-text">Intro to the GameplayAbilitySystem Plugin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-Up-a-Project-Using-GAS"><span class="nav-number">4.1.2.</span> <span class="nav-text">Setting Up a Project Using GAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbilitySystemComponent"><span class="nav-number">4.1.3.</span> <span class="nav-text">AbilitySystemComponent</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Replication-Mode"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">Replication Mode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Setup-and-Initialization"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">Setup and Initialization</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gameplay-Tags"><span class="nav-number">4.1.4.</span> <span class="nav-text">Gameplay Tags</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GameplayTag有变动的函数回调"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">GameplayTag有变动的函数回调</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attributes"><span class="nav-number">4.1.5.</span> <span class="nav-text">Attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute-定义"><span class="nav-number">4.1.5.1.</span> <span class="nav-text">Attribute 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BaseValue-vs-CurrentValue"><span class="nav-number">4.1.5.2.</span> <span class="nav-text">BaseValue vs CurrentValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Meta-Attributes"><span class="nav-number">4.1.5.3.</span> <span class="nav-text">Meta Attributes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Responding-to-Attribute-Changes"><span class="nav-number">4.1.5.4.</span> <span class="nav-text">Responding to Attribute Changes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Derived-Attributes"><span class="nav-number">4.1.5.5.</span> <span class="nav-text">Derived Attributes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attribute-Set"><span class="nav-number">4.1.6.</span> <span class="nav-text">Attribute Set</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute-Set定义"><span class="nav-number">4.1.6.1.</span> <span class="nav-text">Attribute Set定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何设计AttributeSet"><span class="nav-number">4.1.6.2.</span> <span class="nav-text">如何设计AttributeSet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#运行时添加或移除AttributeSet"><span class="nav-number">4.1.6.2.1.</span> <span class="nav-text">运行时添加或移除AttributeSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用float来替代AttributeSet"><span class="nav-number">4.1.6.2.2.</span> <span class="nav-text">使用float来替代AttributeSet</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Attributes定义"><span class="nav-number">4.1.6.3.</span> <span class="nav-text">Attributes定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute的初始化"><span class="nav-number">4.1.6.4.</span> <span class="nav-text">Attribute的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PreAttributeChange-函数"><span class="nav-number">4.1.6.5.</span> <span class="nav-text">PreAttributeChange()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PostGameplayEffectExecute-函数"><span class="nav-number">4.1.6.6.</span> <span class="nav-text">PostGameplayEffectExecute()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OnAtttributeAggregatorCreate-函数"><span class="nav-number">4.1.6.7.</span> <span class="nav-text">OnAtttributeAggregatorCreate()函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Granting-Abilitie"><span class="nav-number">4.1.6.8.</span> <span class="nav-text">Granting Abilitie</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Activating-Abilities-激活"><span class="nav-number">4.1.6.9.</span> <span class="nav-text">Activating Abilities 激活</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Passive-Abilities被动"><span class="nav-number">4.1.6.9.1.</span> <span class="nav-text">Passive Abilities被动</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Canceling-Abilities取消"><span class="nav-number">4.1.6.10.</span> <span class="nav-text">Canceling Abilities取消</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取Active-Ability"><span class="nav-number">4.1.6.11.</span> <span class="nav-text">获取Active Ability</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instancing-Policy"><span class="nav-number">4.1.6.12.</span> <span class="nav-text">Instancing Policy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Net-Execution-Policy"><span class="nav-number">4.1.6.13.</span> <span class="nav-text">Net Execution Policy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ability-Tags"><span class="nav-number">4.1.6.14.</span> <span class="nav-text">Ability Tags</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gameplay-Ability-Spec"><span class="nav-number">4.1.6.15.</span> <span class="nav-text">Gameplay Ability Spec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向Ability中传递数据"><span class="nav-number">4.1.6.16.</span> <span class="nav-text">向Ability中传递数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ability-Cost-and-Cooldown"><span class="nav-number">4.1.6.17.</span> <span class="nav-text">Ability Cost and Cooldown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ability-Sets"><span class="nav-number">4.1.6.18.</span> <span class="nav-text">Ability Sets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ability-Batching"><span class="nav-number">4.1.6.19.</span> <span class="nav-text">Ability Batching</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Net-Security-Policy"><span class="nav-number">4.1.6.20.</span> <span class="nav-text">Net Security Policy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ability-Task"><span class="nav-number">4.1.7.</span> <span class="nav-text">Ability Task</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ability-Task定义"><span class="nav-number">4.1.7.1.</span> <span class="nav-text">Ability Task定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gameplay-Cues"><span class="nav-number">4.1.8.</span> <span class="nav-text">Gameplay Cues</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Gameplay-Cues定义"><span class="nav-number">4.1.8.1.</span> <span class="nav-text">Gameplay Cues定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbilitySystemGlobals"><span class="nav-number">4.1.9.</span> <span class="nav-text">AbilitySystemGlobals</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InitGlobalData"><span class="nav-number">4.1.9.1.</span> <span class="nav-text">InitGlobalData()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prediction"><span class="nav-number">4.1.10.</span> <span class="nav-text">Prediction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Targeting"><span class="nav-number">4.1.11.</span> <span class="nav-text">Targeting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Target-Data"><span class="nav-number">4.1.11.1.</span> <span class="nav-text">Target Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GAS小结"><span class="nav-number">4.1.12.</span> <span class="nav-text">GAS小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GameplayAbilitySystem中重要的类，结构体"><span class="nav-number">4.2.</span> <span class="nav-text">GameplayAbilitySystem中重要的类，结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayAbilitySpec"><span class="nav-number">4.2.1.</span> <span class="nav-text">GameplayAbilitySpec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameplayEffect"><span class="nav-number">4.2.2.</span> <span class="nav-text">GameplayEffect</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FGameplayEffectContext"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">FGameplayEffectContext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FGameplayEffectContextHandle"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">FGameplayEffectContextHandle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputBind"><span class="nav-number">4.2.3.</span> <span class="nav-text">InputBind</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些小的知识点"><span class="nav-number">4.3.</span> <span class="nav-text">一些小的知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OnAvatarSet"><span class="nav-number">4.3.1.</span> <span class="nav-text">OnAvatarSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitDelay"><span class="nav-number">4.3.2.</span> <span class="nav-text">WaitDelay</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从零开始搭建一个GAS工程"><span class="nav-number">5.</span> <span class="nav-text">从零开始搭建一个GAS工程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个空白的项目，准备导入GAS"><span class="nav-number">5.1.</span> <span class="nav-text">创建一个空白的项目，准备导入GAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GameMode"><span class="nav-number">5.1.1.</span> <span class="nav-text">GameMode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pawn"><span class="nav-number">5.1.2.</span> <span class="nav-text">Pawn</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor-with-or-without-FObjectInitializer"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">Constructor with or without FObjectInitializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectInitializer控制组件生成"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">ObjectInitializer控制组件生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Camera组件"><span class="nav-number">5.1.2.3.</span> <span class="nav-text">Camera组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringArmComponent"><span class="nav-number">5.1.2.3.1.</span> <span class="nav-text">SpringArmComponent</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SetupPlayerInputComponent"><span class="nav-number">5.1.2.4.</span> <span class="nav-text">SetupPlayerInputComponent</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="stone"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">stone</p>
  <div class="site-description" itemprop="description">爱自己，对爱你的人来说，是最大的安慰</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/stonelzp" title="GitHub → https://github.com/stonelzp" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stone</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>












  

  

</body>
</html>
